<!DOCTYPE html>
<html>
<head>
  <meta charset="utf-8">
  <title>设计模式 | 单例模式及典型应用 | 小旋锋</title>
  <meta name="keywords" content=" 设计模式 ">
  <meta name="description" content="设计模式 | 单例模式及典型应用 | 小旋锋">
    <meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1">
<meta name="description" content="单例是最常见的设计模式之一，实现的方式非常多，同时需要注意的问题也非常多。 本文主要内容：  介绍单例模式 介绍单例模式的N中写法 单例模式的安全性 序列化攻击 反射攻击   单例模式总结 介绍单例模式的典型应用  单例模式单例模式(Singleton Pattern)：确保某一个类只有一个实例，而且自行实例化并向整个系统提供这个实例，这个类称为单例类，它提供全局访问的方法。单例模式是一种对象创建">
<meta name="keywords" content="Java,设计模式,单例模式">
<meta property="og:type" content="article">
<meta property="og:title" content="设计模式 | 单例模式及典型应用">
<meta property="og:url" content="http://laijianfeng.org/2019/01/设计模式-单例模式及典型应用/index.html">
<meta property="og:site_name" content="小旋锋">
<meta property="og:description" content="单例是最常见的设计模式之一，实现的方式非常多，同时需要注意的问题也非常多。 本文主要内容：  介绍单例模式 介绍单例模式的N中写法 单例模式的安全性 序列化攻击 反射攻击   单例模式总结 介绍单例模式的典型应用  单例模式单例模式(Singleton Pattern)：确保某一个类只有一个实例，而且自行实例化并向整个系统提供这个实例，这个类称为单例类，它提供全局访问的方法。单例模式是一种对象创建">
<meta property="og:locale" content="zh-Hans">
<meta property="og:image" content="http://image.laijianfeng.org/20180913_001328.png">
<meta property="og:updated_time" content="2019-01-06T17:37:03.276Z">
<meta name="twitter:card" content="summary">
<meta name="twitter:title" content="设计模式 | 单例模式及典型应用">
<meta name="twitter:description" content="单例是最常见的设计模式之一，实现的方式非常多，同时需要注意的问题也非常多。 本文主要内容：  介绍单例模式 介绍单例模式的N中写法 单例模式的安全性 序列化攻击 反射攻击   单例模式总结 介绍单例模式的典型应用  单例模式单例模式(Singleton Pattern)：确保某一个类只有一个实例，而且自行实例化并向整个系统提供这个实例，这个类称为单例类，它提供全局访问的方法。单例模式是一种对象创建">
<meta name="twitter:image" content="http://image.laijianfeng.org/20180913_001328.png">


<link rel="icon" href="/img/favicon.jpg">

<link rel="stylesheet" href="/css/style.css">

<link rel="stylesheet" href="/css/hl_theme/darcula.css">

<link href="//cdn.bootcss.com/animate.css/3.5.2/animate.min.css" rel="stylesheet">
<link href="//cdn.bootcss.com/font-awesome/4.7.0/css/font-awesome.min.css" rel="stylesheet">

<link href="//cdn.bootcss.com/photoswipe/4.1.2/photoswipe.min.css" rel="stylesheet">
<link href="//cdn.bootcss.com/photoswipe/4.1.2/default-skin/default-skin.min.css" rel="stylesheet">

<script src="//cdn.bootcss.com/jquery/2.2.4/jquery.min.js"></script>
<script src="/js/jquery.autocomplete.min.js"></script>
<script src="//cdn.bootcss.com/highlight.js/9.12.0/highlight.min.js"></script>
<script>
    hljs.initHighlightingOnLoad();
</script>

<script src="//cdn.bootcss.com/nprogress/0.2.0/nprogress.min.js"></script>



</head>
<div style="display: none">
  <input class="theme_disqus_on" value="false">
  <input class="theme_preload_comment" value="true">
</div>
<body>
<aside class="nav">
    <div class="nav-left">
        <a href="/" class="avatar_target">
    <img class="avatar" src="/img/avatar.jpg" />
</a>
<div class="author">
    <span>小旋锋</span>
</div>

<div class="icon">
    
    <a class="rss" title="rss" href="/atom.xml" target="_blank"></a>
    
    
    <a class="github" title="github" href="https://github.com/whirlys" target="_blank"></a>
    
    
    
    
    
    
    
    
    <a class="email" title="email" href="mailto:whirlys@163.com"></a>
    
</div>



<ul>
    <li class="all active">全部文章</li>
    
    <li data-rel="生活杂记"> 生活杂记 </li>
    
    <li data-rel="后端"> 后端 </li>
    
    <li data-rel="大数据"> 大数据 </li>
    
    <li data-rel="读书"> 读书 </li>
    
</ul>
<div class="left-bottom">
    <div class="menus">
    
    </div>
    <div><a  class="friends">友链</a></div>
</div>
<input type="hidden" id="yelog_site_posts_number" value="38">
<input type="hidden" id="yelog_site_word_count" value="116.8k">
<div style="display: none">
    <span id="busuanzi_value_site_uv"></span>
    <span id="busuanzi_value_site_pv"></span>
</div>
    </div>
    <div class="nav-right">
        <div class="friends-area">
    <div class="friends-title">
        友情链接
        <i class="back-title-list"></i>
    </div>
    <div class="friends-content">
        <ul>
            
            <li><a target="_blank" href="http://yelog.org/">叶落阁</a></li>
            
            <li><a target="_blank" href="https://godbmw.com/">GODBMW</a></li>
            
            <li><a target="_blank" href="http://www.codesheep.cn/">CodeSheep 程序羊</a></li>
            
            <li><a target="_blank" href="http://www.hualong.me/">刘华龙的小窝</a></li>
            
        </ul>
    </div>
</div>
        <div class="title-list">
    <form onkeydown="if(event.keyCode==13){return false;}">
        <input class="search" type="text" placeholder="以 in: 开头进行全文搜索" autocomplete="off"id="local-search-input" >
        <i class="cross"></i>
        <span>
        <label for="tagswitch">Tags:</label>
        <input id="tagswitch" type="checkbox">
    </span>
    </form>
    <div class="tags-list">
    
    <li class="article-tag-list-item">
        <a href="javascript:" class="color2">Java编程</a>
    </li>
    
    <li class="article-tag-list-item">
        <a href="javascript:" class="color4">elasticsearch</a>
    </li>
    
    <li class="article-tag-list-item">
        <a href="javascript:" class="color5">java</a>
    </li>
    
    <li class="article-tag-list-item">
        <a href="javascript:" class="color2">lucene</a>
    </li>
    
    <li class="article-tag-list-item">
        <a href="javascript:" class="color1">spark</a>
    </li>
    
    <li class="article-tag-list-item">
        <a href="javascript:" class="color3">博客</a>
    </li>
    
    <li class="article-tag-list-item">
        <a href="javascript:" class="color5">设计模式</a>
    </li>
    
    <div class="clearfix"></div>
</div>

    
    <div id="local-search-result">

    </div>
    
    <nav id="title-list-nav">
        
        <a  class="后端 "
           href="/2019/01/设计模式-解释器模式及典型应用/"
           data-tag="设计模式"
           data-author="" >
            <span class="post-title" title="设计模式 | 解释器模式及典型应用">设计模式 | 解释器模式及典型应用</span>
            <span class="post-date" title="2019-01-13 16:35:37">2019/01/13</span>
        </a>
        
        <a  class="后端 "
           href="/2019/01/ArrayList-源码分析/"
           data-tag="Java编程"
           data-author="" >
            <span class="post-title" title="ArrayList 源码分析">ArrayList 源码分析</span>
            <span class="post-date" title="2019-01-09 20:21:09">2019/01/09</span>
        </a>
        
        <a  class="大数据 "
           href="/2019/01/Elasticsearch源码分析-单节点的启动和关闭/"
           data-tag="elasticsearch"
           data-author="" >
            <span class="post-title" title="Elasticsearch源码分析 | 单节点的启动和关闭">Elasticsearch源码分析 | 单节点的启动和关闭</span>
            <span class="post-date" title="2019-01-08 01:58:56">2019/01/08</span>
        </a>
        
        <a  class="后端 "
           href="/2019/01/设计模式-单例模式及典型应用/"
           data-tag="设计模式"
           data-author="" >
            <span class="post-title" title="设计模式 | 单例模式及典型应用">设计模式 | 单例模式及典型应用</span>
            <span class="post-date" title="2019-01-07 01:35:54">2019/01/07</span>
        </a>
        
        <a  class="后端 "
           href="/2018/12/Java-动态代理详解/"
           data-tag="Java编程"
           data-author="" >
            <span class="post-title" title="Java 动态代理详解">Java 动态代理详解</span>
            <span class="post-date" title="2018-12-21 01:46:11">2018/12/21</span>
        </a>
        
        <a  class="后端 "
           href="/2018/12/Java反射机制详解/"
           data-tag="Java编程"
           data-author="" >
            <span class="post-title" title="Java反射机制详解">Java反射机制详解</span>
            <span class="post-date" title="2018-12-19 02:08:32">2018/12/19</span>
        </a>
        
        <a  class="大数据 "
           href="/2018/12/Spark-SQL-分析-Imooc-访问日志/"
           data-tag="spark"
           data-author="" >
            <span class="post-title" title="Spark SQL 分析 Nginx 访问日志">Spark SQL 分析 Nginx 访问日志</span>
            <span class="post-date" title="2018-12-16 19:45:35">2018/12/16</span>
        </a>
        
        <a  class="后端 "
           href="/2018/10/设计模式-责任链模式及典型应用/"
           data-tag="设计模式"
           data-author="" >
            <span class="post-title" title="设计模式 | 责任链模式及典型应用">设计模式 | 责任链模式及典型应用</span>
            <span class="post-date" title="2018-10-31 15:16:12">2018/10/31</span>
        </a>
        
        <a  class="后端 "
           href="/2018/10/设计模式-中介者模式及典型应用/"
           data-tag="设计模式"
           data-author="" >
            <span class="post-title" title="设计模式 | 中介者模式及典型应用">设计模式 | 中介者模式及典型应用</span>
            <span class="post-date" title="2018-10-26 00:45:30">2018/10/26</span>
        </a>
        
        <a  class="后端 "
           href="/2018/10/设计模式-备忘录模式及典型应用/"
           data-tag="设计模式"
           data-author="" >
            <span class="post-title" title="设计模式 | 备忘录模式及典型应用">设计模式 | 备忘录模式及典型应用</span>
            <span class="post-date" title="2018-10-25 00:42:24">2018/10/25</span>
        </a>
        
        <a  class="后端 "
           href="/2018/10/设计模式-观察者模式及典型应用/"
           data-tag="设计模式"
           data-author="" >
            <span class="post-title" title="设计模式 | 观察者模式及典型应用">设计模式 | 观察者模式及典型应用</span>
            <span class="post-date" title="2018-10-24 00:30:56">2018/10/24</span>
        </a>
        
        <a  class="后端 "
           href="/2018/10/设计模式-策略模式及典型应用/"
           data-tag="设计模式"
           data-author="" >
            <span class="post-title" title="设计模式 | 策略模式及典型应用">设计模式 | 策略模式及典型应用</span>
            <span class="post-date" title="2018-10-18 20:33:43">2018/10/18</span>
        </a>
        
        <a  class="生活杂记 "
           href="/2018/10/20181013-燃烧吧，破铜烂铁！/"
           data-tag=""
           data-author="" >
            <span class="post-title" title="20181013-燃烧吧，破铜烂铁！">20181013-燃烧吧，破铜烂铁！</span>
            <span class="post-date" title="2018-10-13 22:01:20">2018/10/13</span>
        </a>
        
        <a  class="后端 "
           href="/2018/10/设计模式-迭代器模式及典型应用/"
           data-tag="设计模式"
           data-author="" >
            <span class="post-title" title="设计模式 | 迭代器模式及典型应用">设计模式 | 迭代器模式及典型应用</span>
            <span class="post-date" title="2018-10-11 23:04:40">2018/10/11</span>
        </a>
        
        <a  class="后端 "
           href="/2018/10/设计模式-模板方法模式及典型应用/"
           data-tag="设计模式"
           data-author="" >
            <span class="post-title" title="设计模式 | 模板方法模式及典型应用">设计模式 | 模板方法模式及典型应用</span>
            <span class="post-date" title="2018-10-11 00:22:11">2018/10/11</span>
        </a>
        
        <a  class="后端 "
           href="/2018/10/设计模式-组合模式及典型应用/"
           data-tag="设计模式"
           data-author="" >
            <span class="post-title" title="设计模式 | 组合模式及典型应用">设计模式 | 组合模式及典型应用</span>
            <span class="post-date" title="2018-10-05 17:18:04">2018/10/05</span>
        </a>
        
        <a  class="后端 "
           href="/2018/09/设计模式-享元模式及典型应用/"
           data-tag="设计模式"
           data-author="" >
            <span class="post-title" title="设计模式 | 享元模式及典型应用">设计模式 | 享元模式及典型应用</span>
            <span class="post-date" title="2018-09-25 01:15:00">2018/09/25</span>
        </a>
        
        <a  class="后端 "
           href="/2018/09/设计模式-适配器模式及典型应用/"
           data-tag="设计模式"
           data-author="" >
            <span class="post-title" title="设计模式 | 适配器模式及典型应用">设计模式 | 适配器模式及典型应用</span>
            <span class="post-date" title="2018-09-20 01:00:54">2018/09/20</span>
        </a>
        
        <a  class="后端 "
           href="/2018/09/设计模式-装饰者模式及典型应用/"
           data-tag="设计模式"
           data-author="" >
            <span class="post-title" title="设计模式 | 装饰者模式及典型应用">设计模式 | 装饰者模式及典型应用</span>
            <span class="post-date" title="2018-09-18 20:44:31">2018/09/18</span>
        </a>
        
        <a  class="后端 "
           href="/2018/09/设计模式-外观模式及典型应用/"
           data-tag="设计模式"
           data-author="" >
            <span class="post-title" title="设计模式 | 外观模式及典型应用">设计模式 | 外观模式及典型应用</span>
            <span class="post-date" title="2018-09-16 20:29:56">2018/09/16</span>
        </a>
        
        <a  class="后端 "
           href="/2018/09/设计模式-原型模式及典型应用/"
           data-tag="设计模式"
           data-author="" >
            <span class="post-title" title="设计模式 | 原型模式及典型应用">设计模式 | 原型模式及典型应用</span>
            <span class="post-date" title="2018-09-15 00:08:13">2018/09/15</span>
        </a>
        
        <a  class="后端 "
           href="/2018/09/设计模式-建造者模式及典型应用/"
           data-tag="设计模式"
           data-author="" >
            <span class="post-title" title="设计模式 | 建造者模式及典型应用">设计模式 | 建造者模式及典型应用</span>
            <span class="post-date" title="2018-09-12 00:39:42">2018/09/12</span>
        </a>
        
        <a  class="后端 "
           href="/2018/09/设计模式之抽象工厂模式及典型应用/"
           data-tag="设计模式"
           data-author="" >
            <span class="post-title" title="设计模式 | 抽象工厂模式及典型应用">设计模式 | 抽象工厂模式及典型应用</span>
            <span class="post-date" title="2018-09-10 23:51:05">2018/09/10</span>
        </a>
        
        <a  class="后端 "
           href="/2018/09/设计模式之工厂方法模式及典型应用/"
           data-tag="设计模式"
           data-author="" >
            <span class="post-title" title="设计模式 | 工厂方法模式及典型应用">设计模式 | 工厂方法模式及典型应用</span>
            <span class="post-date" title="2018-09-09 17:20:14">2018/09/09</span>
        </a>
        
        <a  class="后端 "
           href="/2018/09/设计模式-简单工厂模式及典型应用/"
           data-tag="设计模式"
           data-author="" >
            <span class="post-title" title="设计模式 | 简单工厂模式及典型应用">设计模式 | 简单工厂模式及典型应用</span>
            <span class="post-date" title="2018-09-07 23:13:45">2018/09/07</span>
        </a>
        
        <a  class="大数据 "
           href="/2018/09/Elasticsearch-6-3-2-启动过程/"
           data-tag="elasticsearch"
           data-author="" >
            <span class="post-title" title="Elasticsearch 6.3.2 启动过程">Elasticsearch 6.3.2 启动过程</span>
            <span class="post-date" title="2018-09-01 20:25:45">2018/09/01</span>
        </a>
        
        <a  class="后端 "
           href="/2018/08/Google-guava工具类的介绍和使用/"
           data-tag="java"
           data-author="" >
            <span class="post-title" title="Google guava工具类的介绍和使用">Google guava工具类的介绍和使用</span>
            <span class="post-date" title="2018-08-31 00:58:57">2018/08/31</span>
        </a>
        
        <a  class="大数据 "
           href="/2018/08/Elasticsearch-中的-Guice/"
           data-tag="elasticsearch"
           data-author="" >
            <span class="post-title" title="Elasticsearch 中的 Guice">Elasticsearch 中的 Guice</span>
            <span class="post-date" title="2018-08-31 00:39:17">2018/08/31</span>
        </a>
        
        <a  class="读书 "
           href="/2018/08/鼓舞人心/"
           data-tag=""
           data-author="" >
            <span class="post-title" title="鼓舞人心">鼓舞人心</span>
            <span class="post-date" title="2018-08-27 19:51:31">2018/08/27</span>
        </a>
        
        <a  class="大数据 "
           href="/2018/08/Elasticsearch-分布式特性/"
           data-tag="elasticsearch"
           data-author="" >
            <span class="post-title" title="Elasticsearch 分布式特性">Elasticsearch 分布式特性</span>
            <span class="post-date" title="2018-08-25 18:29:15">2018/08/25</span>
        </a>
        
        <a  class="大数据 "
           href="/2018/08/23个最有用的ES检索技巧-Java-API实现/"
           data-tag="elasticsearch"
           data-author="" >
            <span class="post-title" title="23个最有用的ES检索技巧(Java API实现)">23个最有用的ES检索技巧(Java API实现)</span>
            <span class="post-date" title="2018-08-25 13:19:00">2018/08/25</span>
        </a>
        
        <a  class="大数据 "
           href="/2018/08/教你编译调试Elasticsearch-6-3-2源码/"
           data-tag="elasticsearch"
           data-author="" >
            <span class="post-title" title="教你编译调试Elasticsearch 6.3.2源码">教你编译调试Elasticsearch 6.3.2源码</span>
            <span class="post-date" title="2018-08-23 11:39:34">2018/08/23</span>
        </a>
        
        <a  class="生活杂记 "
           href="/2018/08/20180818音乐会/"
           data-tag=""
           data-author="" >
            <span class="post-title" title="20180818音乐会">20180818音乐会</span>
            <span class="post-date" title="2018-08-18 22:44:24">2018/08/18</span>
        </a>
        
        <a  class="大数据 "
           href="/2018/08/Lucene初体验/"
           data-tag="lucene"
           data-author="" >
            <span class="post-title" title="Lucene初体验">Lucene初体验</span>
            <span class="post-date" title="2018-08-18 16:23:02">2018/08/18</span>
        </a>
        
        <a  class="大数据 "
           href="/2018/08/Elasticsearch-6-x-Mapping设置/"
           data-tag="elasticsearch"
           data-author="" >
            <span class="post-title" title="Elasticsearch 6.x Mapping设置">Elasticsearch 6.x Mapping设置</span>
            <span class="post-date" title="2018-08-16 21:14:33">2018/08/16</span>
        </a>
        
        <a  class="大数据 "
           href="/2018/08/倒排索引与分词/"
           data-tag="elasticsearch"
           data-author="" >
            <span class="post-title" title="倒排索引与分词">倒排索引与分词</span>
            <span class="post-date" title="2018-08-15 23:50:57">2018/08/15</span>
        </a>
        
        <a  class="大数据 "
           href="/2018/08/ElasticSearch初体验/"
           data-tag="elasticsearch"
           data-author="" >
            <span class="post-title" title="ElasticSearch初体验">ElasticSearch初体验</span>
            <span class="post-date" title="2018-08-15 19:37:25">2018/08/15</span>
        </a>
        
        <a  class="后端 "
           href="/2018/05/使用hexo-github-pages搭建博客/"
           data-tag="博客"
           data-author="" >
            <span class="post-title" title="使用hexo+github pages搭建博客">使用hexo+github pages搭建博客</span>
            <span class="post-date" title="2018-05-23 11:35:46">2018/05/23</span>
        </a>
        
    </nav>
</div>
    </div>
    <div class="hide-list">
        <div class="semicircle">
            <div class="brackets first"><</div>
            <div class="brackets">&gt;</div>
        </div>
    </div>
</aside>
<div class="post">
    <div class="pjax">
        <article id="post-设计模式-单例模式及典型应用" class="article article-type-post" itemscope itemprop="blogPost">
    
        <h1 class="article-title">设计模式 | 单例模式及典型应用</h1>
    
    <div class="article-meta">
        
        
        
        <span class="book">
            
            <a href="javascript:" data-rel="后端">后端</a>
            
        </span>
        
        
        <span class="tag">
            
            <a href="javascript:" class="color5">设计模式</a>
            
        </span>
        
    </div>
    <div class="article-meta">
        
        创建时间:<time class="date" title='更新时间: 2019-01-07 01:37:03'>2019-01-07 01:35</time>
        
    </div>
    <div class="article-meta">
        
        <span>字数:5,251</span>
        
        
        <span id="busuanzi_container_page_pv">
            阅读:<span id="busuanzi_value_page_pv">
                <span class="count-comment">
                    <span class="spinner">
                      <div class="cube1"></div>
                      <div class="cube2"></div>
                    </span>
                </span>
            </span>
        </span>
        
        
        <span class="top-comment" title="跳转至评论区">
            <a href="#comments">
                评论:<span class="count-comment">
                    <span class="spinner">
                      <div class="cube1"></div>
                      <div class="cube2"></div>
                    </span>
                </span>
            </a>
        </span>
        
    </div>
    
    <div class="toc-ref">
    
        <ol class="toc"><li class="toc-item toc-level-3"><a class="toc-link" href="#单例模式"><span class="toc-text">单例模式</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#角色"><span class="toc-text">角色</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#单例模式的七种写法"><span class="toc-text">单例模式的七种写法</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#1、饿汉式"><span class="toc-text">1、饿汉式</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#2、饿汉式变种"><span class="toc-text">2、饿汉式变种</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#3、懒汉式"><span class="toc-text">3、懒汉式</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#4、懒汉式变种"><span class="toc-text">4、懒汉式变种</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#5、双重检查锁"><span class="toc-text">5、双重检查锁</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#6、静态内部类"><span class="toc-text">6、静态内部类</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#7、枚举"><span class="toc-text">7、枚举</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#单例模式的安全性"><span class="toc-text">单例模式的安全性</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#序列化攻击"><span class="toc-text">序列化攻击</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#Java-序列化机制"><span class="toc-text">Java 序列化机制</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#序列化破坏单例模式的解决方案"><span class="toc-text">序列化破坏单例模式的解决方案</span></a></li></ol></li><li class="toc-item toc-level-4"><a class="toc-link" href="#反射攻击"><span class="toc-text">反射攻击</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#反射攻击解决方案"><span class="toc-text">反射攻击解决方案</span></a></li></ol></li><li class="toc-item toc-level-4"><a class="toc-link" href="#为什么推荐使用枚举单例"><span class="toc-text">为什么推荐使用枚举单例</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#那么，为什么推荐使用枚举单例呢？"><span class="toc-text">那么，为什么推荐使用枚举单例呢？</span></a></li></ol></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#单例模式总结"><span class="toc-text">单例模式总结</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#单例模式的主要优点"><span class="toc-text">单例模式的主要优点</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#单例模式的主要缺点"><span class="toc-text">单例模式的主要缺点</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#适用场景"><span class="toc-text">适用场景</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#单例模式的典型应用"><span class="toc-text">单例模式的典型应用</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#JDK-Runtime-饿汉单例"><span class="toc-text">JDK Runtime 饿汉单例</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#AWT-Desktop-容器单例"><span class="toc-text">AWT Desktop 容器单例</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#spring-AbstractFactoryBean"><span class="toc-text">spring AbstractFactoryBean</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#Mybatis-ErrorContext-ThreadLocal"><span class="toc-text">Mybatis ErrorContext ThreadLocal</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#后记"><span class="toc-text">后记</span></a></li></ol>
    
<style>
    .left-col .switch-btn,
    .left-col .switch-area {
        display: none;
    }
    .toc-level-3 i,
    .toc-level-3 ol {
        display: none !important;
    }
</style>
</div>
    <div class="article-entry" itemprop="articleBody">
      
        <p>单例是最常见的设计模式之一，实现的方式非常多，同时需要注意的问题也非常多。</p>
<p>本文主要内容：</p>
<ul>
<li>介绍单例模式</li>
<li>介绍单例模式的N中写法</li>
<li>单例模式的安全性<ul>
<li>序列化攻击</li>
<li>反射攻击</li>
</ul>
</li>
<li>单例模式总结</li>
<li>介绍单例模式的典型应用</li>
</ul>
<h3 id="单例模式"><a href="#单例模式" class="headerlink" title="单例模式"></a>单例模式</h3><p><strong>单例模式(Singleton Pattern)</strong>：确保某一个类只有一个实例，而且自行实例化并向整个系统提供这个实例，这个类称为单例类，它提供全局访问的方法。单例模式是一种对象创建型模式。</p>
<p>单例模式有三个要点：</p>
<ol>
<li>构造方法私有化；</li>
<li>实例化的变量引用私有化；</li>
<li>获取实例的方法共有</li>
</ol>
<h4 id="角色"><a href="#角色" class="headerlink" title="角色"></a>角色</h4><p><strong>Singleton（单例）</strong>：在单例类的内部实现只生成一个实例，同时它提供一个静态的 <code>getInstance()</code> 工厂方法，让客户可以访问它的唯一实例；为了防止在外部对其实例化，将其构造函数设计为私有；在单例类内部定义了一个 <code>Singleton</code> 类型的静态对象，作为外部共享的唯一实例。</p>
<h3 id="单例模式的七种写法"><a href="#单例模式的七种写法" class="headerlink" title="单例模式的七种写法"></a>单例模式的七种写法</h3><h4 id="1、饿汉式"><a href="#1、饿汉式" class="headerlink" title="1、饿汉式"></a>1、饿汉式</h4><pre><code>// 线程安全
public class Singleton {

    private final static Singleton INSTANCE = new Singleton();

    private Singleton(){}

    public static Singleton getInstance(){
        return INSTANCE;
    }
}
</code></pre><p><strong>优点</strong>：简单，使用时没有延迟；在类装载时就完成实例化，天生的线程安全</p>
<p><strong>缺点</strong>：没有懒加载，启动较慢；如果从始至终都没使用过这个实例，则会造成内存的浪费。</p>
<h4 id="2、饿汉式变种"><a href="#2、饿汉式变种" class="headerlink" title="2、饿汉式变种"></a>2、饿汉式变种</h4><pre><code>// 线程安全
public class Singleton {

    private static Singleton instance;

    static {
        instance = new Singleton();
    }

    private Singleton() {}

    public static Singleton getInstance() {
        return instance;
    }
}
</code></pre><p>将类实例化的过程放在了静态代码块中，在类装载的时执行静态代码块中的代码，初始化类的实例。优缺点同上。</p>
<h4 id="3、懒汉式"><a href="#3、懒汉式" class="headerlink" title="3、懒汉式"></a>3、懒汉式</h4><pre><code>// 线程不安全
public class Singleton {

    private static Singleton singleton;

    private Singleton() {}

    public static Singleton getInstance() {
        if (singleton == null) {
            singleton = new Singleton();
        }
        return singleton;
    }
}
</code></pre><p><strong>优点</strong>：懒加载，启动速度快、如果从始至终都没使用过这个实例，则不会初始化该实力，可节约资源</p>
<p><strong>缺点</strong>：多线程环境下线程不安全。<code>if (singleton == null)</code> 存在竞态条件，可能会有多个线程同时进入 <code>if 语句</code>，导致产生多个实例</p>
<h4 id="4、懒汉式变种"><a href="#4、懒汉式变种" class="headerlink" title="4、懒汉式变种"></a>4、懒汉式变种</h4><pre><code>// 线程安全，效率低
public class Singleton {

    private static Singleton singleton;

    private Singleton() {}

    public static synchronized Singleton getInstance() {
        if (singleton == null) {
            singleton = new Singleton();
        }
        return singleton;
    }
}
</code></pre><p><strong>优点</strong>：解决了上一种实现方式的线程不安全问题</p>
<p><strong>缺点</strong>：synchronized 对整个 <code>getInstance()</code> 方法都进行了同步，每次只有一个线程能够进入该方法，并发性能极差</p>
<h4 id="5、双重检查锁"><a href="#5、双重检查锁" class="headerlink" title="5、双重检查锁"></a>5、双重检查锁</h4><pre><code>// 线程安全
public class Singleton {
    // 注意：这里有 volatile 关键字修饰
    private static volatile Singleton singleton;

    private Singleton() {}

    public static Singleton getInstance() {
        if (singleton == null) {
            synchronized (Singleton.class) {
                if (singleton == null) {
                    singleton = new Singleton();
                }
            }
        }
        return singleton;
    }
}
</code></pre><p><strong>优点</strong>：线程安全；延迟加载；效率较高。</p>
<p>由于 JVM 具有指令重排的特性，在多线程环境下可能出现  singleton 已经赋值但还没初始化的情况，导致一个线程获得还没有初始化的实例。volatile 关键字的作用：</p>
<ul>
<li>保证了不同线程对这个变量进行操作时的可见性</li>
<li>禁止进行指令重排序</li>
</ul>
<h4 id="6、静态内部类"><a href="#6、静态内部类" class="headerlink" title="6、静态内部类"></a>6、静态内部类</h4><pre><code>// 线程安全
public class Singleton {

    private Singleton() {}

    private static class SingletonInstance {
        private static final Singleton INSTANCE = new Singleton();
    }

    public static Singleton getInstance() {
        return SingletonInstance.INSTANCE;
    }
}
</code></pre><p><strong>优点</strong>：避免了线程不安全，延迟加载，效率高。</p>
<p>静态内部类的方式利用了类装载机制来保证线程安全，只有在第一次调用getInstance方法时，才会装载SingletonInstance内部类，完成Singleton的实例化，所以也有懒加载的效果。</p>
<p><strong>加入参数 <code>-verbose:class</code> 可以查看类加载顺序</strong></p>
<pre><code>$ javac Singleton.java
$ java -verbose:class Singleton
</code></pre><h4 id="7、枚举"><a href="#7、枚举" class="headerlink" title="7、枚举"></a>7、枚举</h4><pre><code>// 线程安全
public enum Singleton {
    INSTANCE;
    public void whateverMethod() {
    }
}
</code></pre><p><strong>优点</strong>：通过JDK1.5中添加的枚举来实现单例模式，<strong>写法简单</strong>，且不仅能<strong>避免多线程同步问题</strong>，而且还能<strong>防止反序列化重新创建新的对象</strong>。</p>
<h3 id="单例模式的安全性"><a href="#单例模式的安全性" class="headerlink" title="单例模式的安全性"></a>单例模式的安全性</h3><p>单例模式的目标是，任何时候该类都只有唯一的一个对象。但是上面我们写的大部分单例模式都存在漏洞，被攻击时会产生多个对象，破坏了单例模式。</p>
<h4 id="序列化攻击"><a href="#序列化攻击" class="headerlink" title="序列化攻击"></a>序列化攻击</h4><p>通过Java的序列化机制来攻击单例模式</p>
<pre><code>public class HungrySingleton {
    private static final HungrySingleton instance = new HungrySingleton();
    private HungrySingleton() {
    }
    public static HungrySingleton getInstance() {
        return instance;
    }

    public static void main(String[] args) throws IOException, ClassNotFoundException {
        HungrySingleton singleton = HungrySingleton.getInstance();
        ObjectOutputStream oos = new ObjectOutputStream(new FileOutputStream(&quot;singleton_file&quot;));
        oos.writeObject(singleton); // 序列化

        ObjectInputStream ois = new ObjectInputStream(new FileInputStream(&quot;singleton_file&quot;));
        HungrySingleton newSingleton = (HungrySingleton) ois.readObject(); // 反序列化

        System.out.println(singleton);
        System.out.println(newSingleton);
        System.out.println(singleton == newSingleton);
    }
}
</code></pre><p>结果</p>
<pre><code>com.singleton.HungrySingleton@ed17bee
com.singleton.HungrySingleton@46f5f779
false
</code></pre><p>Java 序列化是如何攻击单例模式的呢？我们需要先复习一下Java的序列化机制</p>
<h5 id="Java-序列化机制"><a href="#Java-序列化机制" class="headerlink" title="Java 序列化机制"></a>Java 序列化机制</h5><p><code>java.io.ObjectOutputStream</code> 是Java实现序列化的关键类，它可以将一个对象转换成二进制流，然后可以通过 <code>ObjectInputStream</code> 将二进制流还原成对象。具体的序列化过程不是本文的重点，在此仅列出几个要点。</p>
<p><strong>Java 序列化机制的要点</strong>：</p>
<ul>
<li>需要序列化的类必须实现<code>java.io.Serializable</code>接口，否则会抛出<code>NotSerializableException</code>异常 </li>
<li>若没有显示地声明一个<code>serialVersionUID</code>变量，Java序列化机制会根据编译时的class自动生成一个<code>serialVersionUID</code>作为序列化版本比较（验证一致性），如果检测到反序列化后的类的<code>serialVersionUID</code>和对象二进制流的<code>serialVersionUID</code>不同，则会抛出异常</li>
<li>Java的序列化会将一个类包含的引用中所有的成员变量保存下来（深度复制），所以里面的引用类型必须也要实现<code>java.io.Serializable</code>接口</li>
<li>当某个字段被声明为<code>transient</code>后，默认序列化机制就会忽略该字段，反序列化后自动获得0或者null值</li>
<li>静态成员不参与序列化</li>
<li>每个类可以实现<code>readObject</code>、<code>writeObject</code>方法实现自己的序列化策略，即使是<code>transient</code>修饰的成员变量也可以手动调用<code>ObjectOutputStream</code>的<code>writeInt</code>等方法将这个成员变量序列化。</li>
<li>任何一个readObject方法，不管是显式的还是默认的，它都会返回一个新建的实例，这个新建的实例不同于该类初始化时创建的实例</li>
<li>每个类可以实现<code>private Object readResolve()</code>方法，在调用<code>readObject</code>方法之后，如果存在<code>readResolve</code>方法则自动调用该方法，<code>readResolve</code>将对<code>readObject</code>的结果进行处理，而最终<code>readResolve</code>的处理结果将作为<code>readObject</code>的结果返回。<code>readResolve</code>的目的是保护性恢复对象，其最重要的应用就是保护性恢复单例、枚举类型的对象</li>
<li><code>Serializable</code>接口是一个标记接口，可自动实现序列化，而<code>Externalizable</code>继承自<code>Serializable</code>，它强制必须手动实现序列化和反序列化算法，相对来说更加高效</li>
</ul>
<h5 id="序列化破坏单例模式的解决方案"><a href="#序列化破坏单例模式的解决方案" class="headerlink" title="序列化破坏单例模式的解决方案"></a>序列化破坏单例模式的解决方案</h5><p>根据上面对Java序列化机制的复习，我们可以自定义一个 <code>readResolve</code>，在其中返回类的单例对象，替换掉 <code>readObject</code> 方法反序列化生成的对象，让我们自己写的单例模式实现保护性恢复对象</p>
<pre><code>public class HungrySingleton implements Serializable {
    private static final HungrySingleton instance = new HungrySingleton();
    private HungrySingleton() {
    }
    public static HungrySingleton getInstance() {
        return instance;
    }

    private Object readResolve() {
        return instance;
    }

    public static void main(String[] args) throws IOException, ClassNotFoundException {
        HungrySingleton singleton = HungrySingleton.getInstance();
        ObjectInputStream ois = new ObjectInputStream(new FileInputStream(&quot;singleton_file&quot;));
        HungrySingleton newSingleton = (HungrySingleton) ois.readObject();

        System.out.println(singleton);
        System.out.println(newSingleton);
        System.out.println(singleton == newSingleton);
    }
}
</code></pre><p>再次运行</p>
<pre><code>com.singleton.HungrySingleton@24273305
com.singleton.HungrySingleton@24273305
true
</code></pre><p>注意：自己实现的单例模式都需要避免被序列化破坏</p>
<h4 id="反射攻击"><a href="#反射攻击" class="headerlink" title="反射攻击"></a>反射攻击</h4><p>在单例模式中，构造器都是私有的，而反射可以通过构造器对象调用 <code>setAccessible(true)</code> 来获得权限，这样就可以创建多个对象，来破坏单例模式了</p>
<pre><code>public class HungrySingleton {
    private static final HungrySingleton instance = new HungrySingleton();

    private HungrySingleton() {
    }

    public static HungrySingleton getInstance() {
        return instance;
    }

    public static void main(String[] args) throws NoSuchMethodException, IllegalAccessException, InvocationTargetException, InstantiationException {
        HungrySingleton instance = HungrySingleton.getInstance();
        Constructor constructor = HungrySingleton.class.getDeclaredConstructor();
        constructor.setAccessible(true);    // 获得权限
        HungrySingleton newInstance = (HungrySingleton) constructor.newInstance();

        System.out.println(instance);
        System.out.println(newInstance);
        System.out.println(instance == newInstance);
    }
}
</code></pre><p>输出结果</p>
<pre><code>com.singleton.HungrySingleton@3b192d32
com.singleton.HungrySingleton@16f65612
false
</code></pre><h5 id="反射攻击解决方案"><a href="#反射攻击解决方案" class="headerlink" title="反射攻击解决方案"></a>反射攻击解决方案</h5><p>反射是通过它的Class对象来调用构造器创建新的对象，我们只需要在构造器中检测并抛出异常就可以达到目的了</p>
<pre><code>private HungrySingleton() {
    // instance 不为空，说明单例对象已经存在
    if (instance != null) {
        throw new RuntimeException(&quot;单例模式禁止反射调用！&quot;);
    }
}
</code></pre><p>运行结果</p>
<pre><code>Exception in thread &quot;main&quot; java.lang.reflect.InvocationTargetException
    at sun.reflect.NativeConstructorAccessorImpl.newInstance0(Native Method)
    at sun.reflect.NativeConstructorAccessorImpl.newInstance(NativeConstructorAccessorImpl.java:62)
    at sun.reflect.DelegatingConstructorAccessorImpl.newInstance(DelegatingConstructorAccessorImpl.java:45)
    at java.lang.reflect.Constructor.newInstance(Constructor.java:423)
    at com.singleton.HungrySingleton.main(HungrySingleton.java:32)
Caused by: java.lang.RuntimeException: 单例模式禁止反射调用！
    at com.singleton.HungrySingleton.&lt;init&gt;(HungrySingleton.java:20)
    ... 5 more
</code></pre><p><strong>注意</strong>，上述方法针对饿汉式单例模式是有效的，但<strong>对懒汉式的单例模式是无效的，懒汉式的单例模式是无法避免反射攻击的！</strong></p>
<p>为什么对饿汉有效，对懒汉无效？因为饿汉的初始化是在类加载的时候，反射一定是在饿汉初始化之后才能使用；而懒汉是在第一次调用 <code>getInstance()</code> 方法的时候才初始化，我们无法控制反射和懒汉初始化的先后顺序，如果反射在前，不管反射创建了多少对象，instance都将一直为null，直到调用 <code>getInstance()</code>。</p>
<p><strong>事实上，实现单例模式的唯一推荐方法，是使用枚举类来实现。</strong></p>
<h4 id="为什么推荐使用枚举单例"><a href="#为什么推荐使用枚举单例" class="headerlink" title="为什么推荐使用枚举单例"></a>为什么推荐使用枚举单例</h4><p>写下我们的枚举单例模式</p>
<pre><code>package com.singleton;

import java.io.*;
import java.lang.reflect.Constructor;
import java.lang.reflect.InvocationTargetException;

public enum SerEnumSingleton implements Serializable {
    INSTANCE;   // 单例对象
    private String content;

    public String getContent() {
        return content;
    }

    public void setContent(String content) {
        this.content = content;
    }

    private SerEnumSingleton() {
    }

    public static void main(String[] args) throws IOException, ClassNotFoundException, NoSuchMethodException, IllegalAccessException, InvocationTargetException, InstantiationException {
        SerEnumSingleton singleton1 = SerEnumSingleton.INSTANCE;
        singleton1.setContent(&quot;枚举单例序列化&quot;);
        System.out.println(&quot;枚举序列化前读取其中的内容：&quot; + singleton1.getContent());
        ObjectOutputStream oos = new ObjectOutputStream(new FileOutputStream(&quot;SerEnumSingleton.obj&quot;));
        oos.writeObject(singleton1);
        oos.flush();
        oos.close();

        FileInputStream fis = new FileInputStream(&quot;SerEnumSingleton.obj&quot;);
        ObjectInputStream ois = new ObjectInputStream(fis);
        SerEnumSingleton singleton2 = (SerEnumSingleton) ois.readObject();
        ois.close();
        System.out.println(singleton1 + &quot;\n&quot; + singleton2);
        System.out.println(&quot;枚举序列化后读取其中的内容：&quot; + singleton2.getContent());
        System.out.println(&quot;枚举序列化前后两个是否同一个：&quot; + (singleton1 == singleton2));

        Constructor&lt;SerEnumSingleton&gt; constructor = SerEnumSingleton.class.getDeclaredConstructor();
        constructor.setAccessible(true);
        SerEnumSingleton singleton3 = constructor.newInstance(); // 通过反射创建对象
        System.out.println(&quot;反射后读取其中的内容：&quot; + singleton3.getContent());
        System.out.println(&quot;反射前后两个是否同一个：&quot; + (singleton1 == singleton3));
    }
}
</code></pre><p>运行结果，序列化前后的对象是同一个对象，而反射的时候抛出了异常</p>
<pre><code>枚举序列化前读取其中的内容：枚举单例序列化
INSTANCE
INSTANCE
枚举序列化后读取其中的内容：枚举单例序列化
枚举序列化前后两个是否同一个：true
Exception in thread &quot;main&quot; java.lang.NoSuchMethodException: com.singleton.SerEnumSingleton.&lt;init&gt;()
    at java.lang.Class.getConstructor0(Class.java:3082)
    at java.lang.Class.getDeclaredConstructor(Class.java:2178)
    at com.singleton.SerEnumSingleton.main(SerEnumSingleton.java:39)
</code></pre><p>编译后，再通过 JAD 进行反编译得到下面的代码</p>
<pre><code>// Decompiled by Jad v1.5.8g. Copyright 2001 Pavel Kouznetsov.
// Jad home page: http://www.kpdus.com/jad.html
// Decompiler options: packimports(3) 
// Source File Name:   SerEnumSingleton.java

package com.singleton;

import java.io.*;
import java.lang.reflect.Constructor;
import java.lang.reflect.InvocationTargetException;

public final class SerEnumSingleton extends Enum
    implements Serializable
{

    public static SerEnumSingleton[] values()
    {
        return (SerEnumSingleton[])$VALUES.clone();
    }

    public static SerEnumSingleton valueOf(String name)
    {
        return (SerEnumSingleton)Enum.valueOf(com/singleton/SerEnumSingleton, name);
    }

    public String getContent()
    {
        return content;
    }

    public void setContent(String content)
    {
        this.content = content;
    }

    private SerEnumSingleton(String s, int i)
    {
        super(s, i);
    }

    public static void main(String args[])
        throws IOException, ClassNotFoundException, NoSuchMethodException, IllegalAccessException, InvocationTargetException, InstantiationException
    {
        SerEnumSingleton singleton1 = INSTANCE;
        singleton1.setContent(&quot;\u679A\u4E3E\u5355\u4F8B\u5E8F\u5217\u5316&quot;);
        System.out.println((new StringBuilder()).append(&quot;\u679A\u4E3E\u5E8F\u5217\u5316\u524D\u8BFB\u53D6\u5176\u4E2D\u7684\u5185\u5BB9\uFF1A&quot;).append(singleton1.getContent()).toString());
        ObjectOutputStream oos = new ObjectOutputStream(new FileOutputStream(&quot;SerEnumSingleton.obj&quot;));
        oos.writeObject(singleton1);
        oos.flush();
        oos.close();
        FileInputStream fis = new FileInputStream(&quot;SerEnumSingleton.obj&quot;);
        ObjectInputStream ois = new ObjectInputStream(fis);
        SerEnumSingleton singleton2 = (SerEnumSingleton)ois.readObject();
        ois.close();
        System.out.println((new StringBuilder()).append(singleton1).append(&quot;\n&quot;).append(singleton2).toString());
        System.out.println((new StringBuilder()).append(&quot;\u679A\u4E3E\u5E8F\u5217\u5316\u540E\u8BFB\u53D6\u5176\u4E2D\u7684\u5185\u5BB9\uFF1A&quot;).append(singleton2.getContent()).toString());
        System.out.println((new StringBuilder()).append(&quot;\u679A\u4E3E\u5E8F\u5217\u5316\u524D\u540E\u4E24\u4E2A\u662F\u5426\u540C\u4E00\u4E2A\uFF1A&quot;).append(singleton1 == singleton2).toString());
        Constructor constructor = com/singleton/SerEnumSingleton.getDeclaredConstructor(new Class[0]);
        constructor.setAccessible(true);
        SerEnumSingleton singleton3 = (SerEnumSingleton)constructor.newInstance(new Object[0]);
        System.out.println((new StringBuilder()).append(&quot;\u53CD\u5C04\u540E\u8BFB\u53D6\u5176\u4E2D\u7684\u5185\u5BB9\uFF1A&quot;).append(singleton3.getContent()).toString());
        System.out.println((new StringBuilder()).append(&quot;\u53CD\u5C04\u524D\u540E\u4E24\u4E2A\u662F\u5426\u540C\u4E00\u4E2A\uFF1A&quot;).append(singleton1 == singleton3).toString());
    }

    public static final SerEnumSingleton INSTANCE;
    private String content;
    private static final SerEnumSingleton $VALUES[];

    static 
    {
        INSTANCE = new SerEnumSingleton(&quot;INSTANCE&quot;, 0);
        $VALUES = (new SerEnumSingleton[] {
            INSTANCE
        });
    }
}
</code></pre><p>通过反编译后代码我们可以看到，<code>ublic final class T extends Enum</code>，说明，当我们使用enmu来定义一个枚举类型的时候，编译器会自动帮我们创建一个final类型的类继承Enum类，所以枚举类型不能被继承。</p>
<h5 id="那么，为什么推荐使用枚举单例呢？"><a href="#那么，为什么推荐使用枚举单例呢？" class="headerlink" title="那么，为什么推荐使用枚举单例呢？"></a>那么，为什么推荐使用枚举单例呢？</h5><p><strong>1. 枚举单例写法简单</strong></p>
<p><strong>2. 线程安全&amp;懒加载</strong></p>
<p>代码中 INSTANCE 变量被 <code>public static final</code> 修饰，因为static类型的属性是在类加载之后初始化的，JVM可以保证线程安全；且Java类是在引用到的时候才进行类加载，所以枚举单例也有懒加载的效果。</p>
<p><strong>3. 枚举自己能避免序列化攻击</strong></p>
<p>为了保证枚举类型像Java规范中所说的那样，每一个枚举类型极其定义的枚举变量在JVM中都是唯一的，在枚举类型的序列化和反序列化上，Java做了特殊的规定。</p>
<p>在序列化的时候Java<strong>仅仅是将枚举对象的name属性输出到结果中</strong>，反序列化的时候则是通过java.lang.Enum的valueOf方法来<strong>根据名字查找枚举对象</strong>。同时，<strong>编译器是不允许任何对这种序列化机制的定制</strong>，因此禁用了writeObject、readObject、readObjectNoData、writeReplace和readResolve等方法。 我们看一下Enum类的valueOf方法：</p>
<pre><code>    public static &lt;T extends Enum&lt;T&gt;&gt; T valueOf(Class&lt;T&gt; enumType, String name) {
        T result = enumType.enumConstantDirectory().get(name);
        if (result != null)
            return result;
        if (name == null)
            throw new NullPointerException(&quot;Name is null&quot;);
        throw new IllegalArgumentException(
            &quot;No enum constant &quot; + enumType.getCanonicalName() + &quot;.&quot; + name);
    }
</code></pre><p>从代码中可以看到，代码会尝试从调用enumType这个Class对象的<code>enumConstantDirectory()</code>方法返回的map中获取名字为name的枚举对象，如果不存在就会抛出异常。再进一步跟到<code>enumConstantDirectory()</code>方法，就会发现到最后会以反射的方式调用enumType这个类型的values()静态方法，也就是上面我们看到的编译器为我们创建的那个方法，然后用返回结果填充enumType这个Class对象中的<code>enumConstantDirectory</code>属性。所以，JVM对序列化有保证。</p>
<p><strong>4. 枚举能够避免反射攻击，因为反射不支持创建枚举对象</strong></p>
<p><code>Constructor</code>类的 <code>newInstance</code>方法中会判断是否为 enum，若是会抛出异常</p>
<pre><code>    @CallerSensitive
    public T newInstance(Object ... initargs) throws InstantiationException, IllegalAccessException, IllegalArgumentException, InvocationTargetException {
        if (!override) {
            if (!Reflection.quickCheckMemberAccess(clazz, modifiers)) {
                Class&lt;?&gt; caller = Reflection.getCallerClass();
                checkAccess(caller, clazz, null, modifiers);
            }
        }
        // 不能为 ENUM，否则抛出异常：不能通过反射创建 enum 对象
        if ((clazz.getModifiers() &amp; Modifier.ENUM) != 0)
            throw new IllegalArgumentException(&quot;Cannot reflectively create enum objects&quot;);
        ConstructorAccessor ca = constructorAccessor;   // read volatile
        if (ca == null) {
            ca = acquireConstructorAccessor();
        }
        @SuppressWarnings(&quot;unchecked&quot;)
        T inst = (T) ca.newInstance(initargs);
        return inst;
    }
</code></pre><h3 id="单例模式总结"><a href="#单例模式总结" class="headerlink" title="单例模式总结"></a>单例模式总结</h3><p>单例模式作为一种目标明确、结构简单、理解容易的设计模式，在软件开发中使用频率相当高，在很多应用软件和框架中都得以广泛应用。</p>
<h4 id="单例模式的主要优点"><a href="#单例模式的主要优点" class="headerlink" title="单例模式的主要优点"></a>单例模式的主要优点</h4><ul>
<li>单例模式提供了对唯一实例的受控访问。</li>
<li>由于在系统内存中只存在一个对象，因此可以节约系统资源，对于一些需要频繁创建和销毁的对象，单例模式可以提高系统的性能。</li>
<li>允许可变数目的实例。基于单例模式我们可以进行扩展，使用与单例控制相似的方法来获得指定个数的对象实例，既节省系统资源，又解决了单例单例对象共享过多有损性能的问题。</li>
</ul>
<h4 id="单例模式的主要缺点"><a href="#单例模式的主要缺点" class="headerlink" title="单例模式的主要缺点"></a>单例模式的主要缺点</h4><ul>
<li>由于单例模式中没有抽象层，因此单例类的扩展有很大的困难。</li>
<li>单例类的职责过重，在一定程度上违背了 “单一职责原则”。</li>
<li>如果实例化的共享对象长时间不被利用，系统可能会认为它是垃圾，会自动销毁并回收资源，下次利用时又将重新实例化，这将导致共享的单例对象状态的丢失。</li>
</ul>
<h4 id="适用场景"><a href="#适用场景" class="headerlink" title="适用场景"></a>适用场景</h4><ul>
<li>系统只需要一个实例对象，如系统要求提供一个唯一的序列号生成器或资源管理器，或者需要考虑资源消耗太大而只允许创建一个对象。</li>
<li>客户调用类的单个实例只允许使用一个公共访问点，除了该公共访问点，不能通过其他途径访问该实例。</li>
</ul>
<h3 id="单例模式的典型应用"><a href="#单例模式的典型应用" class="headerlink" title="单例模式的典型应用"></a>单例模式的典型应用</h3><h4 id="JDK-Runtime-饿汉单例"><a href="#JDK-Runtime-饿汉单例" class="headerlink" title="JDK Runtime 饿汉单例"></a>JDK Runtime 饿汉单例</h4><p>JDK Runtime类代表着Java程序的运行时环境，每个Java程序都有一个Runtime实例，该类会被自动创建，我们可以通过 Runtime.getRuntime() 方法来获取当前程序的Runtime实例。一旦得到了一个当前的Runtime对象的引用，就可以调用Runtime对象的方法去控制Java虚拟机的状态和行为。</p>
<p>Runtime 应用了饿汉式单例模式</p>
<pre><code>public class Runtime {
    private static Runtime currentRuntime = new Runtime();

    public static Runtime getRuntime() {
        return currentRuntime;
    }

    private Runtime() {
    }
    //....
}
</code></pre><p>API 介绍</p>
<pre><code>addShutdownHook(Thread hook) 注册新的虚拟机来关闭挂钩。 
availableProcessors() 向 Java 虚拟机返回可用处理器的数目。 
exec(String command) 在单独的进程中执行指定的字符串命令。 
exec(String[] cmdarray) 在单独的进程中执行指定命令和变量。 
exec(String[] cmdarray, String[] envp) 在指定环境的独立进程中执行指定命令和变量。 
exec(String[] cmdarray, String[] envp, File dir) 在指定环境和工作目录的独立进程中执行指定的命令和变量。 
exec(String command, String[] envp) 在指定环境的单独进程中执行指定的字符串命令。 
exec(String command, String[] envp, File dir) 在有指定环境和工作目录的独立进程中执行指定的字符串命令。 
exit(int status) 通过启动虚拟机的关闭序列，终止当前正在运行的 Java 虚拟机。 
freeMemory() 返回 Java 虚拟机中的空闲内存量。 
gc() 运行垃圾回收器。  
getRuntime() 返回与当前 Java 应用程序相关的运行时对象。 
halt(int status) 强行终止目前正在运行的 Java 虚拟机。 
load(String filename) 加载作为动态库的指定文件名。 
loadLibrary(String libname) 加载具有指定库名的动态库。 
maxMemory() 返回 Java 虚拟机试图使用的最大内存量。 
removeShutdownHook(Thread hook) 取消注册某个先前已注册的虚拟机关闭挂钩。 
runFinalization() 运行挂起 finalization 的所有对象的终止方法。 
totalMemory() 返回 Java 虚拟机中的内存总量。 
traceInstructions(on) 启用／禁用指令跟踪。 
traceMethodCalls(on) 启用／禁用方法调用跟踪。
</code></pre><h4 id="AWT-Desktop-容器单例"><a href="#AWT-Desktop-容器单例" class="headerlink" title="AWT Desktop 容器单例"></a>AWT Desktop 容器单例</h4><p>Desktop 类允许 Java 应用程序启动已在本机桌面上注册的关联应用程序，以处理 URI 或文件。支持的操作包括:</p>
<ul>
<li>打开浏览器: 启动用户默认浏览器来显示指定的 URI；</li>
<li>打开邮件客户端: 启动带有可选 mailto URI 的用户默认邮件客户端；</li>
<li>打开文件/文件夹: 启动已注册的应用程序，以打开、编辑 或 打印 指定的文件。</li>
</ul>
<p>Desktop 通过一个容器来管理单例对象</p>
<pre><code>public class Desktop {
    // synchronized 同步方法
    public static synchronized Desktop getDesktop(){
        if (GraphicsEnvironment.isHeadless()) throw new HeadlessException();
        if (!Desktop.isDesktopSupported()) {
            throw new UnsupportedOperationException(&quot;Desktop API is not &quot; + &quot;supported on the current platform&quot;);
        }
        sun.awt.AppContext context = sun.awt.AppContext.getAppContext();
        Desktop desktop = (Desktop)context.get(Desktop.class); // 获取单例对象
        // 存在则返回，不存在则创建，创建后put进容器
        if (desktop == null) {
            desktop = new Desktop(); 
            context.put(Desktop.class, desktop);
        }
        return desktop;
    }
</code></pre><p>AppContext 中有一个 HashMap 对象table，是实际的容器对象</p>
<pre><code>private final Map&lt;Object, Object&gt; table = new HashMap();
</code></pre><h4 id="spring-AbstractFactoryBean"><a href="#spring-AbstractFactoryBean" class="headerlink" title="spring AbstractFactoryBean"></a>spring AbstractFactoryBean</h4><p>AbstractFactoryBean 类</p>
<pre><code>public final T getObject() throws Exception {
    if (this.isSingleton()) {
        return this.initialized ? this.singletonInstance : this.getEarlySingletonInstance();
    } else {
        return this.createInstance();
    }
}

private T getEarlySingletonInstance() throws Exception {
    Class&lt;?&gt;[] ifcs = this.getEarlySingletonInterfaces();
    if (ifcs == null) {
        throw new FactoryBeanNotInitializedException(this.getClass().getName() + &quot; does not support circular references&quot;);
    } else {
        if (this.earlySingletonInstance == null) {
            // 通过代理创建对象
            this.earlySingletonInstance = Proxy.newProxyInstance(this.beanClassLoader, ifcs, new AbstractFactoryBean.EarlySingletonInvocationHandler());
        }
        return this.earlySingletonInstance;
    }
}
</code></pre><h4 id="Mybatis-ErrorContext-ThreadLocal"><a href="#Mybatis-ErrorContext-ThreadLocal" class="headerlink" title="Mybatis ErrorContext ThreadLocal"></a>Mybatis ErrorContext ThreadLocal</h4><p>ErrorContext 类，通过 ThreadLocal 管理单例对象，一个线程一个ErrorContext对象，ThreadLocal可以保证线程安全</p>
<pre><code>public class ErrorContext {
    private static final ThreadLocal&lt;ErrorContext&gt; LOCAL = new ThreadLocal&lt;ErrorContext&gt;();
    private ErrorContext() {
    }

    public static ErrorContext instance() {
        ErrorContext context = LOCAL.get();
        if (context == null) {
          context = new ErrorContext();
          LOCAL.set(context);
        }
        return context;
    }
    //...
}
</code></pre><blockquote>
<p>参考：<br><a href="http://www.hollischuang.com/archives/197" target="_blank" rel="noopener">http://www.hollischuang.com/archives/197</a><br><a href="https://www.cnblogs.com/chiclee/p/9097772.html" target="_blank" rel="noopener">https://www.cnblogs.com/chiclee/p/9097772.html</a><br><a href="https://blog.csdn.net/abc123lzf/article/details/82318148" target="_blank" rel="noopener">https://blog.csdn.net/abc123lzf/article/details/82318148</a></p>
</blockquote>
<h3 id="后记"><a href="#后记" class="headerlink" title="后记"></a>后记</h3><p>欢迎评论、转发、分享，您的支持是我最大的动力</p>
<p>更多内容可访问我的个人博客：<a href="http://laijianfeng.org">http://laijianfeng.org</a></p>
<p>关注【小旋锋】微信公众号，及时接收博文推送</p>
<p><img src="http://image.laijianfeng.org/20180913_001328.png" alt="关注_小旋锋_微信公众号"></p>

      
       <hr><span style="font-style: italic;color: gray;"> 转载请注明来源，欢迎对文章中的引用来源进行考证，欢迎指出任何有错误或不够清晰的表达。可以在下面评论区评论，也可以邮件至 whirlys@163.com </span>
    </div>
</article>


<p>
    <a href="javascript:void(0)" class="dashang" onclick="dashangToggle()">赏</a>
</p>


<div class="article_copyright">
    <p><span>文章标题:</span>设计模式 | 单例模式及典型应用</p>
    <p><span>文章字数:</span><span class="post-count">5,251</span></p>
    <p><span>本文作者:</span><a href="javascript:void(0)" title="小旋锋">小旋锋</a></p>
    <p><span>发布时间:</span>2019-01-07, 01:35:54</p>
    <p><span>最后更新:</span>2019-01-07, 01:37:03</p>
    <span>原始链接:</span><a class="post-url" href="/2019/01/设计模式-单例模式及典型应用/" title="设计模式 | 单例模式及典型应用">http://laijianfeng.org/2019/01/设计模式-单例模式及典型应用/</a>
    <p>
        <span>版权声明:</span><i class="fa fa-creative-commons"></i> <a rel="license" href="http://creativecommons.org/licenses/by-nc-sa/4.0/" title="CC BY-NC-SA 4.0 International" target = "_blank">"署名-非商用-相同方式共享 4.0"</a> 转载请保留原文链接及作者。
    </p>
</div>


    <div id="comments"></div>
<link rel="stylesheet" href="https://imsun.github.io/gitment/style/default.css">
<script src="https://imsun.github.io/gitment/dist/gitment.browser.js"></script>
<script>
    var gitment = new Gitment({
        id: '设计模式 | 单例模式及典型应用', // 可选。默认为 location.href
        owner: 'whirlys',
        repo: 'whirlys.github.io',
        oauth: {
            client_id: 'f1bd5294d498cdda9693',
            client_secret: '959bbaf23dae12023b1b9ee3e63e882a099ca65a',
        },
        perPage : 3
    })
    gitment.render('comments')
</script>



    </div>
    <div class="copyright">
        <p class="footer-entry">© 2018-2019, 小旋锋. All rights reserved.</p>
<p class="footer-entry">Built with <a href="https://hexo.io/" target="_blank">Hexo</a> and <a href="https://github.com/yelog/hexo-theme-3-hexo" target="_blank">3-hexo</a> theme</p>

    </div>
    <div class="full-toc">
        <button class="full"><span class="min "></span></button>
<button class="post-toc-menu"><span class="post-toc-menu-icons"></span></button>
<div class="post-toc"><span class="post-toc-title">目录</span>
    <div class="post-toc-content">

    </div>
</div>
<a class="" id="rocket" href="javascript:void(0)"></a>
    </div>
</div>
<div class="acParent"></div>

<div class="hide_box" onclick="dashangToggle()"></div>
<div class="shang_box">
    <a class="shang_close" href="javascript:void(0)" onclick="dashangToggle()">×</a>
    <div class="shang_tit">
        <p>喜欢就点赞,疼爱就打赏</p>
    </div>
    <div class="shang_payimg">
        <div class="pay_img">
            <img src="/img/alipay.png" class="alipay" title="扫码支持">
            <img src="/img/weixin.png" class="weixin" title="扫码支持">
        </div>
    </div>
    <div class="shang_payselect">
        <span><label><input type="radio" name="pay" checked value="alipay">支付宝</label></span><span><label><input type="radio" name="pay" value="weixin">微信</label></span>
    </div>
</div>

</body>
<script src="//cdn.bootcss.com/jquery.pjax/2.0.1/jquery.pjax.min.js"></script>

<script src="//cdn.bootcss.com/photoswipe/4.1.2/photoswipe.min.js"></script>
<script src="//cdn.bootcss.com/photoswipe/4.1.2/photoswipe-ui-default.min.js"></script>

<script src="/js/script.js"></script>
<script>
    var img_resize = 'photoSwipe';
    /*作者、标签的自动补全*/
    $(function () {
        $('.search').AutoComplete({
            'data': ['#Java编程','#elasticsearch','#java','#lucene','#spark','#博客','#设计模式',],
            'itemHeight': 20,
            'width': 418
        }).AutoComplete('show');
    })
    function initArticle() {
        /*渲染对应的表格样式*/
        

        /*渲染打赏样式*/
        
        $("input[name=pay]").on("click", function () {
            if($("input[name=pay]:checked").val()=="weixin"){
                $(".shang_box .shang_payimg .pay_img").addClass("weixin_img");
            } else {
                $(".shang_box .shang_payimg .pay_img").removeClass("weixin_img");
            }
        })
        

        /*高亮代码块行号*/
        

        /*访问数量*/
        
        $.getScript("//busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js");
        

        /*代码高亮，行号对齐*/
        $('.pre-numbering').css('line-height',$('.has-numbering').css('line-height'));

        

        // PhotoSwipe
        $('article').each(function(i){
            $(this).find('img').each(function(){
                if ($(this).closest('figure').hasClass('article-gallery-img')) {
                    return;
                }
                var alt = this.alt;
                $(this)
                    .wrap('<figure class="article-gallery-img" itemprop="associatedMedia" itemscope itemtype="http://schema.org/ImageObject"></figure>')
                    .wrap('<a href="' + this.src + '" title="' + alt + '"></a>');
                $(this).after('<div class="img_alt"><span>' + (alt || '') + '</span></div>');
            });
        });

        var pswpElement = document.querySelectorAll('.pswp')[0];
        if (pswpElement) {
            var gallerySelector = '.article-gallery, article';

            var initPhotoSwipeFromDOM = function(gallerySelector) {

                // parse slide data (url, title, size ...) from DOM elements
                // (children of gallerySelector)
                var parseThumbnailElements = function(el) {
                    var thumbElements = $(el).find('figure.article-gallery-img').toArray(),
                        numNodes = thumbElements.length,
                        items = [],
                        figureEl,
                        linkEl,
                        size,
                        imgEl,
                        item;

                    for (var i = 0; i < numNodes; i++) {

                        figureEl = thumbElements[i]; // <figure> element

                        // include only element nodes
                        if (figureEl.nodeType !== 1) {
                            continue;
                        }

                        linkEl = figureEl.children[0]; // <a> element
                        imgEl = linkEl.children[0]; // <img>

                        size = linkEl.getAttribute('data-size');
                        size = size && size.split('x');

                        // create slide object
                        item = {
                            src: linkEl.getAttribute('href'),
                            w: size && parseInt(size[0], 10) || imgEl.width,
                            h: size && parseInt(size[1], 10) || imgEl.height
                        };

                        if (figureEl.children.length > 1) {
                            // <figcaption> content
                            item.title = figureEl.children[1].innerHTML;
                        }

                        if (linkEl.children.length > 0) {
                            // <img> thumbnail element, retrieving thumbnail url
                            item.msrc = linkEl.children[0].getAttribute('src');
                        }

                        item.el = figureEl; // save link to element for getThumbBoundsFn
                        items.push(item);
                    }

                    return items;
                };

                // find nearest parent element
                var closest = function closest(el, fn) {
                    return el && (fn(el) ? el : closest(el.parentNode, fn));
                };

                // triggers when user clicks on thumbnail
                var onThumbnailsClick = function(e) {
                    e = e || window.event;

                    var eTarget = e.target || e.srcElement;

                    // find root element of slide
                    var clickedListItem = closest(eTarget, function(el) {
                        return (el.tagName && el.tagName.toUpperCase() === 'FIGURE');
                    });

                    if (!clickedListItem) {
                        return;
                    }

                    if (e.preventDefault) {
                        e.preventDefault();
                    } else {
                        e.returnValue = false;
                    }

                    // find index of clicked item by looping through all child nodes
                    // alternatively, you may define index via data- attribute
                    var clickedGallery = $(clickedListItem).closest(gallerySelector)[0],
                        childNodes = $(clickedGallery).find('figure.article-gallery-img').toArray(),
                        numChildNodes = childNodes.length,
                        nodeIndex = 0,
                        index;

                    for (var i = 0; i < numChildNodes; i++) {
                        if (childNodes[i].nodeType !== 1) {
                            continue;
                        }

                        if (childNodes[i] === clickedListItem) {
                            index = nodeIndex;
                            break;
                        }
                        nodeIndex++;
                    }



                    if (index >= 0) {
                        // open PhotoSwipe if valid index found
                        openPhotoSwipe(index, clickedGallery);
                    }
                    return false;
                };

                // parse picture index and gallery index from URL (#&pid=1&gid=2)
                var photoswipeParseHash = function() {
                    var hash = window.location.hash.substring(1),
                        params = {};

                    if (hash.length < 5) {
                        return params;
                    }

                    var vars = hash.split('&');
                    for (var i = 0; i < vars.length; i++) {
                        if (!vars[i]) {
                            continue;
                        }
                        var pair = vars[i].split('=');
                        if (pair.length < 2) {
                            continue;
                        }
                        params[pair[0]] = pair[1];
                    }

                    if (params.gid) {
                        params.gid = parseInt(params.gid, 10);
                    }

                    return params;
                };

                var openPhotoSwipe = function(index, galleryElement, disableAnimation, fromURL) {
                    var pswpElement = document.querySelectorAll('.pswp')[0],
                        gallery,
                        options,
                        items;

                    items = parseThumbnailElements(galleryElement);

                    // define options (if needed)
                    options = {

                        // define gallery index (for URL)
                        galleryUID: galleryElement.getAttribute('data-pswp-uid'),

                        getThumbBoundsFn: function(index) {
                            // See Options -> getThumbBoundsFn section of documentation for more info
                            var thumbnail = items[index].el.getElementsByTagName('img')[0], // find thumbnail
                                pageYScroll = window.pageYOffset || document.documentElement.scrollTop,
                                rect = thumbnail.getBoundingClientRect();

                            return {
                                x: rect.left,
                                y: rect.top + pageYScroll,
                                w: rect.width
                            };
                        }
                    };

                    // PhotoSwipe opened from URL
                    if (fromURL) {
                        if (options.galleryPIDs) {
                            // parse real index when custom PIDs are used
                            // http://photoswipe.com/documentation/faq.html#custom-pid-in-url
                            for (var j = 0; j < items.length; j++) {
                                if (items[j].pid == index) {
                                    options.index = j;
                                    break;
                                }
                            }
                        } else {
                            // in URL indexes start from 1
                            options.index = parseInt(index, 10) - 1;
                        }
                    } else {
                        options.index = parseInt(index, 10);
                    }

                    // exit if index not found
                    if (isNaN(options.index)) {
                        return;
                    }

                    if (disableAnimation) {
                        options.showAnimationDuration = 0;
                    }

                    // Pass data to PhotoSwipe and initialize it
                    gallery = new PhotoSwipe(pswpElement, PhotoSwipeUI_Default, items, options);

                    gallery.listen('imageLoadComplete', function(index, item) {
                        var linkEl = item.el.children[0];
                        var img = item.container.children[0];
                        if (!linkEl.getAttribute('data-size')) {
                            linkEl.setAttribute('data-size', img.naturalWidth + 'x' + img.naturalHeight);
                            item.w = img.naturalWidth;
                            item.h = img.naturalHeight;
                            gallery.invalidateCurrItems();
                            gallery.updateSize(true);
                        }
                    });

                    gallery.init();
                };

                // loop through all gallery elements and bind events
                var galleryElements = document.querySelectorAll(gallerySelector);

                for (var i = 0, l = galleryElements.length; i < l; i++) {
                    galleryElements[i].setAttribute('data-pswp-uid', i + 1);
                    galleryElements[i].onclick = onThumbnailsClick;
                }

                // Parse URL and open gallery if it contains #&pid=3&gid=1
                var hashData = photoswipeParseHash();
                if (hashData.pid && hashData.gid) {
                    openPhotoSwipe(hashData.pid, galleryElements[hashData.gid - 1], true, true);
                }
            };

            // execute above function
            initPhotoSwipeFromDOM(gallerySelector);
        }
        
    }

    /*打赏页面隐藏与展示*/
    
    function dashangToggle() {
        $(".shang_box").fadeToggle();
        $(".hide_box").fadeToggle();
    }
    

</script>

<!--加入行号的高亮代码块样式-->

<!--自定义样式设置-->
<style>
    
    .nav-right nav a.hover, #local-search-result a.hover{
        background-color: #e2e0e0;
    }
    
    

    /*列表样式*/
    

    /*引用块样式*/
    
    .post .pjax article blockquote {
        padding: 10px 20px;
        background-color: white;
        border: none;
        border-left: 4px solid #42b983;
        border-right: 4px solid #42b983;
        border-radius: 10px;
    }
    

    /*文章列表背景图*/
    
    .nav-right:before {
        content: ' ';
        display: block;
        position: absolute;
        left: 0;
        top: 0;
        width: 100%;
        height: 100%;
        opacity: 0.1;
        background: url("http://image.laijianfeng.org/v2-cdcf5d00f2e9106f1fd0a70a18cbdf15_r1.jpg");
        background-repeat: no-repeat;
        background-position: 50% 0;
        -ms-background-size: cover;
        -o-background-size: cover;
        -moz-background-size: cover;
        -webkit-background-size: cover;
        background-size: cover;
    }
    
</style>


<!-- Root element of PhotoSwipe. Must have class pswp. -->
<div class="pswp" tabindex="-1" role="dialog" aria-hidden="true">

    <!-- Background of PhotoSwipe.
         It's a separate element, as animating opacity is faster than rgba(). -->
    <div class="pswp__bg"></div>

    <!-- Slides wrapper with overflow:hidden. -->
    <div class="pswp__scroll-wrap">

        <!-- Container that holds slides. PhotoSwipe keeps only 3 slides in DOM to save memory. -->
        <!-- don't modify these 3 pswp__item elements, data is added later on. -->
        <div class="pswp__container">
            <div class="pswp__item"></div>
            <div class="pswp__item"></div>
            <div class="pswp__item"></div>
        </div>

        <!-- Default (PhotoSwipeUI_Default) interface on top of sliding area. Can be changed. -->
        <div class="pswp__ui pswp__ui--hidden">

            <div class="pswp__top-bar">

                <!--  Controls are self-explanatory. Order can be changed. -->

                <div class="pswp__counter"></div>

                <button class="pswp__button pswp__button--close" title="Close (Esc)"></button>

                <button class="pswp__button pswp__button--fs" title="Toggle fullscreen"></button>

                <!-- Preloader demo https://codepen.io/dimsemenov/pen/yyBWoR -->
                <!-- element will get class pswp__preloader--active when preloader is running -->
                <div class="pswp__preloader">
                    <div class="pswp__preloader__icn">
                        <div class="pswp__preloader__cut">
                            <div class="pswp__preloader__donut"></div>
                        </div>
                    </div>
                </div>
            </div>

            <div class="pswp__share-modal pswp__share-modal--hidden pswp__single-tap">
                <div class="pswp__share-tooltip"></div>
            </div>

            <button class="pswp__button pswp__button--arrow--left" title="Previous (arrow left)">
            </button>

            <button class="pswp__button pswp__button--arrow--right" title="Next (arrow right)">
            </button>

            <div class="pswp__caption">
                <div class="pswp__caption__center"></div>
            </div>

        </div>

    </div>

</div>





</html>
