<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>小旋锋</title>
  
  <subtitle>更努力，只为了我们想要的明天</subtitle>
  <link href="/atom.xml" rel="self"/>
  
  <link href="http://laijianfeng.org/"/>
  <updated>2019-01-28T03:06:30.067Z</updated>
  <id>http://laijianfeng.org/</id>
  
  <author>
    <name>小旋锋</name>
    
  </author>
  
  <generator uri="http://hexo.io/">Hexo</generator>
  
  <entry>
    <title>利用Zookeeper实现 - 分布式锁</title>
    <link href="http://laijianfeng.org/2019/01/%E5%88%A9%E7%94%A8Zookeeper%E5%AE%9E%E7%8E%B0-%E5%88%86%E5%B8%83%E5%BC%8F%E9%94%81/"/>
    <id>http://laijianfeng.org/2019/01/利用Zookeeper实现-分布式锁/</id>
    <published>2019-01-28T03:03:44.000Z</published>
    <updated>2019-01-28T03:06:30.067Z</updated>
    
    <content type="html"><![CDATA[<p>在许多场景中，<strong>数据一致性</strong>是一个比较重要的话题，在单机环境中，我们可以通过Java提供的<strong>并发API</strong>来解决；而在分布式环境(会遇到网络故障、消息重复、消息丢失等各种问题)下要复杂得多，常见的解决方案是<strong>分布式事务</strong>、<strong>分布式锁</strong>等。</p><p>本文主要探讨如何利用Zookeeper来实现分布式锁。</p><h3 id="关于分布式锁"><a href="#关于分布式锁" class="headerlink" title="关于分布式锁"></a>关于分布式锁</h3><p>分布式锁是控制分布式系统之间<strong>同步访问共享资源</strong>的一种方式。</p><p>在<strong>实现</strong>分布式锁的过程中需要注意的：</p><ul><li>锁的可重入性(递归调用不应该被阻塞、避免死锁)</li><li>锁的超时(避免死锁、死循环等意外情况)</li><li>锁的阻塞(保证原子性等)</li><li>锁的特性支持(阻塞锁、可重入锁、公平锁、联锁、信号量、读写锁)</li></ul><p>在<strong>使用</strong>分布式锁时需要注意：</p><ul><li>分布式锁的开销(分布式锁一般能不用就不用，有些场景可以用乐观锁代替)</li><li>加锁的粒度(控制加锁的粒度，可以优化系统的性能)</li><li>加锁的方式</li></ul><p>以下是几种常见的实现分布式锁的方案及其优缺点。</p><h4 id="基于数据库"><a href="#基于数据库" class="headerlink" title="基于数据库"></a>基于数据库</h4><p><strong>1. 基于数据库表</strong></p><p>最简单的方式可能就是直接创建一张锁表，当我们要锁住某个方法或资源时，我们就在该表中增加一条记录，想要释放锁的时候就删除这条记录。给某字段添加唯一性约束，如果有多个请求同时提交到数据库的话，<strong>数据库会保证只有一个操作可以成功</strong>，那么我们就可以认为操作成功的那个线程获得了该方法的锁，可以执行方法体内容。</p><p>会引入数据库单点、无失效时间、不阻塞、不可重入等问题。</p><p><strong>2. 基于数据库排他锁</strong></p><p>如果使用的是MySql的InnoDB引擎，在查询语句后面增加<code>for update</code>，数据库会在查询过程中(须通过唯一索引查询)给数据库表增加排他锁，我们可以认为获得排它锁的线程即可获得分布式锁，通过 connection.commit() 操作来释放锁。</p><p>会引入数据库单点、不可重入、无法保证一定使用行锁(部分情况下MySQL自动使用表锁而不是行锁)、排他锁长时间不提交导致占用数据库连接等问题。</p><p><strong>3. 数据库实现分布式锁总结</strong></p><p>优点：</p><ul><li>直接借助数据库，容易理解。</li></ul><p>缺点：</p><ul><li>会引入更多的问题，使整个方案变得越来越复杂</li><li>操作数据库需要一定的开销，有一定的性能问题</li><li>使用数据库的行级锁并不一定靠谱，尤其是当我们的锁表并不大的时候</li></ul><h4 id="基于缓存"><a href="#基于缓存" class="headerlink" title="基于缓存"></a>基于缓存</h4><p>相比较于基于数据库实现分布式锁的方案来说，基于缓存来实现在性能方面会表现的更好一点。目前有很多成熟的缓存产品，包括Redis、memcached、tair等。</p><p>这里以Redis为例举出几种实现方法：</p><p><strong>1. 基于 redis 的 setnx()、expire() 方法做分布式锁</strong></p><p>setnx 的含义就是 <code>SET if Not Exists</code>，其主要有两个参数 <code>setnx(key, value)</code>。该方法是原子的，如果 key 不存在，则设置当前 key 成功，返回 1；如果当前 key 已经存在，则设置当前 key 失败，返回 0。</p><p>expire 设置过期时间，要注意的是 setnx 命令不能设置 key 的超时时间，只能通过 expire() 来对 key 设置。</p><p><strong>2. 基于 redis 的 setnx()、get()、getset()方法做分布式锁</strong></p><p>getset 这个命令主要有两个参数 <code>getset(key，newValue)</code>，该方法是原子的，对 key 设置 newValue 这个值，并且返回 key 原来的旧值。</p><p><strong>3. 基于 Redlock 做分布式锁</strong></p><p>Redlock 是 Redis 的作者 antirez 给出的集群模式的 Redis 分布式锁，它基于 N 个完全独立的 Redis 节点（通常情况下 N 可以设置成 5）</p><p><strong>4. 基于 redisson 做分布式锁</strong></p><p>redisson 是 redis 官方的分布式锁组件，GitHub 地址：<a href="https://github.com/redisson/redisson" target="_blank" rel="noopener">https://github.com/redisson/redisson</a></p><p><strong>基于缓存实现分布式锁总结</strong></p><p>优点：</p><ul><li>性能好</li></ul><p>缺点：</p><ul><li>实现中需要考虑的因素太多</li><li>通过超时时间来控制锁的失效时间并不是十分的靠谱</li></ul><h4 id="基于Zookeeper"><a href="#基于Zookeeper" class="headerlink" title="基于Zookeeper"></a>基于Zookeeper</h4><p><strong>大致思想</strong>为：每个客户端对某个方法加锁时，在 Zookeeper 上与该方法对应的指定节点的目录下，<strong>生成一个唯一的临时有序节点</strong>。 判断是否获取锁的方式很简单，只需要判断有序节点中<strong>序号最小的一个</strong>。 当释放锁的时候，只需将这个临时节点删除即可。同时，其可以避免服务宕机导致的锁无法释放，而产生的死锁问题</p><p><strong>Zookeeper实现分布式锁总结</strong></p><p>优点：</p><ul><li>有效的解决单点问题，不可重入问题，非阻塞问题以及锁无法释放的问题</li><li>实现较为简单</li></ul><p>缺点：</p><ul><li>性能上不如使用缓存实现的分布式锁，因为每次在创建锁和释放锁的过程中，都要动态创建、销毁临时节点来实现锁功能</li><li>需要对Zookeeper的原理有所了解</li></ul><h3 id="Zookeeper-如何实现分布式锁？"><a href="#Zookeeper-如何实现分布式锁？" class="headerlink" title="Zookeeper 如何实现分布式锁？"></a>Zookeeper 如何实现分布式锁？</h3><p>下面讲如何实现排他锁和共享锁，以及如何解决羊群效应。</p><h4 id="排他锁"><a href="#排他锁" class="headerlink" title="排他锁"></a>排他锁</h4><p>排他锁，又称写锁或独占锁。如果事务T1对数据对象O1加上了排他锁，那么在整个加锁期间，只允许事务T1对O1进行读取或更新操作，其他任务事务都不能对这个数据对象进行任何操作，直到T1释放了排他锁。</p><p>排他锁核心是<strong>保证当前有且仅有一个事务获得锁，并且锁释放之后，所有正在等待获取锁的事务都能够被通知到</strong>。</p><p>Zookeeper 的强一致性特性，能够很好地保证在分布式高并发情况下<strong>节点的创建一定能够保证全局唯一性</strong>，即Zookeeper将会保证客户端无法重复创建一个已经存在的数据节点。可以利用Zookeeper这个特性，实现排他锁。</p><ul><li><strong>定义锁</strong>：通过Zookeeper上的数据节点来表示一个锁</li><li><strong>获取锁</strong>：客户端通过调用 <code>create</code> 方法创建表示锁的临时节点，可以认为创建成功的客户端获得了锁，同时可以让没有获得锁的节点在该节点上注册Watcher监听，以便实时监听到lock节点的变更情况</li><li><strong>释放锁</strong>：以下两种情况都可以让锁释放<ul><li>当前获得锁的客户端发生宕机或异常，那么Zookeeper上这个临时节点就会被删除</li><li>正常执行完业务逻辑，客户端主动删除自己创建的临时节点</li></ul></li></ul><p>基于Zookeeper实现排他锁流程：</p><p><img src="http://image.laijianfeng.org/20190124_133414.jpg" alt="基于Zookeeper实现排他锁流程"></p><h4 id="共享锁"><a href="#共享锁" class="headerlink" title="共享锁"></a>共享锁</h4><p>共享锁，又称读锁。如果事务T1对数据对象O1加上了共享锁，那么当前事务只能对O1进行<strong>读取操作</strong>，其他事务也只能对这个数据对象加共享锁，直到该数据对象上的所有共享锁都被释放。</p><p>共享锁与排他锁的区别在于，加了排他锁之后，数据对象只对当前事务可见，而加了共享锁之后，数据对象对所有事务都可见。</p><ul><li><strong>定义锁</strong>：通过Zookeeper上的数据节点来表示一个锁，是一个类似于 <code>/lockpath/[hostname]-请求类型-序号</code> 的临时顺序节点</li><li><strong>获取锁</strong>：客户端通过调用 <code>create</code> 方法创建表示锁的临时顺序节点，如果是读请求，则创建 <code>/lockpath/[hostname]-R-序号</code> 节点，如果是写请求则创建 <code>/lockpath/[hostname]-W-序号</code> 节点</li><li><strong>判断读写顺序</strong>：大概分为4个步骤<ul><li>1)创建完节点后，获取 <code>/lockpath</code> 节点下的所有子节点，并对该节点注册子节点变更的Watcher监听</li><li>2)确定自己的节点序号在所有子节点中的顺序</li><li>3.1)对于读请求：1. 如果没有比自己序号更小的子节点，或者比自己序号小的子节点都是读请求，那么表明自己已经成功获取到了共享锁，同时开始执行读取逻辑 2. 如果有比自己序号小的子节点有写请求，那么等待 3. </li><li>3.2)对于写请求，如果自己不是序号最小的节点，那么等待</li><li>4)接收到Watcher通知后，重复步骤1)</li></ul></li><li><strong>释放锁</strong>：与排他锁逻辑一致</li></ul><p><img src="http://image.laijianfeng.org/2019-01-28_20-08-52.jpg" alt="Zookeeper实现共享锁节点树"></p><p>基于Zookeeper实现共享锁流程：</p><p><img src="http://image.laijianfeng.org/2019-01-28_20-08-50.jpg" alt="基于Zookeeper实现共享锁流程"></p><h4 id="羊群效应"><a href="#羊群效应" class="headerlink" title="羊群效应"></a>羊群效应</h4><p>在实现共享锁的 “判断读写顺序” 的第1个步骤是：创建完节点后，获取 <code>/lockpath</code> 节点下的所有子节点，并对该节点注册子节点变更的Watcher监听。这样的话，任何一次客户端移除共享锁之后，Zookeeper将会发送子节点变更的Watcher通知给所有机器，系统中将有大量的 “Watcher通知” 和 “子节点列表获取” 这个操作重复执行，然后所有节点再判断自己是否是序号最小的节点(写请求)或者判断比自己序号小的子节点是否都是读请求(读请求)，从而继续等待下一次通知。</p><p>然而，这些重复操作很多都是 “无用的”，实际上<strong>每个锁竞争者只需要关注序号比自己小的那个节点是否存在即可</strong></p><p>当集群规模比较大时，这些 “无用的” 操作不仅会对Zookeeper造成巨大的性能影响和网络冲击，更为严重的是，如果同一时间有多个客户端释放了共享锁，Zookeeper服务器就会在短时间内向其余客户端发送大量的事件通知–这就是所谓的 “<strong>羊群效应</strong>“。</p><p><strong>改进后的分布式锁实现</strong>：</p><p>具体实现如下：</p><ul><li><ol><li>客户端调用 <code>create</code> 方法创建一个类似于 <code>/lockpath/[hostname]-请求类型-序号</code> 的临时顺序节点</li></ol></li><li><ol start="2"><li>客户端调用 <code>getChildren</code> 方法获取所有已经创建的子节点列表(这里不注册任何Watcher)</li></ol></li><li><ol start="3"><li>如果无法获取任何共享锁，那么调用 <code>exist</code> 来对比自己小的那个节点注册Watcher<ul><li>读请求：向比自己序号小的最后一个<strong>写请求节点</strong>注册Watcher监听</li><li>写请求：向比自己序号小的最后一个<strong>节点</strong>注册Watcher监听</li></ul></li></ol></li><li><ol start="4"><li>等待Watcher监听，继续进入步骤2</li></ol></li></ul><p>Zookeeper羊群效应改进前后Watcher监听图</p><p><img src="http://image.laijianfeng.org/2019-01-28_20-08-53.jpg" alt="Zookeeper羊群效应改进前后"></p><h3 id="基于Curator客户端实现分布式锁"><a href="#基于Curator客户端实现分布式锁" class="headerlink" title="基于Curator客户端实现分布式锁"></a>基于Curator客户端实现分布式锁</h3><p>Apache Curator是一个Zookeeper的开源客户端，它提供了Zookeeper各种应用场景（Recipe，如共享锁服务、master选举、分布式计数器等）的抽象封装，接下来将利用Curator提供的类来实现分布式锁。</p><p>Curator提供的跟分布式锁相关的类有5个，分别是：</p><ul><li>Shared Reentrant Lock 可重入锁</li><li>Shared Lock 共享不可重入锁</li><li>Shared Reentrant Read Write Lock 可重入读写锁</li><li>Shared Semaphore 信号量</li><li>Multi Shared Lock 多锁</li></ul><blockquote><p>关于错误处理：还是强烈推荐使用ConnectionStateListener处理连接状态的改变。当连接LOST时你不再拥有锁。</p></blockquote><h4 id="可重入锁"><a href="#可重入锁" class="headerlink" title="可重入锁"></a>可重入锁</h4><p>Shared Reentrant Lock，全局可重入锁，所有客户端都可以请求，同一个客户端在拥有锁的同时，可以多次获取，不会被阻塞。它是由类 <code>InterProcessMutex</code> 来实现，它的主要方法：</p><pre><code class="java">// 构造方法public InterProcessMutex(CuratorFramework client, String path)public InterProcessMutex(CuratorFramework client, String path, LockInternalsDriver driver)// 通过acquire获得锁,并提供超时机制：public void acquire() throws Exceptionpublic boolean acquire(long time, TimeUnit unit) throws Exception// 撤销锁public void makeRevocable(RevocationListener&lt;InterProcessMutex&gt; listener)public void makeRevocable(final RevocationListener&lt;InterProcessMutex&gt; listener, Executor executor)</code></pre><p>定义一个 FakeLimitedResource 类来模拟一个共享资源，该资源一次只能被一个线程使用，直到使用结束，下一个线程才能使用，否则会抛出异常</p><pre><code class="java">public class FakeLimitedResource {    private final AtomicBoolean inUse = new AtomicBoolean(false);    // 模拟只能单线程操作的资源    public void use() throws InterruptedException {        if (!inUse.compareAndSet(false, true)) {            // 在正确使用锁的情况下，此异常不可能抛出            throw new IllegalStateException(&quot;Needs to be used by one client at a time&quot;);        }        try {            Thread.sleep((long) (100 * Math.random()));        } finally {            inUse.set(false);        }    }}</code></pre><p>下面的代码将创建 N 个线程来模拟分布式系统中的节点，系统将通过 InterProcessMutex 来控制对资源的同步使用；每个节点都将发起10次请求，完成 <code>请求锁--访问资源--再次请求锁--释放锁--释放锁</code> 的过程；客户端通过 <code>acquire</code> 请求锁，通过 <code>release</code> 释放锁，获得几把锁就要释放几把锁；这个共享资源一次只能被一个线程使用，如果控制同步失败，将抛异常。</p><pre><code class="java">public class SharedReentrantLockTest {    private static final String lockPath = &quot;/testZK/sharedreentrantlock&quot;;    private static final Integer clientNums = 5;    final static FakeLimitedResource resource = new FakeLimitedResource(); // 共享的资源    private static CountDownLatch countDownLatch = new CountDownLatch(clientNums);    public static void main(String[] args) throws InterruptedException {        for (int i = 0; i &lt; clientNums; i++) {            String clientName = &quot;client#&quot; + i;            new Thread(new Runnable() {                @Override                public void run() {                    CuratorFramework client = ZKUtils.getClient();                    client.start();                    Random random = new Random();                    try {                        final InterProcessMutex lock = new InterProcessMutex(client, lockPath);                        // 每个客户端请求10次共享资源                        for (int j = 0; j &lt; 10; j++) {                            if (!lock.acquire(10, TimeUnit.SECONDS)) {                                throw new IllegalStateException(j + &quot;. &quot; + clientName + &quot; 不能得到互斥锁&quot;);                            }                            try {                                System.out.println(j + &quot;. &quot; + clientName + &quot; 已获取到互斥锁&quot;);                                resource.use(); // 使用资源                                if (!lock.acquire(10, TimeUnit.SECONDS)) {                                    throw new IllegalStateException(j + &quot;. &quot; + clientName + &quot; 不能再次得到互斥锁&quot;);                                }                                System.out.println(j + &quot;. &quot; + clientName + &quot; 已再次获取到互斥锁&quot;);                                lock.release(); // 申请几次锁就要释放几次锁                            } finally {                                System.out.println(j + &quot;. &quot; + clientName + &quot; 释放互斥锁&quot;);                                lock.release(); // 总是在finally中释放                            }                            Thread.sleep(random.nextInt(100));                        }                    } catch (Throwable e) {                        System.out.println(e.getMessage());                    } finally {                        CloseableUtils.closeQuietly(client);                        System.out.println(clientName + &quot; 客户端关闭！&quot;);                        countDownLatch.countDown();                    }                }            }).start();        }        countDownLatch.await();        System.out.println(&quot;结束！&quot;);    }}</code></pre><p>控制台打印日志，可以看到对资源的同步访问控制成功，并且锁是可重入的</p><pre><code>0. client#3 已获取到互斥锁0. client#3 已再次获取到互斥锁0. client#3 释放互斥锁0. client#1 已获取到互斥锁0. client#1 已再次获取到互斥锁0. client#1 释放互斥锁0. client#2 已获取到互斥锁0. client#2 已再次获取到互斥锁0. client#2 释放互斥锁0. client#0 已获取到互斥锁0. client#0 已再次获取到互斥锁0. client#0 释放互斥锁0. client#4 已获取到互斥锁0. client#4 已再次获取到互斥锁0. client#4 释放互斥锁1. client#1 已获取到互斥锁1. client#1 已再次获取到互斥锁1. client#1 释放互斥锁2. client#1 已获取到互斥锁2. client#1 已再次获取到互斥锁2. client#1 释放互斥锁1. client#4 已获取到互斥锁1. client#4 已再次获取到互斥锁1. client#4 释放互斥锁1. client#3 已获取到互斥锁1. client#3 已再次获取到互斥锁1. client#3 释放互斥锁1. client#2 已获取到互斥锁1. client#2 已再次获取到互斥锁1. client#2 释放互斥锁2. client#4 已获取到互斥锁2. client#4 已再次获取到互斥锁2. client#4 释放互斥锁........client#2 客户端关闭！9. client#0 已获取到互斥锁9. client#0 已再次获取到互斥锁9. client#0 释放互斥锁9. client#3 已获取到互斥锁9. client#3 已再次获取到互斥锁9. client#3 释放互斥锁client#0 客户端关闭！8. client#4 已获取到互斥锁8. client#4 已再次获取到互斥锁8. client#4 释放互斥锁9. client#4 已获取到互斥锁9. client#4 已再次获取到互斥锁9. client#4 释放互斥锁client#3 客户端关闭！client#4 客户端关闭！结束！</code></pre><p>同时在程序运行期间查看Zookeeper节点树，可以发现每一次请求的锁实际上对应一个临时顺序节点</p><pre><code>[zk: localhost:2181(CONNECTED) 42] ls /testZK/sharedreentrantlock[leases, _c_208d461b-716d-43ea-ac94-1d2be1206db3-lock-0000001659, locks, _c_64b19dba-3efa-46a6-9344-19a52e9e424f-lock-0000001658, _c_cee02916-d7d5-4186-8867-f921210b8815-lock-0000001657]</code></pre><h4 id="不可重入锁"><a href="#不可重入锁" class="headerlink" title="不可重入锁"></a>不可重入锁</h4><p>Shared Lock 与 Shared Reentrant Lock 相似，但是<strong>不可重入</strong>。这个不可重入锁由类 InterProcessSemaphoreMutex 来实现，使用方法和上面的类类似。</p><p>将上面程序中的 InterProcessMutex 换成不可重入锁 InterProcessSemaphoreMutex，如果再运行上面的代码，结果就会发现线程被阻塞在第二个 <code>acquire</code> 上，直到超时，也就是此锁不是可重入的。</p><p>控制台输出日志</p><pre><code>0. client#2 已获取到互斥锁0. client#1 不能得到互斥锁0. client#4 不能得到互斥锁0. client#0 不能得到互斥锁0. client#3 不能得到互斥锁client#1 客户端关闭！client#4 客户端关闭！client#3 客户端关闭！client#0 客户端关闭！0. client#2 释放互斥锁0. client#2 不能再次得到互斥锁client#2 客户端关闭！结束！</code></pre><p>把第二个获取锁的代码注释，程序才能正常执行</p><pre><code>0. client#1 已获取到互斥锁0. client#1 释放互斥锁0. client#2 已获取到互斥锁0. client#2 释放互斥锁0. client#0 已获取到互斥锁0. client#0 释放互斥锁0. client#4 已获取到互斥锁0. client#4 释放互斥锁0. client#3 已获取到互斥锁0. client#3 释放互斥锁1. client#1 已获取到互斥锁1. client#1 释放互斥锁1. client#2 已获取到互斥锁1. client#2 释放互斥锁........9. client#4 已获取到互斥锁9. client#4 释放互斥锁9. client#0 已获取到互斥锁client#2 客户端关闭！9. client#0 释放互斥锁9. client#1 已获取到互斥锁client#0 客户端关闭！client#4 客户端关闭！9. client#1 释放互斥锁9. client#3 已获取到互斥锁client#1 客户端关闭！9. client#3 释放互斥锁client#3 客户端关闭！结束！</code></pre><h4 id="可重入读写锁"><a href="#可重入读写锁" class="headerlink" title="可重入读写锁"></a>可重入读写锁</h4><p>Shared Reentrant Read Write Lock，可重入读写锁，一个读写锁管理一对相关的锁，一个负责读操作，另外一个负责写操作；读操作在写锁没被使用时可同时由多个进程使用，而写锁在使用时不允许读(阻塞)；此锁是可重入的；一个拥有写锁的线程可重入读锁，但是读锁却不能进入写锁，这也意味着写锁可以降级成读锁， 比如 <code>请求写锁 ---&gt;读锁 ----&gt;释放写锁</code>；从读锁升级成写锁是不行的。</p><p>可重入读写锁主要由两个类实现：InterProcessReadWriteLock、InterProcessMutex，使用时首先创建一个 InterProcessReadWriteLock 实例，然后再根据你的需求得到读锁或者写锁，读写锁的类型是 InterProcessMutex。</p><pre><code class="java">    public static void main(String[] args) throws InterruptedException {        for (int i = 0; i &lt; clientNums; i++) {            final String clientName = &quot;client#&quot; + i;            new Thread(new Runnable() {                @Override                public void run() {                    CuratorFramework client = ZKUtils.getClient();                    client.start();                    final InterProcessReadWriteLock lock = new InterProcessReadWriteLock(client, lockPath);                    final InterProcessMutex readLock = lock.readLock();                    final InterProcessMutex writeLock = lock.writeLock();                    try {                        // 注意只能先得到写锁再得到读锁，不能反过来！！！                        if (!writeLock.acquire(10, TimeUnit.SECONDS)) {                            throw new IllegalStateException(clientName + &quot; 不能得到写锁&quot;);                        }                        System.out.println(clientName + &quot; 已得到写锁&quot;);                        if (!readLock.acquire(10, TimeUnit.SECONDS)) {                            throw new IllegalStateException(clientName + &quot; 不能得到读锁&quot;);                        }                        System.out.println(clientName + &quot; 已得到读锁&quot;);                        try {                            resource.use(); // 使用资源                        } finally {                            System.out.println(clientName + &quot; 释放读写锁&quot;);                            readLock.release();                            writeLock.release();                        }                    } catch (Exception e) {                        System.out.println(e.getMessage());                    } finally {                        CloseableUtils.closeQuietly(client);                        countDownLatch.countDown();                    }                }            }).start();        }        countDownLatch.await();        System.out.println(&quot;结束！&quot;);    }}</code></pre><p>控制台打印日志</p><pre><code>client#1 已得到写锁client#1 已得到读锁client#1 释放读写锁client#2 已得到写锁client#2 已得到读锁client#2 释放读写锁client#0 已得到写锁client#0 已得到读锁client#0 释放读写锁client#4 已得到写锁client#4 已得到读锁client#4 释放读写锁client#3 已得到写锁client#3 已得到读锁client#3 释放读写锁结束！</code></pre><h4 id="信号量"><a href="#信号量" class="headerlink" title="信号量"></a>信号量</h4><p>Shared Semaphore，一个计数的信号量类似JDK的 Semaphore，JDK中 Semaphore 维护的一组许可(permits)，而Cubator中称之为租约(Lease)。有两种方式可以决定 semaphore 的最大租约数，第一种方式是由用户给定的 path 决定，第二种方式使用 SharedCountReader 类。如果不使用 SharedCountReader，没有内部代码检查进程是否假定有10个租约而进程B假定有20个租约。 所以所有的实例必须使用相同的 numberOfLeases 值.</p><p>信号量主要实现类有：</p><pre><code>InterProcessSemaphoreV2 - 信号量实现类Lease - 租约(单个信号)SharedCountReader - 计数器，用于计算最大租约数量</code></pre><p>调用 <code>acquire</code> 会返回一个租约对象，客户端必须在 finally 中 close 这些租约对象，否则这些租约会丢失掉。但是，如果客户端session由于某种原因比如crash丢掉，那么这些客户端持有的租约会自动close，这样其它客户端可以继续使用这些租约。租约还可以通过下面的方式返还：</p><pre><code>public void returnLease(Lease lease)public void returnAll(Collection&lt;Lease&gt; leases) </code></pre><p>注意一次你可以请求多个租约，如果 Semaphore 当前的租约不够，则请求线程会被阻塞。同时还提供了超时的重载方法。</p><pre><code>public Lease acquire() throws Exceptionpublic Collection&lt;Lease&gt; acquire(int qty) throws Exceptionpublic Lease acquire(long time, TimeUnit unit) throws Exceptionpublic Collection&lt;Lease&gt; acquire(int qty, long time, TimeUnit unit) throws Exception</code></pre><p>一个Demo程序如下</p><pre><code class="java">public class SharedSemaphoreTest {    private static final int MAX_LEASE = 10;    private static final String PATH = &quot;/testZK/semaphore&quot;;    private static final FakeLimitedResource resource = new FakeLimitedResource();    public static void main(String[] args) throws Exception {        CuratorFramework client = ZKUtils.getClient();        client.start();        InterProcessSemaphoreV2 semaphore = new InterProcessSemaphoreV2(client, PATH, MAX_LEASE);        Collection&lt;Lease&gt; leases = semaphore.acquire(5);        System.out.println(&quot;获取租约数量：&quot; + leases.size());        Lease lease = semaphore.acquire();        System.out.println(&quot;获取单个租约&quot;);        resource.use(); // 使用资源        // 再次申请获取5个leases，此时leases数量只剩4个，不够，将超时        Collection&lt;Lease&gt; leases2 = semaphore.acquire(5, 10, TimeUnit.SECONDS);        System.out.println(&quot;获取租约，如果超时将为null： &quot; + leases2);        System.out.println(&quot;释放租约&quot;);        semaphore.returnLease(lease);        // 再次申请获取5个，这次刚好够        leases2 = semaphore.acquire(5, 10, TimeUnit.SECONDS);        System.out.println(&quot;获取租约，如果超时将为null： &quot; + leases2);        System.out.println(&quot;释放集合中的所有租约&quot;);        semaphore.returnAll(leases);        semaphore.returnAll(leases2);        client.close();        System.out.println(&quot;结束!&quot;);    }}</code></pre><p>控制台打印日志</p><pre><code>获取租约数量：5获取单个租约获取租约，如果超时将为null： null释放租约获取租约，如果超时将为null： [org.apache.curator.framework.recipes.locks.InterProcessSemaphoreV2$3@3108bc, org.apache.curator.framework.recipes.locks.InterProcessSemaphoreV2$3@370736d9, org.apache.curator.framework.recipes.locks.InterProcessSemaphoreV2$3@5f9d02cb, org.apache.curator.framework.recipes.locks.InterProcessSemaphoreV2$3@63753b6d, org.apache.curator.framework.recipes.locks.InterProcessSemaphoreV2$3@6b09bb57]释放集合中的所有租约结束!</code></pre><p>注意：上面所讲的4种锁都是公平锁(fair)。从ZooKeeper的角度看，每个客户端都按照请求的顺序获得锁，相当公平。</p><h4 id="多锁"><a href="#多锁" class="headerlink" title="多锁"></a>多锁</h4><p>Multi Shared Lock 是一个锁的容器。当调用 <code>acquire</code>，所有的锁都会被 <code>acquire</code>，如果请求失败，所有的锁都会被 <code>release</code>。同样调用 <code>release</code> 时所有的锁都被 <code>release</code>(失败被忽略)。基本上，它就是组锁的代表，在它上面的请求释放操作都会传递给它包含的所有的锁。</p><p>主要涉及两个类：</p><pre><code>InterProcessMultiLock - 对所对象实现类InterProcessLock - 分布式锁接口类</code></pre><p>它的构造函数需要包含的锁的集合，或者一组 ZooKeeper 的 path，用法和 Shared Lock 相同</p><pre><code>public InterProcessMultiLock(CuratorFramework client, List&lt;String&gt; paths)public InterProcessMultiLock(List&lt;InterProcessLock&gt; locks)</code></pre><p>一个Demo程序如下</p><pre><code class="java">public class MultiSharedLockTest {    private static final String lockPath1 = &quot;/testZK/MSLock1&quot;;    private static final String lockPath2 = &quot;/testZK/MSLock2&quot;;    private static final FakeLimitedResource resource = new FakeLimitedResource();    public static void main(String[] args) throws Exception {        CuratorFramework client = ZKUtils.getClient();        client.start();        InterProcessLock lock1 = new InterProcessMutex(client, lockPath1); // 可重入锁        InterProcessLock lock2 = new InterProcessSemaphoreMutex(client, lockPath2); // 不可重入锁        // 组锁，多锁        InterProcessMultiLock lock = new InterProcessMultiLock(Arrays.asList(lock1, lock2));        if (!lock.acquire(10, TimeUnit.SECONDS)) {            throw new IllegalStateException(&quot;不能获取多锁&quot;);        }        System.out.println(&quot;已获取多锁&quot;);        System.out.println(&quot;是否有第一个锁: &quot; + lock1.isAcquiredInThisProcess());        System.out.println(&quot;是否有第二个锁: &quot; + lock2.isAcquiredInThisProcess());        try {            resource.use(); // 资源操作        } finally {            System.out.println(&quot;释放多个锁&quot;);            lock.release(); // 释放多锁        }        System.out.println(&quot;是否有第一个锁: &quot; + lock1.isAcquiredInThisProcess());        System.out.println(&quot;是否有第二个锁: &quot; + lock2.isAcquiredInThisProcess());        client.close();        System.out.println(&quot;结束!&quot;);    }}</code></pre><blockquote><p><strong>代码下载地址</strong>：<a href="http://t.cn/EtVc1s4" target="_blank" rel="noopener">http://t.cn/EtVc1s4</a></p></blockquote><h4 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h4><p>1、 《从Paxos到Zookeeper分布式一致性原理与实践》<br>2、 <a href="http://curator.apache.org/curator-recipes/index.html" target="_blank" rel="noopener">Apache Curator Recipes Docs</a><br>3、 <a href="http://www.hollischuang.com/archives/1716" target="_blank" rel="noopener">分布式锁的几种实现方式~</a><br>4、 <a href="http://www.spring4all.com/question/158" target="_blank" rel="noopener">技术专题讨论第四期：漫谈分布式锁</a><br>5、 <a href="https://zhuanlan.zhihu.com/p/42056183" target="_blank" rel="noopener">分布式锁看这篇就够了</a><br>6、 <a href="https://www.cnblogs.com/LiZhiW/p/4931577.html" target="_blank" rel="noopener">Curator分布式锁</a></p><p><img src="http://image.laijianfeng.org/20190116_014816.png" alt="关注_小旋锋_微信公众号"></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;在许多场景中，&lt;strong&gt;数据一致性&lt;/strong&gt;是一个比较重要的话题，在单机环境中，我们可以通过Java提供的&lt;strong&gt;并发API&lt;/strong&gt;来解决；而在分布式环境(会遇到网络故障、消息重复、消息丢失等各种问题)下要复杂得多，常见的解决方案是&lt;stro
      
    
    </summary>
    
      <category term="大数据" scheme="http://laijianfeng.org/categories/%E5%A4%A7%E6%95%B0%E6%8D%AE/"/>
    
    
      <category term="Zookeeper" scheme="http://laijianfeng.org/tags/Zookeeper/"/>
    
  </entry>
  
  <entry>
    <title>利用Zookeeper实现 - 数据发布订阅</title>
    <link href="http://laijianfeng.org/2019/01/%E5%88%A9%E7%94%A8Zookeeper%E5%AE%9E%E7%8E%B0-%E6%95%B0%E6%8D%AE%E5%8F%91%E5%B8%83%E8%AE%A2%E9%98%85/"/>
    <id>http://laijianfeng.org/2019/01/利用Zookeeper实现-数据发布订阅/</id>
    <published>2019-01-23T18:13:43.000Z</published>
    <updated>2019-01-23T18:28:27.269Z</updated>
    
    <content type="html"><![CDATA[<h3 id="数据发布-订阅"><a href="#数据发布-订阅" class="headerlink" title="数据发布/订阅"></a>数据发布/订阅</h3><p>所谓的数据发布/订阅，意思是发布者将数据发布到Zookeeper上的一个或一系列节点上，通过watcher机制，客户端可以监听(订阅)这些数据节点，当这些节点发生变化时，Zookeeper及时地通知客户端，从而达到动态获取数据的目的。</p><p>一种常见的场景就是配置中心。随着应用越来越多，功能越来越复杂，机器也越来越多，对于一些公共的程序配置，譬如各种功能的开关、数据库的配置、服务器的地址等，如果每个应用每个机器仍然单独维护，当要修改配置时就得一个一个地修改，这样显然非常不方便。</p><p>这些公共的配置信息通常具备以下3个特性：</p><ul><li>数据量通常比较小</li><li>数据内容在运行时发生动态变化</li><li>集群中各机器共享、配置一致</li></ul><p>可以将这些配置抽取出来，交给配置中心统一管理起来。配置中心的架构一般是这样：</p><p><img src="http://image.laijianfeng.org/20190123_133414.jpg" alt="配置中心结构图"></p><h3 id="开源配置中心"><a href="#开源配置中心" class="headerlink" title="开源配置中心"></a>开源配置中心</h3><p>开源的配置中心有很多，各有特点，这里只列出几个进行简单地介绍。</p><h4 id="Ctrip-Apollo"><a href="#Ctrip-Apollo" class="headerlink" title="Ctrip Apollo"></a>Ctrip Apollo</h4><p>github地址：<a href="https://github.com/ctripcorp/apollo" target="_blank" rel="noopener">https://github.com/ctripcorp/apollo</a></p><p>介绍：Apollo（阿波罗）是携程框架部门研发的分布式配置中心，能够集中化管理应用不同环境、不同集群的配置，配置修改后能够实时推送到应用端，并且具备规范的权限、流程治理等特性，适用于微服务配置管理场景。</p><h4 id="Disconf"><a href="#Disconf" class="headerlink" title="Disconf"></a>Disconf</h4><p>github地址：<a href="https://github.com/knightliao/disconf" target="_blank" rel="noopener">https://github.com/knightliao/disconf</a></p><p>介绍：专注于各种「分布式系统配置管理」的「通用组件」和「通用平台」, 提供统一的「配置管理服务」。主要目标是部署极其简单、部署动态化、统一管理、一个jar包，到处运行。</p><h4 id="Spring-Cloud-Config"><a href="#Spring-Cloud-Config" class="headerlink" title="Spring Cloud Config"></a>Spring Cloud Config</h4><p>github地址：<a href="https://github.com/spring-cloud/spring-cloud-config" target="_blank" rel="noopener">https://github.com/spring-cloud/spring-cloud-config</a></p><p>介绍：Spring Cloud Config是一个基于http协议的远程配置实现方式，通过统一的配置管理服务器进行配置管理，客户端通过https协议主动的拉取服务的的配置信息，完成配置获取。</p><h4 id="Nacos"><a href="#Nacos" class="headerlink" title="Nacos"></a>Nacos</h4><p>github地址：<a href="https://github.com/alibaba/nacos" target="_blank" rel="noopener">https://github.com/alibaba/nacos</a></p><p>介绍：Nacos是阿里最近才开源的一个更易于构建云原生应用的动态服务发现、配置管理和服务管理平台。Nacos 致力于帮助您发现、配置和管理微服务。Nacos提供了一组简单易用的特性集，帮助您快速实现动态服务发现、服务配置、服务元数据及流量管理。</p><h4 id="利用Zookeeper实现一个配置中心"><a href="#利用Zookeeper实现一个配置中心" class="headerlink" title="利用Zookeeper实现一个配置中心"></a>利用Zookeeper实现一个配置中心</h4><p>开源的配置中心当然都很优秀，但是现在我们还是先利用Zookeeper来实现一个属于自己的配置中心。</p><p>我们的配置中心保存的配置信息十分简单，就是JDBC连接MySQL需要用的连接信息。这些连接信息将转化为JSON字符串，保存在Zookeeper上的一个节点中；应用程序(通过线程模拟的)从Zookeeper中读取这些配置信息，然后查询数据库；当修改数据库连接信息时(<strong>切换数据库</strong>)，应用程序能及时的拉取新的连接信息，使用新的连接查询数据库。</p><p>定义一个 MysqlConfig 类，方便使用 FastJSON 将配置信息在JSON字符串与对象之间做转换。</p><pre><code class="java">@AllArgsConstructor@Datapublic class MysqlConfig {    private String url;    private String driver;    private String username;    private String password;}</code></pre><p>最开始，将Zookeeper上节点的配置信息初始化为 test 数据库的连接信息，然后启动 N 个线程(模拟应用程序)，读取连接信息并查询数据，同时设置监听节点；等待 10 秒钟之后，将配置切换为 test2 数据库的连接信息，这时应用程序将受到配置变更的通知，然后获取信息连接信息，重新查询数据库。</p><pre><code class="java">// 工具类public class ZKUtils {    private static final String zkServerIps = &quot;master:2181,hadoop2:2181&quot;;    public static synchronized CuratorFramework getClient() {        CuratorFramework client = CuratorFrameworkFactory.builder().connectString(zkServerIps)                .sessionTimeoutMs(6000).connectionTimeoutMs(3000) //.namespace(&quot;LeaderLatchTest&quot;)                .retryPolicy(new ExponentialBackoffRetry(1000, 3)).build();        return client;    }}// 配置中心示例，模拟数据库切换public class ConfigCenterTest {    // test 数据库的 test1 表    private static final MysqlConfig mysqlConfig_1 = new MysqlConfig(&quot;jdbc:mysql://master:3306/test?useUnicode=true&amp;characterEncoding=utf-8&amp;useSSL=false&quot;, &quot;com.mysql.jdbc.Driver&quot;, &quot;root&quot;, &quot;123456&quot;);    // test2 数据库的 test1 表    private static final MysqlConfig mysqlConfig_2 = new MysqlConfig(&quot;jdbc:mysql://master:3306/test2?useUnicode=true&amp;characterEncoding=utf-8&amp;useSSL=false&quot;, &quot;com.mysql.jdbc.Driver&quot;, &quot;root&quot;, &quot;123456&quot;);    // 存储MySQL配置信息的节点路径    private static final String configPath = &quot;/testZK/jdbc/mysql&quot;;    private static final Integer clientNums = 3;    private static CountDownLatch countDownLatch = new CountDownLatch(clientNums);    public static void main(String[] args) throws Exception {        // 最开始时设置MySQL配置信息为 mysqlConfig_1        setMysqlConfig(mysqlConfig_1);        // 启动 clientNums 个线程，模拟分布式系统中的节点，        // 从Zookeeper中获取MySQL的配置信息，查询数据        for (int i = 0; i &lt; clientNums; i++) {            String clientName = &quot;client#&quot; + i;            new Thread(new Runnable() {                @Override                public void run() {                    CuratorFramework client = ZKUtils.getClient();                    client.start();                    try {                        Stat stat = new Stat();                        // 如果要监听多个子节点则应该使用 PathChildrenCache                        final NodeCache cacheNode = new NodeCache(client, configPath, false);                        cacheNode.start(true);  // true 表示启动时立即从Zookeeper上获取节点                        byte[] nodeData = cacheNode.getCurrentData().getData();                        MysqlConfig mysqlConfig = JSON.parseObject(new String(nodeData), MysqlConfig.class);                        queryMysql(clientName, mysqlConfig);    // 查询数据                        cacheNode.getListenable().addListener(new NodeCacheListener() {                            @Override                            public void nodeChanged() throws Exception {                                byte[] newData = cacheNode.getCurrentData().getData();                                MysqlConfig newMysqlConfig = JSON.parseObject(new String(newData), MysqlConfig.class);                                queryMysql(clientName, newMysqlConfig);    // 查询数据                            }                        });                        Thread.sleep(20 * 1000);                    } catch (Exception e) {                        e.printStackTrace();                    } finally {                        client.close();                        countDownLatch.countDown();                    }                }            }).start();        }        Thread.sleep(10 * 1000);        System.out.println(&quot;\n---------10秒钟后将MySQL配置信息修改为 mysqlConfig_2---------\n&quot;);        setMysqlConfig(mysqlConfig_2);        countDownLatch.await();    }    /**     * 初始化，最开始的时候的MySQL配置为 mysqlConfig_1     */    public static void setMysqlConfig(MysqlConfig config) throws Exception {        CuratorFramework client = ZKUtils.getClient();        client.start();        String mysqlConfigStr = JSON.toJSONString(config);        Stat s = client.checkExists().forPath(configPath);        if (s != null) {            Stat resultStat = client.setData().forPath(configPath, mysqlConfigStr.getBytes());            System.out.println(String.format(&quot;节点 %s 已存在，更新数据为：%s&quot;, configPath, mysqlConfigStr));        } else {            client.create().creatingParentsIfNeeded().withMode(CreateMode.PERSISTENT).forPath(configPath, mysqlConfigStr.getBytes());            System.out.println(String.format(&quot;创建节点：%s，初始化数据为：%s&quot;, configPath, mysqlConfigStr));        }        System.out.println();        client.close();    }    /**     * 通过配置信息，查询MySQL数据库     */    public static synchronized void queryMysql(String clientName, MysqlConfig mysqlConfig) throws ClassNotFoundException, SQLException {        System.out.println(clientName + &quot; 查询MySQL数据，使用的MySQL配置信息：&quot; + mysqlConfig);        Class.forName(mysqlConfig.getDriver());        Connection connection = DriverManager.getConnection(mysqlConfig.getUrl(), mysqlConfig.getUsername(), mysqlConfig.getPassword());        Statement statement = connection.createStatement();        ResultSet resultSet = statement.executeQuery(&quot;select * from test1&quot;);        while (resultSet.next()) {            System.out.println(String.format(&quot;id=%s, name=%s, age=%s&quot;, resultSet.getString(1), resultSet.getString(2), resultSet.getString(3)));        }        System.out.println();        resultSet.close();        statement.close();        connection.close();    }}</code></pre><p>控制台打印日志</p><pre><code>client#2 查询MySQL数据，使用的MySQL配置信息：MysqlConfig(url=jdbc:mysql://master:3306/test?useUnicode=true&amp;characterEncoding=utf-8&amp;useSSL=false, driver=com.mysql.jdbc.Driver, username=root, password=123456)id=2, name=赖键锋, age=25id=3, name=小旋锋, age=22000id=4, name=test, age=100client#1 查询MySQL数据，使用的MySQL配置信息：MysqlConfig(url=jdbc:mysql://master:3306/test?useUnicode=true&amp;characterEncoding=utf-8&amp;useSSL=false, driver=com.mysql.jdbc.Driver, username=root, password=123456)id=2, name=赖键锋, age=25id=3, name=小旋锋, age=22000id=4, name=test, age=100client#0 查询MySQL数据，使用的MySQL配置信息：MysqlConfig(url=jdbc:mysql://master:3306/test?useUnicode=true&amp;characterEncoding=utf-8&amp;useSSL=false, driver=com.mysql.jdbc.Driver, username=root, password=123456)id=2, name=赖键锋, age=25id=3, name=小旋锋, age=22000id=4, name=test, age=100---------10秒钟后将MySQL配置信息修改为 mysqlConfig_2---------节点 /testZK/jdbc/mysql 已存在，更新数据为：{&quot;driver&quot;:&quot;com.mysql.jdbc.Driver&quot;,&quot;password&quot;:&quot;123456&quot;,&quot;url&quot;:&quot;jdbc:mysql://master:3306/test2?useUnicode=true&amp;characterEncoding=utf-8&amp;useSSL=false&quot;,&quot;username&quot;:&quot;root&quot;}client#1 查询MySQL数据，使用的MySQL配置信息：MysqlConfig(url=jdbc:mysql://master:3306/test2?useUnicode=true&amp;characterEncoding=utf-8&amp;useSSL=false, driver=com.mysql.jdbc.Driver, username=root, password=123456)id=2, name=赖键锋, age=23id=3, name=小旋锋, age=22id=4, name=whirly, age=24client#2 查询MySQL数据，使用的MySQL配置信息：MysqlConfig(url=jdbc:mysql://master:3306/test2?useUnicode=true&amp;characterEncoding=utf-8&amp;useSSL=false, driver=com.mysql.jdbc.Driver, username=root, password=123456)id=2, name=赖键锋, age=23id=3, name=小旋锋, age=22id=4, name=whirly, age=24client#0 查询MySQL数据，使用的MySQL配置信息：MysqlConfig(url=jdbc:mysql://master:3306/test2?useUnicode=true&amp;characterEncoding=utf-8&amp;useSSL=false, driver=com.mysql.jdbc.Driver, username=root, password=123456)id=2, name=赖键锋, age=23id=3, name=小旋锋, age=22id=4, name=whirly, age=24</code></pre><p>上面采用的示例是通过 NodeCache 来监听单个节点，如果要监听多个子节点则须使用 PathChildrenCache，使用示例可以参考《<a href="https://mp.weixin.qq.com/s?__biz=MzI1NDU0MTE1NA==&amp;mid=2247483840&amp;idx=1&amp;sn=615f280b8006333e3b943135e2156ce7&amp;chksm=e9c2edcddeb564dba4cfae6f1c7d125b374b3fb8caf36f0f5da3d48a7ca05d0190e7a98abff6&amp;scene=0&amp;xtrack=1#rd" target="_blank" rel="noopener">Zookeeper 分布式协调服务介绍</a>》</p><h4 id="相关文章"><a href="#相关文章" class="headerlink" title="相关文章"></a>相关文章</h4><ul><li><a href="https://mp.weixin.qq.com/s?__biz=MzI1NDU0MTE1NA==&amp;mid=2247483840&amp;idx=1&amp;sn=615f280b8006333e3b943135e2156ce7&amp;chksm=e9c2edcddeb564dba4cfae6f1c7d125b374b3fb8caf36f0f5da3d48a7ca05d0190e7a98abff6&amp;scene=0&amp;xtrack=1#rd" target="_blank" rel="noopener">Zookeeper 分布式协调服务介绍</a></li><li><a href="https://mp.weixin.qq.com/s?__biz=MzI1NDU0MTE1NA==&amp;mid=2247483848&amp;idx=1&amp;sn=dea24723c9e578cf1deaf540dc8f00ed&amp;chksm=e9c2edc5deb564d3f126329ce0940fadbdede07559c9d86a88a42b8038fcae8b1994ff6e45a9&amp;scene=0#rd" target="_blank" rel="noopener">利用Zookeeper实现 - Master选举</a></li></ul><h4 id="后序"><a href="#后序" class="headerlink" title="后序"></a>后序</h4><p>代码下载：<a href="http://t.cn/E5ncvDR" target="_blank" rel="noopener">http://t.cn/E5ncvDR</a></p><p>我的博客：laijianfeng.org</p><blockquote><p>参考：<br>《从Paxos到Zookeeper分布式一致性原理与实践》     </p></blockquote><p><img src="http://image.laijianfeng.org/20190116_014816.png" alt="关注_小旋锋_微信公众号"></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h3 id=&quot;数据发布-订阅&quot;&gt;&lt;a href=&quot;#数据发布-订阅&quot; class=&quot;headerlink&quot; title=&quot;数据发布/订阅&quot;&gt;&lt;/a&gt;数据发布/订阅&lt;/h3&gt;&lt;p&gt;所谓的数据发布/订阅，意思是发布者将数据发布到Zookeeper上的一个或一系列节点上，通过watc
      
    
    </summary>
    
      <category term="大数据" scheme="http://laijianfeng.org/categories/%E5%A4%A7%E6%95%B0%E6%8D%AE/"/>
    
    
      <category term="Zookeeper" scheme="http://laijianfeng.org/tags/Zookeeper/"/>
    
  </entry>
  
  <entry>
    <title>利用Zookeeper实现 - Master选举</title>
    <link href="http://laijianfeng.org/2019/01/%E5%88%A9%E7%94%A8Zookeeper%E5%AE%9E%E7%8E%B0-Master%E9%80%89%E4%B8%BE/"/>
    <id>http://laijianfeng.org/2019/01/利用Zookeeper实现-Master选举/</id>
    <published>2019-01-22T16:07:38.000Z</published>
    <updated>2019-01-22T16:13:02.635Z</updated>
    
    <content type="html"><![CDATA[<p>Zookeeper 是一个高可用的分布式数据管理与协调框架，基于ZAB协议算法的实现，该框架能够很好的保证分布式环境中数据的一致性。Zookeeper的典型应用场景主要有：数据发布/订阅、负载均衡、命名服务、分布式协调/通知、集群管理、Master选举、分布式锁和分布式队列等。</p><p>本文主要介绍如何利用Zookeeper实现Master选举。</p><h3 id="Master选举"><a href="#Master选举" class="headerlink" title="Master选举"></a>Master选举</h3><p>Master选举在分布式系统中是一个非常常见的场景。在分布式系统中，常常采用主从模式的方式避免单点故障，提高系统服务的可用性。正常情况下，Master节点用来协调集群中其他系统单元，维护系统状态信息，或者负责一些复杂的逻辑，再将处理结果同步给其他节点。当Master节点宕机，或者由于其他问题导致无法提供服务时，系统将发起一次Master选举，从候选节点中选出一个新的Master节点，以继续提供服务。</p><p>譬如在一些读写分离的应用中，Master节点负责客户端的写请求，处理完毕之后再将结果同步给从节点。</p><h4 id="选举算法？"><a href="#选举算法？" class="headerlink" title="选举算法？"></a>选举算法？</h4><p>著名的选举算法有 Paxos算法、Raft算法、Bully算法等，但在业务系统的开发中，实现选举算法并不是我们工作的重心。</p><p>Zookeeper有一个非常重要的特性即<strong>强一致性</strong>，能够很好地保证在分布式高并发情况下<strong>节点的创建一定能够保证全局唯一性</strong>，即Zookeeper将会保证客户端无法重复创建一个已经存在的数据节点。也就是说，如果同时有多个客户端请求创建同一个节点，那么最终一定只有一个客户端请求能够创建成功。利用这个特性，就能很容易地在分布式环境中进行Master选举了。</p><h3 id="利用Zookeeper实现Master选举"><a href="#利用Zookeeper实现Master选举" class="headerlink" title="利用Zookeeper实现Master选举"></a>利用Zookeeper实现Master选举</h3><p>Apache Curator是一个Zookeeper的开源客户端，它提供了Zookeeper各种应用场景（Recipe，如共享锁服务、master选举、分布式计数器等）的抽象封装，本文使用 Curator 提供的Recipe来实现Master选举。</p><p>Curator提供了两种选举方案：Leader Latch 和 Leader Election。下面分别介绍这两种选举方案。</p><h4 id="Leader-Latch"><a href="#Leader-Latch" class="headerlink" title="Leader Latch"></a>Leader Latch</h4><p>使用 Leader Latch 方案进行Master选举，系统将<strong>随机从候选者中选出一台作为 <code>leader</code>，直到调用 <code>close()</code> 释放leadship，此时再重新随机选举 <code>leader</code>，否则其他的候选者无法成为 <code>leader</code>。</strong></p><p>下面的程序将启动 N 个线程用来模拟分布式系统中的节点，每个线程将创建一个Zookeeper客户端和一个 LeaderLatch 对象用于选举；每个线程有一个名称，名称中有一个编号用于区分；每个线程的存活时间为 <code>number * 10秒</code> ，存活时间结束后将关闭 LeaderLatch 对象和客户端，表示该 ‘节点’ 宕机，如果该节点为 Master节点，这时系统将重新发起 Master选举。</p><pre><code class="java">public class LeaderLatchTest {    private static final String zkServerIps = &quot;master:2181,hadoop2:2181&quot;;    private static final String masterPath = &quot;/testZK/leader_latch&quot;;    public static void main(String[] args) {        final int clientNums = 5;  // 客户端数量，用于模拟        final CountDownLatch countDownLatch = new CountDownLatch(clientNums);        List&lt;LeaderLatch&gt; latchList = new CopyOnWriteArrayList();        List&lt;CuratorFramework&gt; clientList = new CopyOnWriteArrayList();        AtomicInteger atomicInteger = new AtomicInteger(1);        try {            for (int i = 0; i &lt; clientNums; i++) {                new Thread(new Runnable() {                    @Override                    public void run() {                        CuratorFramework client = getClient();  // 创建客户端                        clientList.add(client);                        int number = atomicInteger.getAndIncrement();                        final LeaderLatch latch = new LeaderLatch(client, masterPath, &quot;client#&quot; + number);                        System.out.println(&quot;创建客户端：&quot; + latch.getId());                        // LeaderLatch 添加监听事件                        latch.addListener(new LeaderLatchListener() {                            @Override                            public void isLeader() {                                System.out.println(latch.getId() + &quot;: 我现在被选举为Leader！我开始工作了....&quot;);                            }                            @Override                            public void notLeader() {                                System.out.println(latch.getId() + &quot;: 我遗憾地落选了，我到一旁休息去吧...&quot;);                            }                        });                        latchList.add(latch);                        try {                            latch.start();                            // 随机等待 number * 10秒，之后关闭客户端                            Thread.sleep(number * 10000);                        } catch (Exception e) {                            System.out.println(e.getMessage());                        } finally {                            System.out.println(&quot;客户端 &quot; + latch.getId() + &quot; 关闭&quot;);                            CloseableUtils.closeQuietly(latch);                            CloseableUtils.closeQuietly(client);                            countDownLatch.countDown();                        }                    }                }).start();            }            countDownLatch.await(); // 等待，只有所有线程都退出        } catch (Exception e) {            e.printStackTrace();        }    }    private static synchronized CuratorFramework getClient() {        CuratorFramework client = CuratorFrameworkFactory.builder().connectString(zkServerIps)                .sessionTimeoutMs(6000).connectionTimeoutMs(3000) //.namespace(&quot;LeaderLatchTest&quot;)                .retryPolicy(new ExponentialBackoffRetry(1000, 3)).build();        client.start();        return client;    }}</code></pre><p>控制台输出的日志</p><pre><code>创建客户端：client#1创建客户端：client#2创建客户端：client#3创建客户端：client#4创建客户端：client#5client#2: 我现在被选举为Leader！我开始工作了....客户端 client#1 关闭客户端 client#2 关闭client#4: 我现在被选举为Leader！我开始工作了....客户端 client#3 关闭客户端 client#4 关闭client#5: 我现在被选举为Leader！我开始工作了....客户端 client#5 关闭</code></pre><p>系统运行过程中查看 masterPath 可以看见客户端注册的临时节点，当客户端关闭时，临时节点也会被删除</p><p><img src="http://image.laijianfeng.org/20190122_233414.png" alt="LeaderLatch选举时的ZK节点"></p><h4 id="Leader-Election"><a href="#Leader-Election" class="headerlink" title="Leader Election"></a>Leader Election</h4><p>通过 Leader Election 选举方案进行 Master选举，需添加 LeaderSelectorListener 监听器对领导权进行控制，<strong>当节点被选为leader之后，将调用 <code>takeLeadership</code> 方法进行业务逻辑处理，处理完成会立即释放 leadship，重新进行Master选举</strong>，这样每个节点都有可能成为 leader。<code>autoRequeue()</code> 方法的调用确保此实例在释放领导权后还可能获得领导权。</p><pre><code class="java">public class LeaderSelectorTest {    private static final String zkServerIps = &quot;master:2181,hadoop2:2181&quot;;    private static final String masterPath = &quot;/testZK/leader_selector&quot;;    public static void main(String[] args) {        final int clientNums = 5;  // 客户端数量，用于模拟        final CountDownLatch countDownLatch = new CountDownLatch(clientNums);        List&lt;LeaderSelector&gt; selectorList = new CopyOnWriteArrayList();        List&lt;CuratorFramework&gt; clientList = new CopyOnWriteArrayList();        AtomicInteger atomicInteger = new AtomicInteger(1);        try {            for (int i = 0; i &lt; clientNums; i++) {                new Thread(new Runnable() {                    @Override                    public void run() {                        CuratorFramework client = getClient();  // 创建客户端                        clientList.add(client);                        int number = atomicInteger.getAndIncrement();                        final String name = &quot;client#&quot; + number;                        final LeaderSelector selector = new LeaderSelector(client, masterPath, new LeaderSelectorListener() {                            @Override                            public void takeLeadership(CuratorFramework client) throws Exception {                                System.out.println(name + &quot;: 我现在被选举为Leader！我开始工作了....&quot;);                                Thread.sleep(3000);                            }                            @Override                            public void stateChanged(CuratorFramework curatorFramework, ConnectionState connectionState) {                            }                        });                        System.out.println(&quot;创建客户端：&quot; + name);                        try {                            selector.autoRequeue();                            selector.start();                            selectorList.add(selector);                            // 随机等待 number * 10秒，之后关闭客户端                            Thread.sleep(number * 10000);                        } catch (Exception e) {                            System.out.println(e.getMessage());                        } finally {                            countDownLatch.countDown();                            System.out.println(&quot;客户端 &quot; + name + &quot; 关闭&quot;);                            CloseableUtils.closeQuietly(selector);                            if (!client.getState().equals(CuratorFrameworkState.STOPPED)) {                                CloseableUtils.closeQuietly(client);                            }                        }                    }                }).start();            }            countDownLatch.await(); // 等待，只有所有线程都退出        } catch (Exception e) {            e.printStackTrace();        }    }    private static synchronized CuratorFramework getClient() {        CuratorFramework client = CuratorFrameworkFactory.builder().connectString(zkServerIps)                .sessionTimeoutMs(6000).connectionTimeoutMs(3000) //.namespace(&quot;LeaderLatchTest&quot;)                .retryPolicy(new ExponentialBackoffRetry(1000, 3)).build();        client.start();        return client;    }}</code></pre><p>控制台输出的日志信息</p><pre><code>创建客户端：client#2创建客户端：client#1创建客户端：client#3创建客户端：client#5创建客户端：client#4client#5: 我现在被选举为Leader！我开始工作了....client#3: 我现在被选举为Leader！我开始工作了....client#2: 我现在被选举为Leader！我开始工作了....client#4: 我现在被选举为Leader！我开始工作了....客户端 client#1 关闭client#5: 我现在被选举为Leader！我开始工作了....client#3: 我现在被选举为Leader！我开始工作了....client#2: 我现在被选举为Leader！我开始工作了....客户端 client#2 关闭client#4: 我现在被选举为Leader！我开始工作了....client#5: 我现在被选举为Leader！我开始工作了....client#3: 我现在被选举为Leader！我开始工作了....client#4: 我现在被选举为Leader！我开始工作了....客户端 client#3 关闭client#5: 我现在被选举为Leader！我开始工作了....client#4: 我现在被选举为Leader！我开始工作了....client#5: 我现在被选举为Leader！我开始工作了....客户端 client#4 关闭client#5: 我现在被选举为Leader！我开始工作了....client#5: 我现在被选举为Leader！我开始工作了....client#5: 我现在被选举为Leader！我开始工作了....客户端 client#5 关闭</code></pre><p>LeaderSelectorListener类继承了ConnectionStateListener。一旦LeaderSelector启动，它会向curator客户端添加监听器。使用LeaderSelector必须时刻注意连接的变化。一旦出现连接问题如 <code>SUSPENDED</code>，curator实例必须确保它不再是leader，直至它重新收到 <code>RECONNECTED</code>。如果 <code>LOST</code> 出现，curator实例不再是 leader 并且其 <code>takeLeadership()</code> 应该直接退出。</p><p>推荐的做法是，如果发生 <code>SUSPENDED</code> 或者 <code>LOST</code> 连接问题，最好直接抛CancelLeadershipException，此时，leaderSelector实例会尝试中断并且取消正在执行 <code>takeLeadership()</code> 方法的线程。 建议扩展LeaderSelectorListenerAdapter，LeaderSelectorListenerAdapter中已经提供了推荐的处理方式 。</p><blockquote><p>参考：<br>《从Paxos到Zookeeper分布式一致性原理与实践》<br><a href="https://blog.csdn.net/wo541075754/article/details/70216046" target="_blank" rel="noopener">Zookeeper开源客户端Curator之Master/Leader选举</a></p></blockquote><p><img src="http://image.laijianfeng.org/20190116_014816.png" alt="关注_小旋锋_微信公众号"></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;Zookeeper 是一个高可用的分布式数据管理与协调框架，基于ZAB协议算法的实现，该框架能够很好的保证分布式环境中数据的一致性。Zookeeper的典型应用场景主要有：数据发布/订阅、负载均衡、命名服务、分布式协调/通知、集群管理、Master选举、分布式锁和分布式队列
      
    
    </summary>
    
      <category term="大数据" scheme="http://laijianfeng.org/categories/%E5%A4%A7%E6%95%B0%E6%8D%AE/"/>
    
    
      <category term="Zookeeper" scheme="http://laijianfeng.org/tags/Zookeeper/"/>
    
  </entry>
  
  <entry>
    <title>Zookeeper 分布式协调服务介绍</title>
    <link href="http://laijianfeng.org/2019/01/Zookeeper-%E5%88%86%E5%B8%83%E5%BC%8F%E5%8D%8F%E8%B0%83%E6%9C%8D%E5%8A%A1%E4%BB%8B%E7%BB%8D/"/>
    <id>http://laijianfeng.org/2019/01/Zookeeper-分布式协调服务介绍/</id>
    <published>2019-01-21T13:24:09.000Z</published>
    <updated>2019-01-21T13:25:33.534Z</updated>
    
    <content type="html"><![CDATA[<h4 id="分布式系统"><a href="#分布式系统" class="headerlink" title="分布式系统"></a>分布式系统</h4><p>分布式系统的简单定义：分布式系统是一个硬件或软件组件分布在不同的网络计算机上，彼此之间仅仅通过消息传递进行通信和协调的系统。</p><p>分布式系统的特征：</p><ul><li>分布性：系统中的计算机在空间上随意分布和随时变动</li><li>对等性：系统中的计算机是对等的，没有主从之分</li><li>并发性：并发性操作是非常常见的行为</li><li>缺乏全局时钟：系统中的计算机具有明显的分布性，且缺乏一个全局的时钟序列控制，所以很难比较两个事件的先后</li><li>故障总是会发生：任何在设计阶段考虑到的异常情况，一定会在系统实际运行中发生，并且还会遇到很多在设计时未考虑到的异常故障</li></ul><p>随着分布式架构的出现，越来越多的分布式应用会面临数据一致性问题。</p><h4 id="选择Zookeeper"><a href="#选择Zookeeper" class="headerlink" title="选择Zookeeper"></a>选择Zookeeper</h4><p>Zookeeper是一个典型的分布式数据一致性解决方案，分布式应用程序可以基于它实现诸如数据发布/订阅、负载均衡、命名服务、分布式协调/通知、集群管理、master选举、分布式锁和分布式队列等功能。</p><p>Zookeeper致力于提供一个高性能、高可用，具有严格的顺序访问控制能力的分布式协调服务；其主要的设计目标是简单的数据模型、可以构建集群、顺序访问、高性能。Zookeeper已经成为很多大型分布式项目譬如Hadoop、HBase、Storm、Solr等中的核心组件，用于分布式协调。</p><p>Zookeeper可以保证如下<strong>分布式一致性特性</strong>：</p><ul><li>顺序一致性：从同一个客户端发起的事务请求，最终将会严格地按照其发起顺序被应用到Zookeeper中去</li><li>原子性：所有事务请求的处理结果在整个集群中所有的机器上的应用情况是一致的</li><li>单一视图：无论客户端连接的是哪个Zookeeper服务器，其看到的服务器数据模型都是一致的</li><li>可靠性：一旦服务端成功地应用了一个事务，并完成对客户端的响应，那么该事务所引起的服务端状态变更将会被一直保留下来，除非有另一个事务又对其进行了变更</li><li>实时性：在一定的时间内，客户端最终一定能够从服务端上读取到最新的数据状态</li></ul><p><img src="http://image.laijianfeng.org/zkservice.jpg" alt="Zookeeper服务架构图"></p><h3 id="Zookeeper-基本概念"><a href="#Zookeeper-基本概念" class="headerlink" title="Zookeeper 基本概念"></a>Zookeeper 基本概念</h3><ul><li><p>集群角色</p><ul><li>Leader：客户端提供读和写服务</li><li>Follower：提供读服务，所有写服务都需要转交给Leader角色，参与选举</li><li>Observer：提供读服务，不参与选举过程，一般是为了增强Zookeeper集群的读请求并发能力</li></ul></li><li><p>会话 (session)</p><ul><li>Zk的客户端与zk的服务端之间的连接</li><li>通过心跳检测保持客户端连接的存活</li><li>接收来自服务端的watch事件通知</li><li>可以设置超时时间</li></ul></li></ul><h4 id="ZNode-节点"><a href="#ZNode-节点" class="headerlink" title="ZNode 节点"></a>ZNode 节点</h4><p>ZNode 是Zookeeper中数据的最小单元，每个ZNode上可以保存数据(byte[]类型)，同时可以挂在子节点，因此构成了一个层次化的命名空间，我们称之为树</p><p><img src="http://image.laijianfeng.org/20190121_141804.jpg" alt="Zookeeper数据模型"></p><ul><li><p>节点是有生命周期的，生命周期由<strong>节点类型</strong>决定：</p><ul><li>持久节点(PERSISTENT)：节点创建后就一直存在于Zookeeper服务器上，直到有删除操作主动将其删除</li><li>持久顺序节点(PERSISTENT_SEQUENTIAL)：基本特性与持久节点一致，额外的特性在于Zookeeper会记录其子节点创建的先后顺序</li><li>临时节点(EPHEMERAL)：声明周期与客户端的会话绑定，客户端会话失效时节点将被自动清除</li><li>临时顺序节点(EPHEMERAL_SEQUENTIAL)：基本特性与临时节点一致，但添加了顺序的特性</li></ul></li><li><p>每个节点都有<strong>状态信息</strong>，抽象为 Stat 对象，状态属性如下：</p><ul><li>czxid：节点被创建时的事务ID</li><li>mzxid：节点最后一个被更新时的事务ID</li><li>ctime：节点创建时间</li><li>mtime：节点最后一个被更新时间</li><li>version：节点版本号</li><li>cversion：子节点版本号</li><li>aversion：节点的ACL版本号</li><li>ephemeralOwner：创建该临时节点的会话的sessionID，若为持久节点则为0</li><li>dataLength：数据内容长度</li><li>numChildren：子节点数量</li></ul></li><li><p>权限控制ACL (Access Control Lists) </p><ul><li>CREATE：创建子节点的权限</li><li>READ：获取节点数据和子节点列表的权限</li><li>WRITE：更新节点数据的权限</li><li>DELETE：删除子节点的权限</li><li>ADMIN：设置节点ACL的权限</li></ul></li></ul><h4 id="watcher机制"><a href="#watcher机制" class="headerlink" title="watcher机制"></a>watcher机制</h4><p>Zookeeper 引入watcher机制来实现发布/订阅功能，能够让多个订阅者同时监听某一个节点对象，当这个节点对象状态发生变化时，会通知所有订阅者。</p><p>Zookeeper的watcher机制主要包括客户端线程、客户端WatchManager、Zookeeper服务器三个部分。其工作流程简单来说：客户端在向Zookeeper服务器注册Watcher的同时，会将Watcher对象存储在客户端的WatchManager中；当Zookeeper服务器端触发Watcher事件后，会向客户端发送通知，客户端线程从WatchManager中取出对应的Watcher对象来执行回调逻辑</p><p><img src="http://image.laijianfeng.org/20190121_174457.png" alt="Zookeeper Watcher机制概述"></p><p>可以设置的两种 Watcher</p><ul><li><p>NodeCache</p><ul><li>监听数据节点的内容变更</li><li>监听节点的创建，即如果指定的节点不存在，则节点创建后，会触发这个监听</li></ul></li><li><p>PathChildrenCache</p><ul><li>监听指定节点的子节点变化情况</li><li>包括新增子节点、子节点数据变更和子节点删除</li></ul></li></ul><h3 id="客户端命令"><a href="#客户端命令" class="headerlink" title="客户端命令"></a>客户端命令</h3><p>Zookeeper的安装可参考官方文档</p><pre><code class="shell"># 启动客户端，默认为 localhost:2181bin/zkCli.sh     # 启动客户端，指定连接的Zookeeper地址bin/zkCli.sh -server ip:port # create 创建一个节点，路径为 /test，内容为 some test data create /test &quot;some test data&quot;# ls 列出指定节点下的所有子节点 ls /# get 获取指定节点的数据内容和属性get /test# set 更新指定节点的数据内容set /test &quot;new test data&quot;# delete 删除节点delete /test# rmr 删除非空节点rmr /test# stat 输出节点的状态信息stat /test</code></pre><h4 id="四字命令"><a href="#四字命令" class="headerlink" title="四字命令"></a>四字命令</h4><p>四字命令可以查看Zookeeper服务器的一些信息，可以通过 telnet 和 nc 等方式执行四字命令，以执行 conf 命令为例</p><pre><code># telnet 方式 执行Zookeeper的 conf 命令telnet localhost 2181conf# nc 方式 执行Zookeeper的 conf 命令echo conf | nc localhost 2181</code></pre><p><strong>四字命令介绍</strong>：</p><ul><li>conf 命令用于输出Zookeeper服务器运行时的基本配置信息</li><li>cons 命令用于输出这台服务器上所有客户端连接的详细信息</li><li>crst 命令用于重置所有客户端的连接统计信息</li><li>dump 命令用于输出当前集群的所有会话信息</li><li>envi 命令用于输出Zookeeper所在服务器的运行时信息</li><li>ruok 命令用于输出当前Zookeeper服务器是否正在运行</li><li>stat 命令用于获取Zookeeper服务器的运行状态信息</li><li>srvr 命令与stat命令功能一致，但仅输出服务器自身的信息</li><li>srst 命令用于重置所有服务器的统计信息</li><li>wchs 命令用于输出当前服务器上管理的 watcher 的概要信息</li><li>wchc 命令用于输出当前服务器上管理的 watcher 的详细信息</li><li>wchp 命令与wchc功能非常相似，但输出信息以节点路径为单位进行归组</li><li>mntr 命令用于输出比stat命令更为详细的服务器统计信息</li></ul><h3 id="Curator-客户端代码实例"><a href="#Curator-客户端代码实例" class="headerlink" title="Curator 客户端代码实例"></a>Curator 客户端代码实例</h3><p>Curator 是 Apache 基金会的顶级项目之一，解决了很多Zookeeper客户端非常底层的细节开发工作，包括会话超时重连、反复注册Watcher、NodeExistsException异常等，提供了一套易用性和可读性更强的Fluent风格的客户端API框架，除此之外，curator还提供了Zookeeper各种应用场景（Recipe，如共享锁服务、master选举、分布式计数器等）的抽象封装。</p><p>Zookeeper 的核心提交者 Patrick Hunt 对 Curator 的高度评价：</p><blockquote><p>Guava is to Java what Curator is to Zookeeper</p></blockquote><h4 id="示例-增删查改"><a href="#示例-增删查改" class="headerlink" title="示例 - 增删查改"></a>示例 - 增删查改</h4><pre><code class="java">import org.apache.curator.RetryPolicy;import org.apache.curator.framework.CuratorFramework;import org.apache.curator.framework.CuratorFrameworkFactory;import org.apache.curator.framework.imps.CuratorFrameworkState;import org.apache.curator.retry.ExponentialBackoffRetry;import org.apache.zookeeper.CreateMode;import org.apache.zookeeper.ZooDefs;import org.apache.zookeeper.data.Stat;public class CuratorCrud {    // 集群模式则是多个ip    private static final String zkServerIps = &quot;master:2181,hadoop2:2181&quot;;    public static void main(String[] args) throws Exception {        // 创建节点        String nodePath = &quot;/testZK&quot;; // 节点路径        byte[] data = &quot;this is a test data&quot;.getBytes(); // 节点数据        byte[] newData = &quot;new test data&quot;.getBytes(); // 节点数据        // 设置重连策略ExponentialBackoffRetry, baseSleepTimeMs：初始sleep的时间,maxRetries：最大重试次数,maxSleepMs：最大重试时间        RetryPolicy retryPolicy = new ExponentialBackoffRetry(10000, 5);        //（推荐）curator链接zookeeper的策略:RetryNTimes n：重试的次数 sleepMsBetweenRetries：每次重试间隔的时间        // RetryPolicy retryPolicy = new RetryNTimes(3, 5000);        // （不推荐） curator链接zookeeper的策略:RetryOneTime sleepMsBetweenRetry:每次重试间隔的时间,这个策略只会重试一次        // RetryPolicy retryPolicy2 = new RetryOneTime(3000);        // 永远重试，不推荐使用        // RetryPolicy retryPolicy3 = new RetryForever(retryIntervalMs)        // curator链接zookeeper的策略:RetryUntilElapsed maxElapsedTimeMs:最大重试时间 sleepMsBetweenRetries:每次重试间隔 重试时间超过maxElapsedTimeMs后，就不再重试        // RetryPolicy retryPolicy4 = new RetryUntilElapsed(2000, 3000);        // Curator客户端        CuratorFramework client = null;        // 实例化Curator客户端，Curator的编程风格可以让我们使用方法链的形式完成客户端的实例化        client = CuratorFrameworkFactory.builder()  // 使用工厂类来建造客户端的实例对象                .connectString(zkServerIps) // 放入zookeeper服务器ip                .sessionTimeoutMs(10000).retryPolicy(retryPolicy)  // 设定会话时间以及重连策略                // .namespace(&quot;testApp&quot;)    // 隔离的命名空间                .build(); // 建立连接通道        // 启动Curator客户端        client.start();        boolean isZkCuratorStarted = client.getState().equals(CuratorFrameworkState.STARTED);        System.out.println(&quot;当前客户端的状态：&quot; + (isZkCuratorStarted ? &quot;连接中...&quot; : &quot;已关闭...&quot;));        try {            // 检查节点是否存在            Stat s = client.checkExists().forPath(nodePath);            if (s == null) {                System.out.println(&quot;节点不存在，创建节点&quot;);                // 创建节点                String result = client.create().creatingParentsIfNeeded()    // 创建父节点，也就是会递归创建                        .withMode(CreateMode.PERSISTENT) // 节点类型                        .withACL(ZooDefs.Ids.OPEN_ACL_UNSAFE) // 节点的ACL权限                        .forPath(nodePath, data);                System.out.println(result + &quot;节点，创建成功...&quot;);            } else {                System.out.println(&quot;节点已存在，&quot; + s);            }            getData(client, nodePath);  // 输出节点信息            // 更新指定节点的数据            int version = s == null ? 0 : s.getVersion();  // 版本不一致时的异常：KeeperErrorCode = BadVersion            Stat resultStat = client.setData().withVersion(version)   // 指定数据版本                    .forPath(nodePath, newData);    // 需要修改的节点路径以及新数据            System.out.println(&quot;更新节点数据成功&quot;);            getData(client, nodePath);  // 输出节点信息            // 删除节点            client.delete().guaranteed()    // 如果删除失败，那么在后端还是会继续删除，直到成功                    .deletingChildrenIfNeeded() // 子节点也一并删除，也就是会递归删除                    .withVersion(resultStat.getVersion())                    .forPath(nodePath);            System.out.println(&quot;删除节点：&quot; + nodePath);            Thread.sleep(1000);        } finally {            // 关闭客户端            if (!client.getState().equals(CuratorFrameworkState.STOPPED)) {                System.out.println(&quot;关闭客户端.....&quot;);                client.close();            }            isZkCuratorStarted = client.getState().equals(CuratorFrameworkState.STARTED);            System.out.println(&quot;当前客户端的状态：&quot; + (isZkCuratorStarted ? &quot;连接中...&quot; : &quot;已关闭...&quot;));        }    }    /**     * 读取节点的数据     */    private static byte[] getData(CuratorFramework client, String nodePath) throws Exception {        Stat stat = new Stat();        byte[] nodeData = client.getData().storingStatIn(stat).forPath(nodePath);        System.out.println(&quot;节点 &quot; + nodePath + &quot; 的数据为：&quot; + new String(nodeData));        System.out.println(&quot;该节点的数据版本号为：&quot; + stat.getVersion() + &quot;\n&quot;);        return nodeData;    }}// 输出当前客户端的状态：连接中...节点不存在，创建节点/testZK节点，创建成功...节点 /testZK 的数据为：this is a test data该节点的数据版本号为：0更新节点数据成功节点 /testZK 的数据为：new test data该节点的数据版本号为：1删除节点：/testZK关闭客户端.....当前客户端的状态：已关闭...</code></pre><h4 id="示例-异步接口"><a href="#示例-异步接口" class="headerlink" title="示例 - 异步接口"></a>示例 - 异步接口</h4><pre><code class="java">public class CuratorBackGround {    private static final String zkServerIps = &quot;master:2181,hadoop2:2181&quot;;    public static void main(String[] args) throws Exception {        CountDownLatch samphore = new CountDownLatch(2);        ExecutorService tp = Executors.newFixedThreadPool(2);   // 线程池        String nodePath = &quot;/testZK&quot;;        byte[] data = &quot;this is a test data&quot;.getBytes();        RetryPolicy retryPolicy = new ExponentialBackoffRetry(10000, 5);        CuratorFramework client = CuratorFrameworkFactory.builder().connectString(zkServerIps)                .sessionTimeoutMs(10000).retryPolicy(retryPolicy).build();        client.start();        // 异步创建节点，传入 ExecutorService，这样比较复杂的就会放到线程池中执行        client.create().creatingParentsIfNeeded().withMode(CreateMode.EPHEMERAL)                .inBackground(new BackgroundCallback() {                    @Override                    public void processResult(CuratorFramework curatorFramework, CuratorEvent curatorEvent) throws Exception {                        System.out.println(&quot;event[code: &quot; + curatorEvent.getResultCode() + &quot;, type: &quot; + curatorEvent.getType() + &quot;]&quot;);                        System.out.println(&quot;当前线程：&quot; + Thread.currentThread().getName());                        samphore.countDown();                    }                }, tp).forPath(nodePath, data); // 此处传入 ExecutorService tp        // 异步创建节点        client.create().creatingParentsIfNeeded().withMode(CreateMode.EPHEMERAL)                .inBackground(new BackgroundCallback() {                    @Override                    public void processResult(CuratorFramework curatorFramework, CuratorEvent curatorEvent) throws Exception {                        System.out.println(&quot;event[code: &quot; + curatorEvent.getResultCode() + &quot;, type: &quot; + curatorEvent.getType() + &quot;]&quot;);                        System.out.println(&quot;当前线程：&quot; + Thread.currentThread().getName());                        samphore.countDown();                    }                }).forPath(nodePath, data); // 此处没有传入 ExecutorService tp        samphore.await();        tp.shutdown();    }}// 输出event[code: -110, type: CREATE]当前线程：main-EventThreadevent[code: 0, type: CREATE]当前线程：pool-1-thread-1</code></pre><h4 id="示例-watcher-事件监听-NodeCache"><a href="#示例-watcher-事件监听-NodeCache" class="headerlink" title="示例 - watcher 事件监听 - NodeCache"></a>示例 - watcher 事件监听 - NodeCache</h4><pre><code class="java">public class CuratorWatcher {    private static final String zkServerIps = &quot;master:2181,hadoop2:2181&quot;;    public static void main(String[] args) throws Exception {        final String nodePath = &quot;/testZK&quot;;        RetryPolicy retryPolicy = new ExponentialBackoffRetry(10000, 5);        CuratorFramework client = CuratorFrameworkFactory.builder().connectString(zkServerIps)                .sessionTimeoutMs(10000).retryPolicy(retryPolicy).build();        try {            client.start();            client.create().creatingParentsIfNeeded().withMode(CreateMode.PERSISTENT).forPath(nodePath, &quot;this is a test data&quot;.getBytes());            final NodeCache cacheNode = new NodeCache(client, nodePath, false);            cacheNode.start(true);  // true 表示启动时立即从Zookeeper上获取节点            cacheNode.getListenable().addListener(new NodeCacheListener() {                @Override                public void nodeChanged() throws Exception {                    System.out.println(&quot;节点数据更新，新的内容是： &quot; + new String(cacheNode.getCurrentData().getData()));                }            });            for (int i = 0; i &lt; 5; i++) {                client.setData().forPath(nodePath, (&quot;new test data &quot; + i).getBytes());                Thread.sleep(1000);            }            Thread.sleep(10000); // 等待100秒，手动在 zkCli 客户端操作节点，触发事件        } finally {            client.delete().deletingChildrenIfNeeded().forPath(nodePath);            client.close();            System.out.println(&quot;客户端关闭......&quot;);        }    }}</code></pre><h4 id="示例-watcher-事件监听-PathChildrenCache"><a href="#示例-watcher-事件监听-PathChildrenCache" class="headerlink" title="示例 - watcher 事件监听 - PathChildrenCache"></a>示例 - watcher 事件监听 - PathChildrenCache</h4><pre><code>public class CuratorPCWatcher {    private static final String zkServerIps = &quot;master:2181,hadoop2:2181&quot;;    public static void main(String[] args) throws Exception {        final String nodePath = &quot;/testZK&quot;;        RetryPolicy retryPolicy = new ExponentialBackoffRetry(10000, 5);        CuratorFramework client = CuratorFrameworkFactory.builder().connectString(zkServerIps)                .sessionTimeoutMs(10000).retryPolicy(retryPolicy).build();        client.start();        try {            // 为子节点添加watcher，PathChildrenCache: 监听数据节点的增删改，可以设置触发的事件            final PathChildrenCache childrenCache = new PathChildrenCache(client, nodePath, true);            /**             * StartMode: 初始化方式             *  - POST_INITIALIZED_EVENT：异步初始化，初始化之后会触发事件             *  - NORMAL：异步初始化             *  - BUILD_INITIAL_CACHE：同步初始化             */            childrenCache.start(PathChildrenCache.StartMode.BUILD_INITIAL_CACHE);            // 列出子节点数据列表，需要使用BUILD_INITIAL_CACHE同步初始化模式才能获得，异步是获取不到的            List&lt;ChildData&gt; childDataList = childrenCache.getCurrentData();            System.out.println(&quot;当前节点的子节点详细数据列表：&quot;);            for (ChildData childData : childDataList) {                System.out.println(&quot;\t* 子节点路径：&quot; + new String(childData.getPath()) + &quot;，该节点的数据为：&quot; + new String(childData.getData()));            }            // 添加事件监听器            childrenCache.getListenable().addListener(new PathChildrenCacheListener() {                @Override                public void childEvent(CuratorFramework curatorFramework, PathChildrenCacheEvent event) throws Exception {                    // 通过判断event type的方式来实现不同事件的触发                    if (event.getType().equals(PathChildrenCacheEvent.Type.INITIALIZED)) {  // 子节点初始化时触发                        System.out.println(&quot;子节点初始化成功&quot;);                    } else if (event.getType().equals(PathChildrenCacheEvent.Type.CHILD_ADDED)) {  // 添加子节点时触发                        System.out.print(&quot;子节点：&quot; + event.getData().getPath() + &quot; 添加成功，&quot;);                        System.out.println(&quot;该子节点的数据为：&quot; + new String(event.getData().getData()));                    } else if (event.getType().equals(PathChildrenCacheEvent.Type.CHILD_REMOVED)) {  // 删除子节点时触发                        System.out.println(&quot;子节点：&quot; + event.getData().getPath() + &quot; 删除成功&quot;);                    } else if (event.getType().equals(PathChildrenCacheEvent.Type.CHILD_UPDATED)) {  // 修改子节点数据时触发                        System.out.print(&quot;子节点：&quot; + event.getData().getPath() + &quot; 数据更新成功，&quot;);                        System.out.println(&quot;子节点：&quot; + event.getData().getPath() + &quot; 新的数据为：&quot; + new String(event.getData().getData()));                    }                }            });            Thread.sleep(100000); // sleep 100秒，在 zkCli.sh 操作子节点，注意查看控制台的输出        } finally {            client.close();        }    }}// 输出当前节点的子节点详细数据列表：    * 子节点路径：/testZK/node1，该节点的数据为：hello world子节点：/testZK/node2 添加成功，该子节点的数据为：hello node2子节点：/testZK/node2 数据更新成功，子节点：/testZK/node2 新的数据为：hello zookeeper子节点：/testZK/node2 删除成功</code></pre><h3 id="Zookeeper的典型应用场景"><a href="#Zookeeper的典型应用场景" class="headerlink" title="Zookeeper的典型应用场景"></a>Zookeeper的典型应用场景</h3><p>下一篇文章将使用 Curator 客户端来实现 Zookeeper 的典型应用场景的示例，这里简单概括一下Zookeeper的典型应用场景：</p><ul><li>数据发布/订阅，即所谓的配置中心</li><li>负载均衡</li><li>命名服务</li><li>分布式协调/通知</li><li>集群管理</li><li>master 选举</li><li>分布式锁</li><li>分布式队列</li></ul><blockquote><p>参考：<br>《从Paxos到Zookeeper分布式一致性原理与实践》</p></blockquote><p><img src="http://image.laijianfeng.org/20190116_014816.png" alt="关注_小旋锋_微信公众号"></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h4 id=&quot;分布式系统&quot;&gt;&lt;a href=&quot;#分布式系统&quot; class=&quot;headerlink&quot; title=&quot;分布式系统&quot;&gt;&lt;/a&gt;分布式系统&lt;/h4&gt;&lt;p&gt;分布式系统的简单定义：分布式系统是一个硬件或软件组件分布在不同的网络计算机上，彼此之间仅仅通过消息传递进行通信和协调
      
    
    </summary>
    
      <category term="大数据" scheme="http://laijianfeng.org/categories/%E5%A4%A7%E6%95%B0%E6%8D%AE/"/>
    
    
      <category term="Zookeeper" scheme="http://laijianfeng.org/tags/Zookeeper/"/>
    
  </entry>
  
  <entry>
    <title>分布式系统 | CAP 定理图解</title>
    <link href="http://laijianfeng.org/2019/01/%E5%88%86%E5%B8%83%E5%BC%8F%E7%B3%BB%E7%BB%9F-CAP-%E5%AE%9A%E7%90%86%E5%9B%BE%E8%A7%A3/"/>
    <id>http://laijianfeng.org/2019/01/分布式系统-CAP-定理图解/</id>
    <published>2019-01-15T17:18:59.000Z</published>
    <updated>2019-01-15T17:20:56.449Z</updated>
    
    <content type="html"><![CDATA[<p>CAP定理是分布系统中的一个基本定理，它指出任何分布系统最多可以具有以下三个属性中的两个。</p><ul><li>一致性 (Consistency) </li><li>可用性 (Availability)  </li><li>分区容错性 (Partition tolerance)   </li></ul><p>本文将以图解的形式简明地对 <a href="https://www.comp.nus.edu.sg/~gilbert/pubs/BrewersConjecture-SigAct.pdf" target="_blank" rel="noopener">Gilbert and Lynch’s specification and proof of the CAP Theorem </a>(CAP定理的规范和证明) 进行概括总结</p><h3 id="什么是-CAP-定理？"><a href="#什么是-CAP-定理？" class="headerlink" title="什么是 CAP 定理？"></a>什么是 CAP 定理？</h3><p>CAP定理指出分布式系统不可能同时具有一致性、可用性和分区容错性。听起来很简单，但一致性、可用性、分区容错性到底是什么意思呢？确切地来说分布式系统又意味着什么呢？</p><p>在本文中，我们将介绍一个简单的分布式系统，并对分布式系统的可用性、一致性和分区容错性进行诠释。有关分布式系统和这三个属性的正式描述，请参阅 Gilbert 和 Lynch 的论文。</p><h4 id="分布式系统"><a href="#分布式系统" class="headerlink" title="分布式系统"></a>分布式系统</h4><p>让我们来考虑一个非常简单的分布式系统，它由两台服务器G1和G2组成；这两台服务器都存储了同一个变量<code>v</code>，<code>v</code>的初始值为<code>v0</code>；G1和G2互相之间能够通信，并且也能与外部的客户端通信；我们的分布式系统的架构图如下图所示：</p><p><img src="http://image.laijianfeng.org/cap1.svg" alt="一个简单的分布式系统"></p><p>客户端可以向任何服务器发出读写请求。服务器当接收到请求之后，将根据请求执行一些计算，然后把请求结果返回给客户端。譬如，下图是一个写请求的例子：</p><p><img src="http://image.laijianfeng.org/20190115_182005.png" alt="客户端发起写请求"></p><p>接着，下图是一个读请求的例子</p><p><img src="http://image.laijianfeng.org/20190115_182219.png" alt="客户端发起读请求"></p><p>现在我们的分布式系统建立起来了，下面我们就来回顾一下分布式系统的可用性、一致性以及分区容错性的含义。</p><h4 id="一致性-Consistency"><a href="#一致性-Consistency" class="headerlink" title="一致性 (Consistency)"></a>一致性 (Consistency)</h4><p>Gilbert 和 Lynch 在论文中的描述是：</p><blockquote><p>any read operation that begins after a write operation completes must return that value, or the result of a later write operation</p></blockquote><p>也就是说，在一个一致性的系统中，客户端向任何服务器发起一个写请求，将一个值写入服务器并得到响应，那么之后向任何服务器发起读请求，都必须读取到这个值（或者更加新的值）。</p><p>下图是一个不一致的分布式系统的例子:</p><p><img src="http://image.laijianfeng.org/20190115_223824.png" alt="不一致的分布式系统"></p><p>客户端向G1发起写请求，将v的值更新为v1且得到G1的确认响应；当向G2发起读<code>v</code>的请求时，读取到的却是旧的值<code>v0</code>，与期待的<code>v1</code>不一致。</p><p>下图一致的分布式系统的例子:</p><p><img src="http://image.laijianfeng.org/20190115_225536.png" alt="一致的分布式系统"></p><p>在这个系统中，G1在将确认响应返回给客户端之前，会先把<code>v</code>的新值复制给G2，这样，当客户端从G2读取<code>v</code>的值时就能读取到最新的值<code>v1</code></p><h4 id="可用性-Availability"><a href="#可用性-Availability" class="headerlink" title="可用性 (Availability)"></a>可用性 (Availability)</h4><p>Gilbert 和 Lynch 在论文中的描述是：</p><blockquote><p>every request received by a non-failing node in the system must result in a response</p></blockquote><p>也就是说，在一个可用的分布式系统中，客户端向其中一个服务器发起一个请求且该服务器未崩溃，那么这个服务器最终必须响应客户端的请求。</p><h4 id="分区容错性-Partition-tolerance"><a href="#分区容错性-Partition-tolerance" class="headerlink" title="分区容错性 (Partition tolerance)"></a>分区容错性 (Partition tolerance)</h4><p>Gilbert 和 Lynch 在论文中的描述是：</p><blockquote><p>the network will be allowed to lose arbitrarily many messages sent from one node to another</p></blockquote><p>也就是说服务器G1和G2之间互相发送的任意消息都可能丢失。如果所有的消息都丢失了，那么我们的系统就变成了下图这样：</p><p><img src="http://image.laijianfeng.org/20190115_225537.svg" alt="网络分区"></p><p>为了满足分区容错性，我们的系统在任意的网络分区情况下都必须正常的工作。</p><h3 id="CAP定理的证明"><a href="#CAP定理的证明" class="headerlink" title="CAP定理的证明"></a>CAP定理的证明</h3><p>现在我们已经了解了一致性、可用性和分区容错性的概念，我们可以来证明一个系统不能同时满足这三种属性了。</p><p>假设存在一个同时满足这三个属性的系统，我们第一件要做的就是让系统发生网络分区，就像下图的情况一样：</p><p><img src="http://image.laijianfeng.org/20190115_225537.svg" alt="网络分区"></p><p>客户端向G1发起写请求，将<code>v</code>的值更新为<code>v1</code>，因为系统是可用的，所以G1必须响应客户端的请求，但是由于网络是分区的，G1无法将其数据复制到G2</p><p><img src="http://image.laijianfeng.org/20190115_230826.png" alt="由于网络分区导致不一致"></p><p>接着，客户端向G2发起读<code>v</code>的请求，再一次因为系统是可用的，所以G2必须响应客户端的请求，又由于网络是分区的，G2无法从G1更新<code>v</code>的值，所以G2返回给客户端的是旧的值<code>v0</code></p><p><img src="http://image.laijianfeng.org/20190115_231317.png" alt="由于网络分区导致不一致"></p><p>客户端发起写请求将G1上<code>v</code>的值修改为<code>v1</code>之后，从G2上读取到的值仍然是<code>v0</code>，这违背了一致性。</p><h3 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h3><p>我们假设了存在一个满足一致性、可用性、分区容错性的分布式系统，但是我们展示了在一些情况下，系统表现出不一致的行为，因此证明不存在这样一个系统</p><p>对于一个分布式系统来说，P 是一个基本要求，CAP 三者中，只能根据系统要求在 C 和 A 两者之间做权衡，并且要想尽办法提升 P</p><blockquote><p>参考：<br>英文原文：<a href="https://www.iteblog.com/redirect.php?url=aHR0cHM6Ly9td2hpdHRha2VyLmdpdGh1Yi5pby9ibG9nL2FuX2lsbHVzdHJhdGVkX3Byb29mX29mX3RoZV9jYXBfdGhlb3JlbS8=&amp;article=true" target="_blank" rel="noopener">An Illustrated Proof of the CAP Theorem</a><br><a href="https://www.iteblog.com/archives/2390.html" target="_blank" rel="noopener">一篇文章搞清楚什么是分布式系统 CAP 定理</a></p></blockquote><h3 id="后记"><a href="#后记" class="headerlink" title="后记"></a>后记</h3><p>欢迎评论、转发、分享</p><p>更多内容可访问我的个人博客：<a href="http://laijianfeng.org">http://laijianfeng.org</a></p><p>关注【小旋锋】微信公众号，及时接收博文推送</p><p><img src="http://image.laijianfeng.org/20180913_001328.png" alt="关注_小旋锋_微信公众号"></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;CAP定理是分布系统中的一个基本定理，它指出任何分布系统最多可以具有以下三个属性中的两个。&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;一致性 (Consistency) &lt;/li&gt;
&lt;li&gt;可用性 (Availability)  &lt;/li&gt;
&lt;li&gt;分区容错性 (Partition tol
      
    
    </summary>
    
      <category term="大数据" scheme="http://laijianfeng.org/categories/%E5%A4%A7%E6%95%B0%E6%8D%AE/"/>
    
    
      <category term="分布式系统理论" scheme="http://laijianfeng.org/tags/%E5%88%86%E5%B8%83%E5%BC%8F%E7%B3%BB%E7%BB%9F%E7%90%86%E8%AE%BA/"/>
    
  </entry>
  
  <entry>
    <title>设计模式 | 解释器模式及典型应用</title>
    <link href="http://laijianfeng.org/2019/01/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F-%E8%A7%A3%E9%87%8A%E5%99%A8%E6%A8%A1%E5%BC%8F%E5%8F%8A%E5%85%B8%E5%9E%8B%E5%BA%94%E7%94%A8/"/>
    <id>http://laijianfeng.org/2019/01/设计模式-解释器模式及典型应用/</id>
    <published>2019-01-13T08:35:37.000Z</published>
    <updated>2019-01-13T08:37:32.492Z</updated>
    
    <content type="html"><![CDATA[<p>本文主要介绍解释器模式，在日常开发中，解释器模式的使用频率比较低</p><h3 id="解释器模式"><a href="#解释器模式" class="headerlink" title="解释器模式"></a>解释器模式</h3><p><strong>解释器模式(Interpreter Pattern)</strong>：定义一个语言的文法，并且建立一个解释器来解释该语言中的句子，这里的 “语言” 是指使用规定格式和语法的代码。解释器模式是一种类行为型模式。</p><h4 id="角色"><a href="#角色" class="headerlink" title="角色"></a>角色</h4><p><strong>AbstractExpression（抽象表达式）</strong>：在抽象表达式中声明了抽象的解释操作，它是所有终结符表达式和非终结符表达式的公共父类。</p><p><strong>TerminalExpression（终结符表达式）</strong>：终结符表达式是抽象表达式的子类，它实现了与文法中的终结符相关联的解释操作，在句子中的每一个终结符都是该类的一个实例。通常在一个解释器模式中只有少数几个终结符表达式类，它们的实例可以通过非终结符表达式组成较为复杂的句子。</p><p><strong>NonterminalExpression（非终结符表达式）</strong>：非终结符表达式也是抽象表达式的子类，它实现了文法中非终结符的解释操作，由于在非终结符表达式中可以包含终结符表达式，也可以继续包含非终结符表达式，因此其解释操作一般通过递归的方式来完成。</p><p><strong>Context（环境类）</strong>：环境类又称为上下文类，它用于存储解释器之外的一些全局信息，通常它临时存储了需要解释的语句。</p><p><img src="http://image.laijianfeng.org/20190113_110631.jpg" alt="解释器模式结构图"></p><h3 id="示例"><a href="#示例" class="headerlink" title="示例"></a>示例</h3><p>使用解释器模式实现一个简单的后缀表达式解释器，仅支持对整数的加法和乘法即可</p><p>定义抽象表达式接口</p><pre><code class="java">public interface Interpreter {    int interpret();}</code></pre><p>非终结符表达式，对整数进行解释</p><pre><code class="java">public class NumberInterpreter implements Interpreter {    private int number;    public NumberInterpreter(int number) {        this.number = number;    }    public NumberInterpreter(String number) {        this.number = Integer.parseInt(number);    }    @Override    public int interpret() {        return this.number;    }}</code></pre><p>终结符表达式，对加法和乘法进行解释</p><pre><code class="java">// 加法public class AddInterpreter implements Interpreter {    private Interpreter firstExpression, secondExpression;    public AddInterpreter(Interpreter firstExpression, Interpreter secondExpression) {        this.firstExpression = firstExpression;        this.secondExpression = secondExpression;    }    @Override    public int interpret() {            return this.firstExpression.interpret() + this.secondExpression.interpret();    }    @Override    public String toString() {        return &quot;+&quot;;    }}// 乘法public class MultiInterpreter implements Interpreter {    private Interpreter firstExpression, secondExpression;    public MultiInterpreter(Interpreter firstExpression, Interpreter secondExpression) {        this.firstExpression = firstExpression;        this.secondExpression = secondExpression;    }    @Override    public int interpret() {        return this.firstExpression.interpret() * this.secondExpression.interpret();    }    @Override    public String toString() {        return &quot;*&quot;;    }}</code></pre><p>工具类</p><pre><code class="java">public class OperatorUtil {    public static boolean isOperator(String symbol) {        return (symbol.equals(&quot;+&quot;) || symbol.equals(&quot;*&quot;));    }    public static Interpreter getExpressionObject(Interpreter firstExpression, Interpreter secondExpression, String symbol) {        if (&quot;+&quot;.equals(symbol)) {  // 加法            return new AddInterpreter(firstExpression, secondExpression);        } else if (&quot;*&quot;.equals(symbol)) {    // 乘法            return new MultiInterpreter(firstExpression, secondExpression);        } else {            throw new RuntimeException(&quot;不支持的操作符：&quot; + symbol);        }    }}</code></pre><p>测试，对后缀表达式 <code>6 100 11 + *</code> 进行求值</p><pre><code class="java">public class Test {    public static void main(String[] args) {        String inputStr = &quot;6 100 11 + *&quot;;        MyExpressionParser expressionParser = new MyExpressionParser();        int result = expressionParser.parse(inputStr);        System.out.println(&quot;解释器计算结果: &quot; + result);    }}</code></pre><p>运行结果</p><pre><code>入栈: 6入栈: 100入栈: 11出栈: 11 和 100应用运算符: +阶段结果入栈: 111出栈: 111 和 6应用运算符: *阶段结果入栈: 666解释器计算结果: 666</code></pre><p><img src="http://image.laijianfeng.org/20190113_110632.png" alt="示例.类图"></p><h3 id="解释器模式总结"><a href="#解释器模式总结" class="headerlink" title="解释器模式总结"></a>解释器模式总结</h3><p>解释器模式为自定义语言的设计和实现提供了一种解决方案，它用于定义一组文法规则并通过这组文法规则来解释语言中的句子。虽然解释器模式的使用频率不是特别高，但是它在<strong>正则表达式</strong>、<strong>XML文档解释</strong>等领域还是得到了广泛使用。</p><h4 id="主要优点"><a href="#主要优点" class="headerlink" title="主要优点"></a>主要优点</h4><ul><li><strong>易于改变和扩展文法</strong>。由于在解释器模式中使用类来表示语言的文法规则，因此可以通过继承等机制来改变或扩展文法。</li><li>每一条文法规则都可以表示为一个类，因此可以<strong>方便地实现一个简单的语言</strong>。</li><li><strong>实现文法较为容易</strong>。在抽象语法树中每一个表达式节点类的实现方式都是相似的，这些类的代码编写都不会特别复杂，还可以通过一些工具自动生成节点类代码。</li><li><strong>增加新的解释表达式较为方便</strong>。如果用户需要增加新的解释表达式只需要对应增加一个新的终结符表达式或非终结符表达式类，原有表达式类代码无须修改，符合 “开闭原则”。</li></ul><h4 id="主要缺点"><a href="#主要缺点" class="headerlink" title="主要缺点"></a>主要缺点</h4><ul><li><strong>对于复杂文法难以维护</strong>。在解释器模式中，每一条规则至少需要定义一个类，因此如果一个语言包含太多文法规则，类的个数将会急剧增加，导致系统难以管理和维护，此时可以考虑使用语法分析程序等方式来取代解释器模式。</li><li><strong>执行效率较低</strong>。由于在解释器模式中使用了大量的循环和递归调用，因此在解释较为复杂的句子时其速度很慢，而且代码的调试过程也比较麻烦。</li></ul><h4 id="适用场景"><a href="#适用场景" class="headerlink" title="适用场景"></a>适用场景</h4><ul><li>可以将一个需要解释执行的语言中的句子表示为一个抽象语法树。</li><li>一些重复出现的问题可以用一种简单的语言来进行表达。</li><li>一个语言的文法较为简单。</li><li>对执行效率要求不高。</li></ul><h3 id="解释器模式的典型应用"><a href="#解释器模式的典型应用" class="headerlink" title="解释器模式的典型应用"></a>解释器模式的典型应用</h3><h4 id="Spring-EL表达式中的解释器模式"><a href="#Spring-EL表达式中的解释器模式" class="headerlink" title="Spring EL表达式中的解释器模式"></a>Spring EL表达式中的解释器模式</h4><p>Spring EL表达式相关的类在 <code>org.springframework.expression</code> 包下，类图如下</p><p><img src="http://image.laijianfeng.org/20190113_110633.png" alt="org.springframework.expression 包的类图"></p><p>涉及的类非常多，这里仅对此时我们最关心的几个类做介绍：</p><p><strong>SpelExpression</strong>，表示一个 EL 表达式，表达式在内部通过一个 AST抽象语法树 表示，EL表达式求值是通过 <code>this.ast.getValue(expressionState);</code> 求值</p><pre><code class="java">public class SpelExpression implements Expression {    private final String expression;    private final SpelNodeImpl ast;    private final SpelParserConfiguration configuration;    @Override    @Nullable    public Object getValue() throws EvaluationException {        if (this.compiledAst != null) {            try {                EvaluationContext context = getEvaluationContext();                return this.compiledAst.getValue(context.getRootObject().getValue(), context);            }            catch (Throwable ex) {                // If running in mixed mode, revert to interpreted                if (this.configuration.getCompilerMode() == SpelCompilerMode.MIXED) {                    this.interpretedCount = 0;                    this.compiledAst = null;                }                else {                    // Running in SpelCompilerMode.immediate mode - propagate exception to caller                    throw new SpelEvaluationException(ex, SpelMessage.EXCEPTION_RUNNING_COMPILED_EXPRESSION);                }            }        }        ExpressionState expressionState = new ExpressionState(getEvaluationContext(), this.configuration);        Object result = this.ast.getValue(expressionState);        checkCompile(expressionState);        return result;    }    //...省略...}</code></pre><p><strong>SpelNodeImpl</strong>：已解析的Spring表达式所代表的ast语法树的节点的通用父类型，语法树的节点在解释器模式中扮演的角色是终结符和非终结符。从类图中可以看到，SpelNodeImpl 的子类主要有 Literal，Operator，Indexer等，其中 Literal 是各种类型的值的父类，Operator 则是各种操作的父类</p><pre><code class="java">public abstract class SpelNodeImpl implements SpelNode, Opcodes {    protected int pos;  // start = top 16bits, end = bottom 16bits    protected SpelNodeImpl[] children = SpelNodeImpl.NO_CHILDREN;    @Nullable    private SpelNodeImpl parent;    public final Object getValue(ExpressionState expressionState) throws EvaluationException {        return getValueInternal(expressionState).getValue();    }    // 抽象方法，由子类实现，获取对象的值    public abstract TypedValue getValueInternal(ExpressionState expressionState) throws EvaluationException;    //...省略...}</code></pre><p><strong>IntLiteral</strong> 表示整型文字的表达式语言的ast结点</p><pre><code class="java">public class IntLiteral extends Literal {    private final TypedValue value;    public IntLiteral(String payload, int pos, int value) {        super(payload, pos);        this.value = new TypedValue(value); //         this.exitTypeDescriptor = &quot;I&quot;;    }    @Override    public TypedValue getLiteralValue() {        return this.value;    }    // ...}</code></pre><p><strong>OpPlus</strong> 表示加法的ast结点，在 getValueInternal 方法中对操作符两边进行相加操作</p><pre><code class="java">public class OpPlus extends Operator {    public OpPlus(int pos, SpelNodeImpl... operands) {        super(&quot;+&quot;, pos, operands);        Assert.notEmpty(operands, &quot;Operands must not be empty&quot;);    }    @Override    public TypedValue getValueInternal(ExpressionState state) throws EvaluationException {        SpelNodeImpl leftOp = getLeftOperand();        if (this.children.length &lt; 2) {  // if only one operand, then this is unary plus            Object operandOne = leftOp.getValueInternal(state).getValue();            if (operandOne instanceof Number) {                if (operandOne instanceof Double) {                    this.exitTypeDescriptor = &quot;D&quot;;                }                else if (operandOne instanceof Float) {                    this.exitTypeDescriptor = &quot;F&quot;;                }                else if (operandOne instanceof Long) {                    this.exitTypeDescriptor = &quot;J&quot;;                }                else if (operandOne instanceof Integer) {                    this.exitTypeDescriptor = &quot;I&quot;;                }                return new TypedValue(operandOne);            }            return state.operate(Operation.ADD, operandOne, null);        }        // 递归调用leftOp的 getValueInternal(state) ，获取操作符左边的值        TypedValue operandOneValue = leftOp.getValueInternal(state);        Object leftOperand = operandOneValue.getValue();        // 递归调用children[1]的 getValueInternal(state) ，获取操作符右边的值        TypedValue operandTwoValue = getRightOperand().getValueInternal(state);        Object rightOperand = operandTwoValue.getValue();        // 如果操作符左右都是数值类型，则将它们相加        if (leftOperand instanceof Number &amp;&amp; rightOperand instanceof Number) {            Number leftNumber = (Number) leftOperand;            Number rightNumber = (Number) rightOperand;            if (leftNumber instanceof BigDecimal || rightNumber instanceof BigDecimal) {                BigDecimal leftBigDecimal = NumberUtils.convertNumberToTargetClass(leftNumber, BigDecimal.class);                BigDecimal rightBigDecimal = NumberUtils.convertNumberToTargetClass(rightNumber, BigDecimal.class);                return new TypedValue(leftBigDecimal.add(rightBigDecimal));            }            else if (leftNumber instanceof Double || rightNumber instanceof Double) {                this.exitTypeDescriptor = &quot;D&quot;;                  return new TypedValue(leftNumber.doubleValue() + rightNumber.doubleValue());            }            //...省略 Float-&gt;F, BigInteger-&gt;add, Long-&gt;J,Integer-&gt;I            else {                // Unknown Number subtypes -&gt; best guess is double addition                return new TypedValue(leftNumber.doubleValue() + rightNumber.doubleValue());            }        }        //...        return state.operate(Operation.ADD, leftOperand, rightOperand);    }    //...}</code></pre><p>通过一个示例，调试查看程序中间经历的步骤</p><pre><code class="java">public class SpringELTest {    public static void main(String[] args) {        // 1. 构建解析器        org.springframework.expression.ExpressionParser parser = new SpelExpressionParser();        // 2. 解析表达式        Expression expression = parser.parseExpression(&quot;100 * 2 + 400 * 1 + 66&quot;);        // 3. 获取结果        int result = (Integer) expression.getValue();        System.out.println(result); // 结果：666    }}</code></pre><p>EL表达式解析后得到表达式 <code>(((100 * 2) + (400 * 1)) + 66)</code><br><img src="http://image.laijianfeng.org/20190113_161156.png" alt="EL表达式解析后得到的表达式"></p><p>如果用图形把其这棵AST抽象语法树简单地画出来，大概是这样</p><p><img src="http://image.laijianfeng.org/20190113_161157.jpg" alt="示例.AST抽象语法树"></p><p>调用 <code>expression.getValue()</code> 求值，此时的 ast 是语法树的头结点，也就是 <code>+</code> OpPlus，所以通过 <code>this.ast.getValue(expressionState)</code> 进入了 OpPlus 的 getValue 方法（是父类中的方法），接着进入 getValueInternal 方法，然后递归计算操作符左边的值，递归计算操作符右边的值，最后相加返回</p><p><img src="http://image.laijianfeng.org/20190113_163005.png" alt="示例.spring EL调试"></p><blockquote><p>参考：<br><a href="gof.quanke.name">刘伟.Java设计模式</a><br>Java设计模式精讲</p></blockquote><p><img src="http://image.laijianfeng.org/20180913_001328.png" alt="关注_小旋锋_微信公众号"></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;本文主要介绍解释器模式，在日常开发中，解释器模式的使用频率比较低&lt;/p&gt;
&lt;h3 id=&quot;解释器模式&quot;&gt;&lt;a href=&quot;#解释器模式&quot; class=&quot;headerlink&quot; title=&quot;解释器模式&quot;&gt;&lt;/a&gt;解释器模式&lt;/h3&gt;&lt;p&gt;&lt;strong&gt;解释器模式(Inte
      
    
    </summary>
    
      <category term="后端" scheme="http://laijianfeng.org/categories/%E5%90%8E%E7%AB%AF/"/>
    
    
      <category term="设计模式" scheme="http://laijianfeng.org/tags/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/"/>
    
  </entry>
  
  <entry>
    <title>ArrayList 源码分析</title>
    <link href="http://laijianfeng.org/2019/01/ArrayList-%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90/"/>
    <id>http://laijianfeng.org/2019/01/ArrayList-源码分析/</id>
    <published>2019-01-09T12:21:09.000Z</published>
    <updated>2019-01-09T12:22:21.858Z</updated>
    
    <content type="html"><![CDATA[<blockquote><p>以下源码分析使用的 Java 版本为 1.8 </p></blockquote><h4 id="1-概览"><a href="#1-概览" class="headerlink" title="1. 概览"></a>1. 概览</h4><p>ArrayList 是基于数组实现的，继承 AbstractList， 实现了 List、RandomAccess、Cloneable、Serializable 接口，支持随机访问。</p><pre><code>java.util public class ArrayList&lt;E&gt; extends AbstractList&lt;E&gt;     implements List&lt;E&gt;, RandomAccess, Cloneable, java.io.Serializable</code></pre><h4 id="2-Java-Doc-关键点："><a href="#2-Java-Doc-关键点：" class="headerlink" title="2. Java Doc 关键点："></a>2. Java Doc 关键点：</h4><ul><li>实现List接口的动态数组，容量大小为 capacity，默认的容量大小 10，会自动扩容</li><li>可包含空元素 null</li><li>size, isEmpty, get, set, iterator, and listIterator 等操作的复杂度为 O(1)，The add operation runs in amortized constant time, that is, adding n elements requires O(n) time，其它操作为线性时间</li><li>非线程安全，多线程环境下必须在外部增加同步限制，或者使用包装对象 <code>List list = Collections.synchronizedList(new ArrayList(...));</code></li><li>快速失败：在使用迭代器时，调用迭代器的添加、修改、删除方法，将抛出 <code>ConcurrentModificationException</code> 异常，但是快速失败行为不是硬保证的，只是尽最大努力</li></ul><h4 id="3-成员属性"><a href="#3-成员属性" class="headerlink" title="3. 成员属性"></a>3. 成员属性</h4><p>当添加第一个元素时，<code>elementData == DEFAULTCAPACITY_EMPTY_ELEMENTDATA</code> 的任何空ArrayList都将扩展为默认的capacity</p><pre><code class="java">private static final int DEFAULT_CAPACITY = 10; // 默认容量大小private static final Object[] EMPTY_ELEMENTDATA = {}; // ArrayList空实例共享的一个空数组private static final Object[] DEFAULTCAPACITY_EMPTY_ELEMENTDATA = {}; // ArrayList空实例共享的一个空数组，用于默认大小的空实例。与 EMPTY_ELEMENTDATA 分开，这样就可以了解当添加第一个元素时需要创建多大的空间transient Object[] elementData; // 真正存储ArrayList中的元素的数组private int size;   // 存储ArrayList的大小，注意不是elementData的长度private static final int MAX_ARRAY_SIZE = Integer.MAX_VALUE - 8; // 数组的最大长度protected transient int modCount = 0; //AbstractList类的，表示 elementData在结构上被修改的次数,每次add或者remove它的值都会加1</code></pre><h4 id="4-构造方法"><a href="#4-构造方法" class="headerlink" title="4. 构造方法"></a>4. 构造方法</h4><pre><code class="java">// 无参构造方法，默认初始容量10public ArrayList() {    this.elementData = DEFAULTCAPACITY_EMPTY_ELEMENTDATA;}// 提供初始容量的构造方法public ArrayList(int initialCapacity) {    if (initialCapacity &gt; 0) {        this.elementData = new Object[initialCapacity];    } else if (initialCapacity == 0) {        this.elementData = EMPTY_ELEMENTDATA;    } else {        throw new IllegalArgumentException(&quot;Illegal Capacity: &quot;+                                           initialCapacity);    }}// 通过一个容器来初始化public ArrayList(Collection&lt;? extends E&gt; c) {    elementData = c.toArray();     if ((size = elementData.length) != 0) { // c.toArray 返回的可能不是  Object[]        if (elementData.getClass() != Object[].class)            elementData = Arrays.copyOf(elementData, size, Object[].class);    } else {        this.elementData = EMPTY_ELEMENTDATA; // replace with empty array.    }}</code></pre><h4 id="5-添加元素与扩容"><a href="#5-添加元素与扩容" class="headerlink" title="5. 添加元素与扩容"></a>5. 添加元素与扩容</h4><p><strong>添加元素</strong>时使用 ensureCapacityInternal() 方法来保证容量足够，<code>size + 1</code> 为最少需要的空间大小，如果elementData的长度不够时，需要使用 grow() 方法进行扩容</p><pre><code class="java">// 添加一个元素public boolean add(E e) {    ensureCapacityInternal(size + 1);  // Increments modCount!!    elementData[size++] = e;    return true;}// 计算最少需要的容量private static int calculateCapacity(Object[] elementData, int minCapacity) {    if (elementData == DEFAULTCAPACITY_EMPTY_ELEMENTDATA) {         // 默认的空实例第一次添加元素时，使用默认的容量大小与minCapacity的最大值        return Math.max(DEFAULT_CAPACITY, minCapacity);    }    return minCapacity;}private void ensureCapacityInternal(int minCapacity) {    ensureExplicitCapacity(calculateCapacity(elementData, minCapacity));}private void ensureExplicitCapacity(int minCapacity) {    modCount++;     if (minCapacity - elementData.length &gt; 0) // 需要的容量大于elementData的长度        grow(minCapacity);  // 进行扩容}</code></pre><p>扩容：当新容量小于等于 <code>MAX_ARRAY_SIZE</code> 时，新容量的大小为 <code>oldCapacity + (oldCapacity &gt;&gt; 1)</code> 与 <code>minCapacity</code> 之间的较大值 ，也就是旧容量的 1.5 倍与 <code>minCapacity</code> 之间的较大值</p><pre><code>private void grow(int minCapacity) {    int oldCapacity = elementData.length; // 原本的容量    int newCapacity = oldCapacity + (oldCapacity &gt;&gt; 1); // 新的容量    if (newCapacity - minCapacity &lt; 0)        newCapacity = minCapacity;    if (newCapacity - MAX_ARRAY_SIZE &gt; 0)        newCapacity = hugeCapacity(minCapacity);    elementData = Arrays.copyOf(elementData, newCapacity);}private static int hugeCapacity(int minCapacity) {    if (minCapacity &lt; 0) // overflow        throw new OutOfMemoryError();    return (minCapacity &gt; MAX_ARRAY_SIZE) ? Integer.MAX_VALUE : MAX_ARRAY_SIZE;}</code></pre><p>最后调用 <code>Arrays.copyOf</code> 复制原数组，将 elementData 赋值为得到的新数组。由于数组复制代价较高，所以建议在创建 ArrayList 对象时就指定大概的容量大小，减少扩容操作的次数</p><pre><code>public class Arrays {    public static &lt;T&gt; T[] copyOf(T[] original, int newLength) {        return (T[]) copyOf(original, newLength, original.getClass());    }    public static &lt;T,U&gt; T[] copyOf(U[] original, int newLength, Class&lt;? extends T[]&gt; newType) {        @SuppressWarnings(&quot;unchecked&quot;)        T[] copy = ((Object)newType == (Object)Object[].class)            ? (T[]) new Object[newLength] : (T[]) Array.newInstance(newType.getComponentType(), newLength);        System.arraycopy(original, 0, copy, 0, Math.min(original.length, newLength));        return copy;    }    //...}</code></pre><p>通过 addAll <strong>添加一个集合中所有元素</strong>时的扩容：至少需要的容量为两个集合的长度之和，同样是通过 ensureCapacityInternal() 来保证容量是足够的，然后调用 <code>System.arraycopy</code> 将要添加的集合中的元素复制到原集合已有元素的后面</p><pre><code class="java">public boolean addAll(Collection&lt;? extends E&gt; c) {    Object[] a = c.toArray();    int numNew = a.length;    ensureCapacityInternal(size + numNew);  // Increments modCount    System.arraycopy(a, 0, elementData, size, numNew); // 复制元素到原数组尾部    size += numNew;    return numNew != 0;}</code></pre><h4 id="6-删除元素"><a href="#6-删除元素" class="headerlink" title="6. 删除元素"></a>6. 删除元素</h4><p><strong>删除指定下标的元素</strong>时，如果下标没有越界，则取出下标对应的值，然后将数组中该下标后面的元素都往前挪1位，需要挪的元素数量是 <code>size - index - 1</code>，时间复杂度为 O(n)，所以删除元素的代价挺高</p><pre><code class="java">public E remove(int index) {    rangeCheck(index); // 检查下标是否在数组的长度范围内    modCount++;    E oldValue = elementData(index); // 下标为index的值    int numMoved = size - index - 1; // 需要移动的元素数量    if (numMoved &gt; 0)        System.arraycopy(elementData, index+1, elementData, index, numMoved);    elementData[--size] = null; // clear to let GC do its work    return oldValue;}private void rangeCheck(int index) {    if (index &gt;= size)          throw new IndexOutOfBoundsException(outOfBoundsMsg(index));}</code></pre><p><strong>删除在指定集合中的所有元素</strong> removeAll，<strong>删除不在指定集合中的所有元素</strong> retainAll</p><p>这两者都是通过 <code>batchRemove</code> 来批量删除</p><pre><code>// 删除在指定集合中的所有元素public boolean removeAll(Collection&lt;?&gt; c) {    Objects.requireNonNull(c);  // c 不能为null    return batchRemove(c, false);}// 删除不在指定集合中的所有元素，也就是只保留指定集合中的元素，其它的都删除掉public boolean retainAll(Collection&lt;?&gt; c) {    Objects.requireNonNull(c);    return batchRemove(c, true);}// 批量删除private boolean batchRemove(Collection&lt;?&gt; c, boolean complement) {    final Object[] elementData = this.elementData;    int r = 0, w = 0;   // r为当前下标，w为当前需要保留的元素的数量（或者说是下一个需保留元素的下标）    boolean modified = false;    try {        for (; r &lt; size; r++)            if (c.contains(elementData[r]) == complement)   // 判断元素 elementData[r] 是否需要删除                elementData[w++] = elementData[r];    } finally {        // r != size 的情况可能是 c.contains() 抛出了异常，将 r 之后的元素复制到 w 之后        if (r != size) {             System.arraycopy(elementData, r, elementData, w, size - r);            w += size - r;        }        if (w != size) {            // w 之后的元素设置为 null 以让 GC 回收            for (int i = w; i &lt; size; i++)                 elementData[i] = null;              modCount += size - w;            size = w;            modified = true;        }    }    return modified;}</code></pre><p><strong>删除第一个值为指定值的元素</strong> <code>remove(Object o)</code>，参数 o 可以为 null</p><p><code>fastRemove(int index)</code> 与 <code>remove(int index)</code> 几乎一样，只不过不返回被删除的元素</p><pre><code>public boolean remove(Object o) {    if (o == null) {        for (int index = 0; index &lt; size; index++)            if (elementData[index] == null) {                fastRemove(index);                return true;            }    } else {        for (int index = 0; index &lt; size; index++)            if (o.equals(elementData[index])) {                fastRemove(index);                return true;            }    }    return false;}private void fastRemove(int index) {    modCount++;    int numMoved = size - index - 1;    if (numMoved &gt; 0)        System.arraycopy(elementData, index+1, elementData, index,                         numMoved);    elementData[--size] = null; // clear to let GC do its work}</code></pre><h4 id="7-遍历"><a href="#7-遍历" class="headerlink" title="7. 遍历"></a>7. 遍历</h4><p>ArrayList 支持三种方式：</p><ul><li>for循环下标遍历</li><li>迭代器(Iterator和ListIterator)</li><li>foreach 语句</li></ul><p><strong>迭代器 Iterator 和 ListIterator 的主要区别：</strong>：</p><blockquote><p>ArrayList 的迭代器 Iterator 和 ListIterator 在《<a href="https://mp.weixin.qq.com/s?__biz=MzI1NDU0MTE1NA==&amp;mid=2247483752&amp;idx=1&amp;sn=7880679f18b5727ea64cd05c06817c35&amp;chksm=e9c2ed65deb56473da688784c4562995c24daf4b13425d0d4d080208728b86525f6600127925&amp;scene=0#rd" target="_blank" rel="noopener">设计模式 | 迭代器模式及典型应用</a>》这篇文章中有过详细介绍，这里只做一个小结</p></blockquote><ul><li>ListIterator 有 add() 方法，可以向List中添加对象，而 Iterator 不能</li><li>ListIterator 和 Iterator 都有 hasNext() 和 next() 方法，可以实现顺序向后遍历，但是 ListIterator 有 hasPrevious() 和 previous() 方法，可以实现逆向（顺序向前）遍历。Iterator 就不可以。</li><li>ListIterator 可以定位当前的索引位置，nextIndex() 和 previousIndex() 可以实现。Iterator 没有此功能。</li><li>都可实现删除对象，但是 ListIterator 可以实现对象的修改，set() 方法可以实现。Iierator 仅能遍历，不能修改</li></ul><p><strong>foreach 循环：</strong></p><p>foreach 循环涉及到一个 Consumer 接口，接收一个泛型的参数T，当调用 accept 方法时，Stream流中将对 accept 的参数做一系列的操作</p><pre><code class="java">public void forEach(Consumer&lt;? super E&gt; action) {    Objects.requireNonNull(action);    final int expectedModCount = modCount;  // 记录当前的 modCount    @SuppressWarnings(&quot;unchecked&quot;)    final E[] elementData = (E[]) this.elementData;    final int size = this.size;    for (int i=0; modCount == expectedModCount &amp;&amp; i &lt; size; i++) {        action.accept(elementData[i]);    }    if (modCount != expectedModCount) {        throw new ConcurrentModificationException();    }}</code></pre><h4 id="8-序列化"><a href="#8-序列化" class="headerlink" title="8. 序列化"></a>8. 序列化</h4><p>ArrayList 有两个属性被 <code>transient 关键字</code> 修饰，<strong>transient 关键字</strong> 的作用：让某些被修饰的成员属性变量不被序列化   </p><pre><code class="java">transient Object[] elementData;protected transient int modCount = 0;</code></pre><p><strong>为什么最为重要的数组元素要用 transient 修饰呢？</strong> </p><p>跟Java的序列化机制有关，这里列出Java序列化机制的几个要点：</p><ul><li>需要序列化的类必须实现java.io.Serializable接口，否则会抛出NotSerializableException异常</li><li>若没有显示地声明一个serialVersionUID变量，Java序列化机制会根据编译时的class自动生成一个serialVersionUID作为序列化版本比较（验证一致性），如果检测到反序列化后的类的serialVersionUID和对象二进制流的serialVersionUID不同，则会抛出异常</li><li>Java的序列化会将一个类包含的引用中所有的成员变量保存下来（深度复制），所以里面的引用类型必须也要实现java.io.Serializable接口</li><li>当某个字段被声明为transient后，默认序列化机制就会忽略该字段，反序列化后自动获得0或者null值</li><li>静态成员不参与序列化</li><li>每个类可以实现readObject、writeObject方法实现自己的序列化策略，即使是transient修饰的成员变量也可以手动调用ObjectOutputStream的writeInt等方法将这个成员变量序列化。</li><li>任何一个readObject方法，不管是显式的还是默认的，它都会返回一个新建的实例，这个新建的实例不同于该类初始化时创建的实例</li><li>每个类可以实现private Object readResolve()方法，在调用readObject方法之后，如果存在readResolve方法则自动调用该方法，readResolve将对readObject的结果进行处理，而最终readResolve的处理结果将作为readObject的结果返回。readResolve的目的是保护性恢复对象，其最重要的应用就是保护性恢复单例、枚举类型的对象</li></ul><p>所以问题的答案是：ArrayList 不想用Java序列化机制的默认处理来序列化 elementData 数组，而是通过 readObject、writeObject 方法自定义序列化和反序列化策略。</p><p>问题又来了，<strong>为什么不用Java序列化机制的默认处理来序列化 elementData 数组呢</strong>？</p><p>答案是因为效率问题，如果用默认处理来序列化的话，如果 elementData 的长度有100，但是实际只用了50，其实剩余的50是可以不用序列化的，这样可以提高序列化和反序列化的效率，节省空间。</p><p>现在来看 ArrayList 中自定义的序列化和反序列化策略</p><pre><code class="java">private static final long serialVersionUID = 8683452581122892189L;private void writeObject(java.io.ObjectOutputStream s) throws java.io.IOException{    int expectedModCount = modCount;    s.defaultWriteObject(); // 默认的序列化策略，序列化其它的字段    s.writeInt(size);   // 实际用的长度，而不是容量    for (int i=0; i&lt;size; i++) {  // 只序列化数组的前 size 个对象        s.writeObject(elementData[i]);    }    if (modCount != expectedModCount) {        throw new ConcurrentModificationException();    }}private void readObject(java.io.ObjectInputStream s) throws java.io.IOException, ClassNotFoundException {    elementData = EMPTY_ELEMENTDATA;    // Read in size, and any hidden stuff    s.defaultReadObject();    s.readInt(); // ignored    if (size &gt; 0) {        int capacity = calculateCapacity(elementData, size);        SharedSecrets.getJavaOISAccess().checkArray(s, Object[].class, capacity);        ensureCapacityInternal(size);        Object[] a = elementData;        for (int i=0; i&lt;size; i++) {            a[i] = s.readObject();        }    }}</code></pre><h4 id="9-快速失败-fail-fast"><a href="#9-快速失败-fail-fast" class="headerlink" title="9. 快速失败(fail-fast)"></a>9. 快速失败(fail-fast)</h4><p>modCount 用来记录 ArrayList 结构发生变化的次数，如果一个动作前后 modCount 的值不相等，说明 ArrayList 被其它线程修改了</p><p>如果在创建迭代器之后的任何时候以任何方式修改了列表（增加、删除、修改），除了通过迭代器自己的remove 或 add方法，迭代器将抛出 <code>ConcurrentModificationException</code> 异常</p><p>需要注意的是：这里异常的抛出条件是检测到 <code>modCount != expectedmodCount</code>，如果并发场景下一个线程修改了modCount值时另一个线程又 “及时地” 修改了expectedmodCount值，则异常不会抛出。所以不能依赖于这个异常来检测程序的正确性。</p><pre><code>private void writeObject(java.io.ObjectOutputStream s) throws java.io.IOException{    int expectedModCount = modCount;    // 记录下当前的 modCount    // 一些操作之后....    if (modCount != expectedModCount) { // 比较现在与之前的 modCount，不相等表示在中间过程中被修改了        throw new ConcurrentModificationException();    }}private void writeObject(java.io.ObjectOutputStream s) throws java.io.IOException{    int expectedModCount = modCount;    // 一些操作之后....    if (modCount != expectedModCount) {        throw new ConcurrentModificationException();    }}public void forEach(Consumer&lt;? super E&gt; action) {    final int expectedModCount = modCount;    // 一些操作之后....    if (modCount != expectedModCount) {        throw new ConcurrentModificationException();    }}public boolean removeIf(Predicate&lt;? super E&gt; filter) {    final int expectedModCount = modCount;    // 一些操作之后....    if (modCount != expectedModCount) {        throw new ConcurrentModificationException();    }}public void replaceAll(UnaryOperator&lt;E&gt; operator) {    final int expectedModCount = modCount;    // 一些操作之后....    if (modCount != expectedModCount) {        throw new ConcurrentModificationException();    }    modCount++; // 修改了要加一}public void sort(Comparator&lt;? super E&gt; c) {    final int expectedModCount = modCount;    // 一些操作之后....    if (modCount != expectedModCount) {        throw new ConcurrentModificationException();    }    modCount++;}// 内部迭代器private class Itr implements Iterator&lt;E&gt; {    public void forEachRemaining(Consumer&lt;? super E&gt; consumer) {        checkForComodification();    }    final void checkForComodification() {        if (modCount != expectedModCount)            throw new ConcurrentModificationException();    }}</code></pre><h3 id="后记"><a href="#后记" class="headerlink" title="后记"></a>后记</h3><p>欢迎评论、转发、分享</p><p>更多内容可访问我的个人博客：<a href="http://laijianfeng.org">http://laijianfeng.org</a></p><p>关注【小旋锋】微信公众号，及时接收博文推送</p><p><img src="http://image.laijianfeng.org/20180913_001328.png" alt="关注_小旋锋_微信公众号"></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;blockquote&gt;
&lt;p&gt;以下源码分析使用的 Java 版本为 1.8 &lt;/p&gt;
&lt;/blockquote&gt;
&lt;h4 id=&quot;1-概览&quot;&gt;&lt;a href=&quot;#1-概览&quot; class=&quot;headerlink&quot; title=&quot;1. 概览&quot;&gt;&lt;/a&gt;1. 概览&lt;/h4&gt;&lt;p&gt;Ar
      
    
    </summary>
    
      <category term="后端" scheme="http://laijianfeng.org/categories/%E5%90%8E%E7%AB%AF/"/>
    
    
      <category term="Java编程" scheme="http://laijianfeng.org/tags/Java%E7%BC%96%E7%A8%8B/"/>
    
  </entry>
  
  <entry>
    <title>Elasticsearch源码分析 | 单节点的启动和关闭</title>
    <link href="http://laijianfeng.org/2019/01/Elasticsearch%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90-%E5%8D%95%E8%8A%82%E7%82%B9%E7%9A%84%E5%90%AF%E5%8A%A8%E5%92%8C%E5%85%B3%E9%97%AD/"/>
    <id>http://laijianfeng.org/2019/01/Elasticsearch源码分析-单节点的启动和关闭/</id>
    <published>2019-01-07T17:58:56.000Z</published>
    <updated>2019-01-08T13:10:43.142Z</updated>
    
    <content type="html"><![CDATA[<p>本文主要简要介绍Elasticsearch单节点的启动和关闭流程。Elasticsearch版本：6.3.2   </p><h4 id="相关文章"><a href="#相关文章" class="headerlink" title="相关文章"></a>相关文章</h4><p>1、<a href="https://mp.weixin.qq.com/s?__biz=MzI1NDU0MTE1NA==&amp;mid=2247483683&amp;idx=1&amp;sn=0d77085a0234b2c5b7c679e62200e6f5&amp;chksm=e9c2ed2edeb56438010b5f5d487bcb7f0529c85d50ac7c858e1a8e3a9279c15007341170c5ac&amp;mpshare=1&amp;scene=1&amp;srcid=0107YiaAuX3EDzO9XLEBCDHq#rd" target="_blank" rel="noopener">Google Guice 快速入门</a><br>2、<a href="https://mp.weixin.qq.com/s?__biz=MzI1NDU0MTE1NA==&amp;mid=2247483691&amp;idx=1&amp;sn=3c7175d318bce6728c2105d27ae6bafe&amp;chksm=e9c2ed26deb56430289edabd15cef1a0cf777c5dfe4f4ad5013655e9d3607958e0fe16ac5436&amp;mpshare=1&amp;scene=1&amp;srcid=01079MoANk2UViY4CftnPRVo#rd" target="_blank" rel="noopener">Elasticsearch 中的 Guice</a><br>3、<a href="https://mp.weixin.qq.com/s?__biz=MzI1NDU0MTE1NA==&amp;mid=2247483676&amp;idx=1&amp;sn=1d88a883ce21d7dcacd073a8fa85dbfc&amp;chksm=e9c2ed11deb56407879ba0b22a4ef96916f8a9e7931e1efb99df57991966a3dc475eb3e23101&amp;mpshare=1&amp;scene=1&amp;srcid=0107L5Z1RW5tpECUU13Ymxwg#rd" target="_blank" rel="noopener">教你编译调试Elasticsearch 6.3.2源码</a><br>4、<a href="https://mp.weixin.qq.com/s?__biz=MzI1NDU0MTE1NA==&amp;mid=2247483695&amp;idx=1&amp;sn=c434b83ca67cfd1e2e0cbf416b3ee28e&amp;chksm=e9c2ed22deb56434978446cd05c8b8235783a3f28ce940b601206fb76a8025e1a69a33e1c64a&amp;mpshare=1&amp;scene=1&amp;srcid=0107LgY2cJ3bNjMZFLX58mVz#rd" target="_blank" rel="noopener">Elasticsearch 6.3.2 启动过程</a></p><h4 id="创建节点"><a href="#创建节点" class="headerlink" title="创建节点"></a>创建节点</h4><p>Elasticsearch的启动引导类为 Bootstrap 类，在创建节点 Node 对象之前，Bootstrap 会解析配置和进行一些安全检查等</p><p><img src="http://image.laijianfeng.org/20190107_223512.png" alt="创建节点对象"></p><p>environment 对象主要是解析出来的配置信息</p><p><img src="http://image.laijianfeng.org/20190107_223749.png" alt="environment 对象"></p><p>创建节点过程的主要工作是创建各个模块对象和服务对象，<strong>完成 Guice 依赖绑定</strong>，获取并初始化探测器。</p><p>ModulesBuilder 用于统一管理 Module</p><pre><code>ModulesBuilder modules = new ModulesBuilder();ClusterModule clusterModule = new ClusterModule(settings, clusterService, clusterPlugins, clusterInfoService);modules.add(clusterModule);     // 将模块加入管理//....// 实例绑定modules.add(b -&gt; {        b.bind(Node.class).toInstance(this);        b.bind(NodeService.class).toInstance(nodeService);        b.bind(NamedXContentRegistry.class).toInstance(xContentRegistry);        b.bind(PluginsService.class).toInstance(pluginsService);        b.bind(Client.class).toInstance(client);        b.bind(NodeClient.class).toInstance(client);        b.bind(Environment.class).toInstance(this.environment);        b.bind(ThreadPool.class).toInstance(threadPool);        b.bind(NodeEnvironment.class).toInstance(nodeEnvironment);        // ....    });injector = modules.createInjector();    // 生成注入器</code></pre><p>主要的服务类简介如下：</p><table><thead><tr><th>服务</th><th>简介</th></tr></thead><tbody><tr><td>ResourceWatcherService</td><td>通用资源监视服务</td></tr><tr><td>HttpServerTransport</td><td>HTTP传输服务，提供Rest接口服务</td></tr><tr><td>SnapshotsService</td><td>快照服务</td></tr><tr><td>SnapshotShardsService</td><td>负责启动和停止shard级快照</td></tr><tr><td>IndicesClusterStateService</td><td>根据收到的集群状态信息，处理相关索引</td></tr><tr><td>Discovery</td><td>集群拓扑管理</td></tr><tr><td>RoutingService</td><td>处理路由（节点之间迁移shard）</td></tr><tr><td>ClusterService</td><td>集群管理服务，主要处理集群任务，发布集群状态</td></tr><tr><td>NodeConnectionsService</td><td>节点连接管理服务</td></tr><tr><td>MonitorService</td><td>提供进程级、系统级、文件系统和JVM的监控服务</td></tr><tr><td>GatewayService</td><td>负责集群元数据持久化与恢复</td></tr><tr><td>SearchService</td><td>处理搜索请求</td></tr><tr><td>TransportService</td><td>底层传输服务</td></tr><tr><td>plugins</td><td>插件</td></tr><tr><td>IndicesService</td><td>负责创建、删除索引等索引操作</td></tr></tbody></table><h4 id="启动节点"><a href="#启动节点" class="headerlink" title="启动节点"></a>启动节点</h4><p>启动节点的主要工作是启动各个模块的服务对象，服务对象从注入器 <code>injector</code> 中取出来，然后调用它们的 <code>start</code> 方法，服务对象的 <code>start</code> 方法的工作基本是初始化内部数据、创建线程池、启动线程池等，详细的流程留到后面的文章中再介绍。</p><pre><code class="java">injector.getInstance(MappingUpdatedAction.class).setClient(client);injector.getInstance(IndicesService.class).start();injector.getInstance(IndicesClusterStateService.class).start();</code></pre><p>在启动 Discovery 和 ClusterService 之前，还会调用 validateNodeBeforeAcceptingRequests 方法来检测环境外部，外部环境主要是JVM、操作系统相关参数，将一些影响性能的配置标记为错误以引起用户的重视。</p><h4 id="环境检测"><a href="#环境检测" class="headerlink" title="环境检测"></a>环境检测</h4><p>节点的环境检测代码都封装在 BootstrapChecks 类中，BootstrapChecks 类通过责任链模式对十几个检测项进行检测，关于责任链模式可以翻看这篇文章《<a href="https://mp.weixin.qq.com/s?__biz=MzI1NDU0MTE1NA==&amp;mid=2247483778&amp;idx=1&amp;sn=aa816aec86370806ab9ee4b366760bcb&amp;scene=19#wechat_redirect" target="_blank" rel="noopener">设计模式之责任链模式及典型应用</a>》</p><p>这里的责任链模式中的抽象处理者由 BootstrapCheck 接口扮演，它定义了一个处理方法 <code>check</code>，而每个检查项则是具体处理者，都有对应的一个静态类，具体的检查则在 <code>check</code> 接口中完成</p><p>以第一个检查项 “堆大小检查” 为例，从 JvmInfo 类中获取配置的堆的初始值和最大值进行比较，不相等则格式化提示信息，最后返回检查结果</p><pre><code class="java">    static class HeapSizeCheck implements BootstrapCheck {        @Override        public BootstrapCheckResult check(BootstrapContext context) {            final long initialHeapSize = getInitialHeapSize();            final long maxHeapSize = getMaxHeapSize();            if (initialHeapSize != 0 &amp;&amp; maxHeapSize != 0 &amp;&amp; initialHeapSize != maxHeapSize) {                final String message = String.format(Locale.ROOT,                        &quot;initial heap size [%d] not equal to maximum heap size [%d]; &quot; +                                &quot;this can cause resize pauses and prevents mlockall from locking the entire heap&quot;,                        getInitialHeapSize(), getMaxHeapSize());                return BootstrapCheckResult.failure(message);            } else {                return BootstrapCheckResult.success();            }        }        long getInitialHeapSize() {             return JvmInfo.jvmInfo().getConfiguredInitialHeapSize();        }        long getMaxHeapSize() {            return JvmInfo.jvmInfo().getConfiguredMaxHeapSize();        }    }</code></pre><p>把所有检查项的对象添加到一个 List 链中</p><pre><code>    static List&lt;BootstrapCheck&gt; checks() {        final List&lt;BootstrapCheck&gt; checks = new ArrayList&lt;&gt;();        checks.add(new HeapSizeCheck());        final FileDescriptorCheck fileDescriptorCheck            = Constants.MAC_OS_X ? new OsXFileDescriptorCheck() : new FileDescriptorCheck();        checks.add(fileDescriptorCheck);        checks.add(new MlockallCheck());        if (Constants.LINUX) {            checks.add(new MaxNumberOfThreadsCheck());        }        if (Constants.LINUX || Constants.MAC_OS_X) {            checks.add(new MaxSizeVirtualMemoryCheck());        }        if (Constants.LINUX || Constants.MAC_OS_X) {            checks.add(new MaxFileSizeCheck());        }        if (Constants.LINUX) {            checks.add(new MaxMapCountCheck());        }        checks.add(new ClientJvmCheck());        checks.add(new UseSerialGCCheck());        checks.add(new SystemCallFilterCheck());        checks.add(new OnErrorCheck());        checks.add(new OnOutOfMemoryErrorCheck());        checks.add(new EarlyAccessCheck());        checks.add(new G1GCCheck());        checks.add(new AllPermissionCheck());        return Collections.unmodifiableList(checks);    }</code></pre><p>for 循环分别调用 check 方法进行检查，有些检查项检查不通过是可以忽略的，如果有不能忽略的错误则会抛出异常</p><pre><code>for (final BootstrapCheck check : checks) {    final BootstrapCheck.BootstrapCheckResult result = check.check(context);    if (result.isFailure()) {        if (!(enforceLimits || enforceBootstrapChecks) &amp;&amp; !check.alwaysEnforce()) {            ignoredErrors.add(result.getMessage());        } else {            errors.add(result.getMessage());        }    }}</code></pre><p><strong>那么检查项有哪些呢？</strong></p><ul><li><code>堆大小检查</code>：如果开启了<code>bootstrap.memory_lock</code>，则JVM在启动时将锁定堆的初始大小，若配置的初始值与最大值不等，堆变化后无法保证堆都锁定在内存中</li><li><code>文件描述符检查</code>：ES进程需要非常多的文件描述符，所以须配置系统的文件描述符的最大数量 <code>ulimit -n 65535</code></li><li><code>内存锁定检查</code>：ES允许进程只使用物理内存，若使用交换分区可能会带来很多问题，所以最好让ES锁定内存</li><li><code>最大线程数检查</code>：ES进程会创建很多线程，这个数最少需2048</li><li><code>最大虚拟内存检查</code></li><li><code>最大文件大小检查</code>：段文件和事务日志文件可能会非常大，建议这个数设置为无限</li><li><code>虚拟内存区域最大数量检查</code></li><li><code>JVM Client模式检查</code></li><li><code>串行收集检查</code>：ES默认使用 CMS 垃圾回收器，而不是 Serial 收集器</li><li><code>系统调用过滤器检查</code></li><li><code>OnError与OnOutOfMemoryError检查</code></li><li><code>Early-access检查</code>：ES最好运行在JVM的稳定版本上</li><li><code>G1GC检查</code></li></ul><p>顺便一提，JvmInfo 则是<strong>利用了 JavaSDK 自带的 ManagementFactory 类来获取JVM信息</strong>的，获取的 JVM 属性如下所示</p><pre><code>long pid;   // 进程IDString version; // Java版本String vmName;  // JVM名称String vmVersion;   // JVM版本String vmVendor;    // JVM开发商long startTime;     // 启动时间long configuredInitialHeapSize; // 配置的堆的初始值long configuredMaxHeapSize;     // 配置的堆的最大值Mem mem;            // 内存信息String[] inputArguments;    // JVM启动时输入的参数String bootClassPath;String classPath;   Map&lt;String, String&gt; systemProperties;   // 系统环境变量String[] gcCollectors;String[] memoryPools;String onError;String onOutOfMemoryError;String useCompressedOops;String useG1GC;     // 是否使用 G1 垃圾回收器String useSerialGC; // 是否使用 Serial 垃圾回收器</code></pre><h4 id="keepAlive-线程"><a href="#keepAlive-线程" class="headerlink" title="keepAlive 线程"></a>keepAlive 线程</h4><p>在启动引导类 Bootstrap 的 start 方法中，启动节点之后还会启动一个 keepAlive 线程</p><pre><code>private void start() throws NodeValidationException {    node.start();    keepAliveThread.start();}// CountDownLatch 初始值为 1private final CountDownLatch keepAliveLatch = new CountDownLatch(1);Bootstrap() {    keepAliveThread = new Thread(new Runnable() {        @Override        public void run() {            try {                keepAliveLatch.await(); // 一直等待直到 CountDownLatch 减为 0            } catch (InterruptedException e) {                // bail out            }        }    }, &quot;elasticsearch[keepAlive/&quot; + Version.CURRENT + &quot;]&quot;);    keepAliveThread.setDaemon(false);   // false 用户线程    // keep this thread alive (non daemon thread) until we shutdown    Runtime.getRuntime().addShutdownHook(new Thread() {        @Override        public void run() {            // 当进程收到关闭 SIGTERM 或 SIGINT 信号时，CountDownLatch 减1             keepAliveLatch.countDown();        }    });}if (addShutdownHook) {    Runtime.getRuntime().addShutdownHook(new Thread() {        @Override        public void run() {            try {                IOUtils.close(node, spawner);                LoggerContext context = (LoggerContext) LogManager.getContext(false);                Configurator.shutdown(context);            } catch (IOException ex) {                throw new ElasticsearchException(&quot;failed to stop node&quot;, ex);            }        }    });}</code></pre><p>keepAliveThread 线程本身不做具体的工作。主线程执行完启动流程后会退出，keepAliveThread 线程是唯一的用户线程，<strong>作用是保持进程运行</strong>。在Java程序中，一个进程至少需要有一个用户线程，当用户线程为零时将退出进程。</p><p>做个试验，将 <code>keepAliveThread.setDaemon(false);</code> 中的 <code>false</code> 改为 <code>true</code>，会发现Elasticsearch启动后马上就停止了</p><pre><code>[2019-01-08T01:28:47,522][INFO ][o.e.n.Node               ] [1yGidog] started[2019-01-08T01:28:47,525][INFO ][o.e.n.Node               ] [1yGidog] stopping ...</code></pre><h4 id="关闭节点"><a href="#关闭节点" class="headerlink" title="关闭节点"></a>关闭节点</h4><p>关闭的顺序大致为：</p><ul><li>关闭快照和HTTPServer，不再响应用户REST请求</li><li>关闭集群拓扑管理，不再响应ping请求</li><li>关闭网络模块，让节点离线</li><li>执行各个插件的关闭流程</li><li>关闭IndicesService，这期间需要等待释放的资源最多，时间最长</li></ul><pre><code class="java">public static void close(final Exception ex, final Iterable&lt;? extends Closeable&gt; objects) throws IOException {    Exception firstException = ex;    for (final Closeable object : objects) {        try {            if (object != null) {                object.close();            }        } catch (final IOException | RuntimeException e) {            if (firstException == null) {                firstException = e;            } else {                firstException.addSuppressed(e);            }        }    }    // ...}private Node stop() {    if (!lifecycle.moveToStopped()) {        return this;    }    Logger logger = Loggers.getLogger(Node.class, NODE_NAME_SETTING.get(settings));    logger.info(&quot;stopping ...&quot;);    injector.getInstance(ResourceWatcherService.class).stop();    if (NetworkModule.HTTP_ENABLED.get(settings)) {        injector.getInstance(HttpServerTransport.class).stop();    }    injector.getInstance(SnapshotsService.class).stop();    injector.getInstance(SnapshotShardsService.class).stop();    // stop any changes happening as a result of cluster state changes    injector.getInstance(IndicesClusterStateService.class).stop();    // close discovery early to not react to pings anymore.    // This can confuse other nodes and delay things - mostly if we&#39;re the master and we&#39;re running tests.    injector.getInstance(Discovery.class).stop();    // we close indices first, so operations won&#39;t be allowed on it    injector.getInstance(RoutingService.class).stop();    injector.getInstance(ClusterService.class).stop();    injector.getInstance(NodeConnectionsService.class).stop();    nodeService.getMonitorService().stop();    injector.getInstance(GatewayService.class).stop();    injector.getInstance(SearchService.class).stop();    injector.getInstance(TransportService.class).stop();    pluginLifecycleComponents.forEach(LifecycleComponent::stop);    // we should stop this last since it waits for resources to get released    // if we had scroll searchers etc or recovery going on we wait for to finish.    injector.getInstance(IndicesService.class).stop();    logger.info(&quot;stopped&quot;);    return this;}</code></pre><p>节点的关闭当然没那么简单。更多细节敬请期待。</p><blockquote><p>参考：<br>张超.Elasticsearch源码解析与优化实战</p></blockquote><h3 id="后记"><a href="#后记" class="headerlink" title="后记"></a>后记</h3><p>欢迎评论、转发、分享，您的支持是我最大的动力</p><p>更多内容可访问我的个人博客：<a href="http://laijianfeng.org">http://laijianfeng.org</a></p><p>关注【小旋锋】微信公众号，及时接收博文推送</p><p><img src="http://image.laijianfeng.org/20180913_001328.png" alt="关注_小旋锋_微信公众号"></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;本文主要简要介绍Elasticsearch单节点的启动和关闭流程。Elasticsearch版本：6.3.2   &lt;/p&gt;
&lt;h4 id=&quot;相关文章&quot;&gt;&lt;a href=&quot;#相关文章&quot; class=&quot;headerlink&quot; title=&quot;相关文章&quot;&gt;&lt;/a&gt;相关文章&lt;/h4&gt;
      
    
    </summary>
    
      <category term="大数据" scheme="http://laijianfeng.org/categories/%E5%A4%A7%E6%95%B0%E6%8D%AE/"/>
    
    
      <category term="elasticsearch" scheme="http://laijianfeng.org/tags/elasticsearch/"/>
    
  </entry>
  
  <entry>
    <title>设计模式 | 单例模式及典型应用</title>
    <link href="http://laijianfeng.org/2019/01/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F-%E5%8D%95%E4%BE%8B%E6%A8%A1%E5%BC%8F%E5%8F%8A%E5%85%B8%E5%9E%8B%E5%BA%94%E7%94%A8/"/>
    <id>http://laijianfeng.org/2019/01/设计模式-单例模式及典型应用/</id>
    <published>2019-01-06T17:35:54.000Z</published>
    <updated>2019-01-06T17:37:03.276Z</updated>
    
    <content type="html"><![CDATA[<p>单例是最常见的设计模式之一，实现的方式非常多，同时需要注意的问题也非常多。</p><p>本文主要内容：</p><ul><li>介绍单例模式</li><li>介绍单例模式的N中写法</li><li>单例模式的安全性<ul><li>序列化攻击</li><li>反射攻击</li></ul></li><li>单例模式总结</li><li>介绍单例模式的典型应用</li></ul><h3 id="单例模式"><a href="#单例模式" class="headerlink" title="单例模式"></a>单例模式</h3><p><strong>单例模式(Singleton Pattern)</strong>：确保某一个类只有一个实例，而且自行实例化并向整个系统提供这个实例，这个类称为单例类，它提供全局访问的方法。单例模式是一种对象创建型模式。</p><p>单例模式有三个要点：</p><ol><li>构造方法私有化；</li><li>实例化的变量引用私有化；</li><li>获取实例的方法共有</li></ol><h4 id="角色"><a href="#角色" class="headerlink" title="角色"></a>角色</h4><p><strong>Singleton（单例）</strong>：在单例类的内部实现只生成一个实例，同时它提供一个静态的 <code>getInstance()</code> 工厂方法，让客户可以访问它的唯一实例；为了防止在外部对其实例化，将其构造函数设计为私有；在单例类内部定义了一个 <code>Singleton</code> 类型的静态对象，作为外部共享的唯一实例。</p><h3 id="单例模式的七种写法"><a href="#单例模式的七种写法" class="headerlink" title="单例模式的七种写法"></a>单例模式的七种写法</h3><h4 id="1、饿汉式"><a href="#1、饿汉式" class="headerlink" title="1、饿汉式"></a>1、饿汉式</h4><pre><code>// 线程安全public class Singleton {    private final static Singleton INSTANCE = new Singleton();    private Singleton(){}    public static Singleton getInstance(){        return INSTANCE;    }}</code></pre><p><strong>优点</strong>：简单，使用时没有延迟；在类装载时就完成实例化，天生的线程安全</p><p><strong>缺点</strong>：没有懒加载，启动较慢；如果从始至终都没使用过这个实例，则会造成内存的浪费。</p><h4 id="2、饿汉式变种"><a href="#2、饿汉式变种" class="headerlink" title="2、饿汉式变种"></a>2、饿汉式变种</h4><pre><code>// 线程安全public class Singleton {    private static Singleton instance;    static {        instance = new Singleton();    }    private Singleton() {}    public static Singleton getInstance() {        return instance;    }}</code></pre><p>将类实例化的过程放在了静态代码块中，在类装载的时执行静态代码块中的代码，初始化类的实例。优缺点同上。</p><h4 id="3、懒汉式"><a href="#3、懒汉式" class="headerlink" title="3、懒汉式"></a>3、懒汉式</h4><pre><code>// 线程不安全public class Singleton {    private static Singleton singleton;    private Singleton() {}    public static Singleton getInstance() {        if (singleton == null) {            singleton = new Singleton();        }        return singleton;    }}</code></pre><p><strong>优点</strong>：懒加载，启动速度快、如果从始至终都没使用过这个实例，则不会初始化该实力，可节约资源</p><p><strong>缺点</strong>：多线程环境下线程不安全。<code>if (singleton == null)</code> 存在竞态条件，可能会有多个线程同时进入 <code>if 语句</code>，导致产生多个实例</p><h4 id="4、懒汉式变种"><a href="#4、懒汉式变种" class="headerlink" title="4、懒汉式变种"></a>4、懒汉式变种</h4><pre><code>// 线程安全，效率低public class Singleton {    private static Singleton singleton;    private Singleton() {}    public static synchronized Singleton getInstance() {        if (singleton == null) {            singleton = new Singleton();        }        return singleton;    }}</code></pre><p><strong>优点</strong>：解决了上一种实现方式的线程不安全问题</p><p><strong>缺点</strong>：synchronized 对整个 <code>getInstance()</code> 方法都进行了同步，每次只有一个线程能够进入该方法，并发性能极差</p><h4 id="5、双重检查锁"><a href="#5、双重检查锁" class="headerlink" title="5、双重检查锁"></a>5、双重检查锁</h4><pre><code>// 线程安全public class Singleton {    // 注意：这里有 volatile 关键字修饰    private static volatile Singleton singleton;    private Singleton() {}    public static Singleton getInstance() {        if (singleton == null) {            synchronized (Singleton.class) {                if (singleton == null) {                    singleton = new Singleton();                }            }        }        return singleton;    }}</code></pre><p><strong>优点</strong>：线程安全；延迟加载；效率较高。</p><p>由于 JVM 具有指令重排的特性，在多线程环境下可能出现  singleton 已经赋值但还没初始化的情况，导致一个线程获得还没有初始化的实例。volatile 关键字的作用：</p><ul><li>保证了不同线程对这个变量进行操作时的可见性</li><li>禁止进行指令重排序</li></ul><h4 id="6、静态内部类"><a href="#6、静态内部类" class="headerlink" title="6、静态内部类"></a>6、静态内部类</h4><pre><code>// 线程安全public class Singleton {    private Singleton() {}    private static class SingletonInstance {        private static final Singleton INSTANCE = new Singleton();    }    public static Singleton getInstance() {        return SingletonInstance.INSTANCE;    }}</code></pre><p><strong>优点</strong>：避免了线程不安全，延迟加载，效率高。</p><p>静态内部类的方式利用了类装载机制来保证线程安全，只有在第一次调用getInstance方法时，才会装载SingletonInstance内部类，完成Singleton的实例化，所以也有懒加载的效果。</p><p><strong>加入参数 <code>-verbose:class</code> 可以查看类加载顺序</strong></p><pre><code>$ javac Singleton.java$ java -verbose:class Singleton</code></pre><h4 id="7、枚举"><a href="#7、枚举" class="headerlink" title="7、枚举"></a>7、枚举</h4><pre><code>// 线程安全public enum Singleton {    INSTANCE;    public void whateverMethod() {    }}</code></pre><p><strong>优点</strong>：通过JDK1.5中添加的枚举来实现单例模式，<strong>写法简单</strong>，且不仅能<strong>避免多线程同步问题</strong>，而且还能<strong>防止反序列化重新创建新的对象</strong>。</p><h3 id="单例模式的安全性"><a href="#单例模式的安全性" class="headerlink" title="单例模式的安全性"></a>单例模式的安全性</h3><p>单例模式的目标是，任何时候该类都只有唯一的一个对象。但是上面我们写的大部分单例模式都存在漏洞，被攻击时会产生多个对象，破坏了单例模式。</p><h4 id="序列化攻击"><a href="#序列化攻击" class="headerlink" title="序列化攻击"></a>序列化攻击</h4><p>通过Java的序列化机制来攻击单例模式</p><pre><code>public class HungrySingleton {    private static final HungrySingleton instance = new HungrySingleton();    private HungrySingleton() {    }    public static HungrySingleton getInstance() {        return instance;    }    public static void main(String[] args) throws IOException, ClassNotFoundException {        HungrySingleton singleton = HungrySingleton.getInstance();        ObjectOutputStream oos = new ObjectOutputStream(new FileOutputStream(&quot;singleton_file&quot;));        oos.writeObject(singleton); // 序列化        ObjectInputStream ois = new ObjectInputStream(new FileInputStream(&quot;singleton_file&quot;));        HungrySingleton newSingleton = (HungrySingleton) ois.readObject(); // 反序列化        System.out.println(singleton);        System.out.println(newSingleton);        System.out.println(singleton == newSingleton);    }}</code></pre><p>结果</p><pre><code>com.singleton.HungrySingleton@ed17beecom.singleton.HungrySingleton@46f5f779false</code></pre><p>Java 序列化是如何攻击单例模式的呢？我们需要先复习一下Java的序列化机制</p><h5 id="Java-序列化机制"><a href="#Java-序列化机制" class="headerlink" title="Java 序列化机制"></a>Java 序列化机制</h5><p><code>java.io.ObjectOutputStream</code> 是Java实现序列化的关键类，它可以将一个对象转换成二进制流，然后可以通过 <code>ObjectInputStream</code> 将二进制流还原成对象。具体的序列化过程不是本文的重点，在此仅列出几个要点。</p><p><strong>Java 序列化机制的要点</strong>：</p><ul><li>需要序列化的类必须实现<code>java.io.Serializable</code>接口，否则会抛出<code>NotSerializableException</code>异常 </li><li>若没有显示地声明一个<code>serialVersionUID</code>变量，Java序列化机制会根据编译时的class自动生成一个<code>serialVersionUID</code>作为序列化版本比较（验证一致性），如果检测到反序列化后的类的<code>serialVersionUID</code>和对象二进制流的<code>serialVersionUID</code>不同，则会抛出异常</li><li>Java的序列化会将一个类包含的引用中所有的成员变量保存下来（深度复制），所以里面的引用类型必须也要实现<code>java.io.Serializable</code>接口</li><li>当某个字段被声明为<code>transient</code>后，默认序列化机制就会忽略该字段，反序列化后自动获得0或者null值</li><li>静态成员不参与序列化</li><li>每个类可以实现<code>readObject</code>、<code>writeObject</code>方法实现自己的序列化策略，即使是<code>transient</code>修饰的成员变量也可以手动调用<code>ObjectOutputStream</code>的<code>writeInt</code>等方法将这个成员变量序列化。</li><li>任何一个readObject方法，不管是显式的还是默认的，它都会返回一个新建的实例，这个新建的实例不同于该类初始化时创建的实例</li><li>每个类可以实现<code>private Object readResolve()</code>方法，在调用<code>readObject</code>方法之后，如果存在<code>readResolve</code>方法则自动调用该方法，<code>readResolve</code>将对<code>readObject</code>的结果进行处理，而最终<code>readResolve</code>的处理结果将作为<code>readObject</code>的结果返回。<code>readResolve</code>的目的是保护性恢复对象，其最重要的应用就是保护性恢复单例、枚举类型的对象</li><li><code>Serializable</code>接口是一个标记接口，可自动实现序列化，而<code>Externalizable</code>继承自<code>Serializable</code>，它强制必须手动实现序列化和反序列化算法，相对来说更加高效</li></ul><h5 id="序列化破坏单例模式的解决方案"><a href="#序列化破坏单例模式的解决方案" class="headerlink" title="序列化破坏单例模式的解决方案"></a>序列化破坏单例模式的解决方案</h5><p>根据上面对Java序列化机制的复习，我们可以自定义一个 <code>readResolve</code>，在其中返回类的单例对象，替换掉 <code>readObject</code> 方法反序列化生成的对象，让我们自己写的单例模式实现保护性恢复对象</p><pre><code>public class HungrySingleton implements Serializable {    private static final HungrySingleton instance = new HungrySingleton();    private HungrySingleton() {    }    public static HungrySingleton getInstance() {        return instance;    }    private Object readResolve() {        return instance;    }    public static void main(String[] args) throws IOException, ClassNotFoundException {        HungrySingleton singleton = HungrySingleton.getInstance();        ObjectInputStream ois = new ObjectInputStream(new FileInputStream(&quot;singleton_file&quot;));        HungrySingleton newSingleton = (HungrySingleton) ois.readObject();        System.out.println(singleton);        System.out.println(newSingleton);        System.out.println(singleton == newSingleton);    }}</code></pre><p>再次运行</p><pre><code>com.singleton.HungrySingleton@24273305com.singleton.HungrySingleton@24273305true</code></pre><p>注意：自己实现的单例模式都需要避免被序列化破坏</p><h4 id="反射攻击"><a href="#反射攻击" class="headerlink" title="反射攻击"></a>反射攻击</h4><p>在单例模式中，构造器都是私有的，而反射可以通过构造器对象调用 <code>setAccessible(true)</code> 来获得权限，这样就可以创建多个对象，来破坏单例模式了</p><pre><code>public class HungrySingleton {    private static final HungrySingleton instance = new HungrySingleton();    private HungrySingleton() {    }    public static HungrySingleton getInstance() {        return instance;    }    public static void main(String[] args) throws NoSuchMethodException, IllegalAccessException, InvocationTargetException, InstantiationException {        HungrySingleton instance = HungrySingleton.getInstance();        Constructor constructor = HungrySingleton.class.getDeclaredConstructor();        constructor.setAccessible(true);    // 获得权限        HungrySingleton newInstance = (HungrySingleton) constructor.newInstance();        System.out.println(instance);        System.out.println(newInstance);        System.out.println(instance == newInstance);    }}</code></pre><p>输出结果</p><pre><code>com.singleton.HungrySingleton@3b192d32com.singleton.HungrySingleton@16f65612false</code></pre><h5 id="反射攻击解决方案"><a href="#反射攻击解决方案" class="headerlink" title="反射攻击解决方案"></a>反射攻击解决方案</h5><p>反射是通过它的Class对象来调用构造器创建新的对象，我们只需要在构造器中检测并抛出异常就可以达到目的了</p><pre><code>private HungrySingleton() {    // instance 不为空，说明单例对象已经存在    if (instance != null) {        throw new RuntimeException(&quot;单例模式禁止反射调用！&quot;);    }}</code></pre><p>运行结果</p><pre><code>Exception in thread &quot;main&quot; java.lang.reflect.InvocationTargetException    at sun.reflect.NativeConstructorAccessorImpl.newInstance0(Native Method)    at sun.reflect.NativeConstructorAccessorImpl.newInstance(NativeConstructorAccessorImpl.java:62)    at sun.reflect.DelegatingConstructorAccessorImpl.newInstance(DelegatingConstructorAccessorImpl.java:45)    at java.lang.reflect.Constructor.newInstance(Constructor.java:423)    at com.singleton.HungrySingleton.main(HungrySingleton.java:32)Caused by: java.lang.RuntimeException: 单例模式禁止反射调用！    at com.singleton.HungrySingleton.&lt;init&gt;(HungrySingleton.java:20)    ... 5 more</code></pre><p><strong>注意</strong>，上述方法针对饿汉式单例模式是有效的，但<strong>对懒汉式的单例模式是无效的，懒汉式的单例模式是无法避免反射攻击的！</strong></p><p>为什么对饿汉有效，对懒汉无效？因为饿汉的初始化是在类加载的时候，反射一定是在饿汉初始化之后才能使用；而懒汉是在第一次调用 <code>getInstance()</code> 方法的时候才初始化，我们无法控制反射和懒汉初始化的先后顺序，如果反射在前，不管反射创建了多少对象，instance都将一直为null，直到调用 <code>getInstance()</code>。</p><p><strong>事实上，实现单例模式的唯一推荐方法，是使用枚举类来实现。</strong></p><h4 id="为什么推荐使用枚举单例"><a href="#为什么推荐使用枚举单例" class="headerlink" title="为什么推荐使用枚举单例"></a>为什么推荐使用枚举单例</h4><p>写下我们的枚举单例模式</p><pre><code>package com.singleton;import java.io.*;import java.lang.reflect.Constructor;import java.lang.reflect.InvocationTargetException;public enum SerEnumSingleton implements Serializable {    INSTANCE;   // 单例对象    private String content;    public String getContent() {        return content;    }    public void setContent(String content) {        this.content = content;    }    private SerEnumSingleton() {    }    public static void main(String[] args) throws IOException, ClassNotFoundException, NoSuchMethodException, IllegalAccessException, InvocationTargetException, InstantiationException {        SerEnumSingleton singleton1 = SerEnumSingleton.INSTANCE;        singleton1.setContent(&quot;枚举单例序列化&quot;);        System.out.println(&quot;枚举序列化前读取其中的内容：&quot; + singleton1.getContent());        ObjectOutputStream oos = new ObjectOutputStream(new FileOutputStream(&quot;SerEnumSingleton.obj&quot;));        oos.writeObject(singleton1);        oos.flush();        oos.close();        FileInputStream fis = new FileInputStream(&quot;SerEnumSingleton.obj&quot;);        ObjectInputStream ois = new ObjectInputStream(fis);        SerEnumSingleton singleton2 = (SerEnumSingleton) ois.readObject();        ois.close();        System.out.println(singleton1 + &quot;\n&quot; + singleton2);        System.out.println(&quot;枚举序列化后读取其中的内容：&quot; + singleton2.getContent());        System.out.println(&quot;枚举序列化前后两个是否同一个：&quot; + (singleton1 == singleton2));        Constructor&lt;SerEnumSingleton&gt; constructor = SerEnumSingleton.class.getDeclaredConstructor();        constructor.setAccessible(true);        SerEnumSingleton singleton3 = constructor.newInstance(); // 通过反射创建对象        System.out.println(&quot;反射后读取其中的内容：&quot; + singleton3.getContent());        System.out.println(&quot;反射前后两个是否同一个：&quot; + (singleton1 == singleton3));    }}</code></pre><p>运行结果，序列化前后的对象是同一个对象，而反射的时候抛出了异常</p><pre><code>枚举序列化前读取其中的内容：枚举单例序列化INSTANCEINSTANCE枚举序列化后读取其中的内容：枚举单例序列化枚举序列化前后两个是否同一个：trueException in thread &quot;main&quot; java.lang.NoSuchMethodException: com.singleton.SerEnumSingleton.&lt;init&gt;()    at java.lang.Class.getConstructor0(Class.java:3082)    at java.lang.Class.getDeclaredConstructor(Class.java:2178)    at com.singleton.SerEnumSingleton.main(SerEnumSingleton.java:39)</code></pre><p>编译后，再通过 JAD 进行反编译得到下面的代码</p><pre><code>// Decompiled by Jad v1.5.8g. Copyright 2001 Pavel Kouznetsov.// Jad home page: http://www.kpdus.com/jad.html// Decompiler options: packimports(3) // Source File Name:   SerEnumSingleton.javapackage com.singleton;import java.io.*;import java.lang.reflect.Constructor;import java.lang.reflect.InvocationTargetException;public final class SerEnumSingleton extends Enum    implements Serializable{    public static SerEnumSingleton[] values()    {        return (SerEnumSingleton[])$VALUES.clone();    }    public static SerEnumSingleton valueOf(String name)    {        return (SerEnumSingleton)Enum.valueOf(com/singleton/SerEnumSingleton, name);    }    public String getContent()    {        return content;    }    public void setContent(String content)    {        this.content = content;    }    private SerEnumSingleton(String s, int i)    {        super(s, i);    }    public static void main(String args[])        throws IOException, ClassNotFoundException, NoSuchMethodException, IllegalAccessException, InvocationTargetException, InstantiationException    {        SerEnumSingleton singleton1 = INSTANCE;        singleton1.setContent(&quot;\u679A\u4E3E\u5355\u4F8B\u5E8F\u5217\u5316&quot;);        System.out.println((new StringBuilder()).append(&quot;\u679A\u4E3E\u5E8F\u5217\u5316\u524D\u8BFB\u53D6\u5176\u4E2D\u7684\u5185\u5BB9\uFF1A&quot;).append(singleton1.getContent()).toString());        ObjectOutputStream oos = new ObjectOutputStream(new FileOutputStream(&quot;SerEnumSingleton.obj&quot;));        oos.writeObject(singleton1);        oos.flush();        oos.close();        FileInputStream fis = new FileInputStream(&quot;SerEnumSingleton.obj&quot;);        ObjectInputStream ois = new ObjectInputStream(fis);        SerEnumSingleton singleton2 = (SerEnumSingleton)ois.readObject();        ois.close();        System.out.println((new StringBuilder()).append(singleton1).append(&quot;\n&quot;).append(singleton2).toString());        System.out.println((new StringBuilder()).append(&quot;\u679A\u4E3E\u5E8F\u5217\u5316\u540E\u8BFB\u53D6\u5176\u4E2D\u7684\u5185\u5BB9\uFF1A&quot;).append(singleton2.getContent()).toString());        System.out.println((new StringBuilder()).append(&quot;\u679A\u4E3E\u5E8F\u5217\u5316\u524D\u540E\u4E24\u4E2A\u662F\u5426\u540C\u4E00\u4E2A\uFF1A&quot;).append(singleton1 == singleton2).toString());        Constructor constructor = com/singleton/SerEnumSingleton.getDeclaredConstructor(new Class[0]);        constructor.setAccessible(true);        SerEnumSingleton singleton3 = (SerEnumSingleton)constructor.newInstance(new Object[0]);        System.out.println((new StringBuilder()).append(&quot;\u53CD\u5C04\u540E\u8BFB\u53D6\u5176\u4E2D\u7684\u5185\u5BB9\uFF1A&quot;).append(singleton3.getContent()).toString());        System.out.println((new StringBuilder()).append(&quot;\u53CD\u5C04\u524D\u540E\u4E24\u4E2A\u662F\u5426\u540C\u4E00\u4E2A\uFF1A&quot;).append(singleton1 == singleton3).toString());    }    public static final SerEnumSingleton INSTANCE;    private String content;    private static final SerEnumSingleton $VALUES[];    static     {        INSTANCE = new SerEnumSingleton(&quot;INSTANCE&quot;, 0);        $VALUES = (new SerEnumSingleton[] {            INSTANCE        });    }}</code></pre><p>通过反编译后代码我们可以看到，<code>ublic final class T extends Enum</code>，说明，当我们使用enmu来定义一个枚举类型的时候，编译器会自动帮我们创建一个final类型的类继承Enum类，所以枚举类型不能被继承。</p><h5 id="那么，为什么推荐使用枚举单例呢？"><a href="#那么，为什么推荐使用枚举单例呢？" class="headerlink" title="那么，为什么推荐使用枚举单例呢？"></a>那么，为什么推荐使用枚举单例呢？</h5><p><strong>1. 枚举单例写法简单</strong></p><p><strong>2. 线程安全&amp;懒加载</strong></p><p>代码中 INSTANCE 变量被 <code>public static final</code> 修饰，因为static类型的属性是在类加载之后初始化的，JVM可以保证线程安全；且Java类是在引用到的时候才进行类加载，所以枚举单例也有懒加载的效果。</p><p><strong>3. 枚举自己能避免序列化攻击</strong></p><p>为了保证枚举类型像Java规范中所说的那样，每一个枚举类型极其定义的枚举变量在JVM中都是唯一的，在枚举类型的序列化和反序列化上，Java做了特殊的规定。</p><p>在序列化的时候Java<strong>仅仅是将枚举对象的name属性输出到结果中</strong>，反序列化的时候则是通过java.lang.Enum的valueOf方法来<strong>根据名字查找枚举对象</strong>。同时，<strong>编译器是不允许任何对这种序列化机制的定制</strong>，因此禁用了writeObject、readObject、readObjectNoData、writeReplace和readResolve等方法。 我们看一下Enum类的valueOf方法：</p><pre><code>    public static &lt;T extends Enum&lt;T&gt;&gt; T valueOf(Class&lt;T&gt; enumType, String name) {        T result = enumType.enumConstantDirectory().get(name);        if (result != null)            return result;        if (name == null)            throw new NullPointerException(&quot;Name is null&quot;);        throw new IllegalArgumentException(            &quot;No enum constant &quot; + enumType.getCanonicalName() + &quot;.&quot; + name);    }</code></pre><p>从代码中可以看到，代码会尝试从调用enumType这个Class对象的<code>enumConstantDirectory()</code>方法返回的map中获取名字为name的枚举对象，如果不存在就会抛出异常。再进一步跟到<code>enumConstantDirectory()</code>方法，就会发现到最后会以反射的方式调用enumType这个类型的values()静态方法，也就是上面我们看到的编译器为我们创建的那个方法，然后用返回结果填充enumType这个Class对象中的<code>enumConstantDirectory</code>属性。所以，JVM对序列化有保证。</p><p><strong>4. 枚举能够避免反射攻击，因为反射不支持创建枚举对象</strong></p><p><code>Constructor</code>类的 <code>newInstance</code>方法中会判断是否为 enum，若是会抛出异常</p><pre><code>    @CallerSensitive    public T newInstance(Object ... initargs) throws InstantiationException, IllegalAccessException, IllegalArgumentException, InvocationTargetException {        if (!override) {            if (!Reflection.quickCheckMemberAccess(clazz, modifiers)) {                Class&lt;?&gt; caller = Reflection.getCallerClass();                checkAccess(caller, clazz, null, modifiers);            }        }        // 不能为 ENUM，否则抛出异常：不能通过反射创建 enum 对象        if ((clazz.getModifiers() &amp; Modifier.ENUM) != 0)            throw new IllegalArgumentException(&quot;Cannot reflectively create enum objects&quot;);        ConstructorAccessor ca = constructorAccessor;   // read volatile        if (ca == null) {            ca = acquireConstructorAccessor();        }        @SuppressWarnings(&quot;unchecked&quot;)        T inst = (T) ca.newInstance(initargs);        return inst;    }</code></pre><h3 id="单例模式总结"><a href="#单例模式总结" class="headerlink" title="单例模式总结"></a>单例模式总结</h3><p>单例模式作为一种目标明确、结构简单、理解容易的设计模式，在软件开发中使用频率相当高，在很多应用软件和框架中都得以广泛应用。</p><h4 id="单例模式的主要优点"><a href="#单例模式的主要优点" class="headerlink" title="单例模式的主要优点"></a>单例模式的主要优点</h4><ul><li>单例模式提供了对唯一实例的受控访问。</li><li>由于在系统内存中只存在一个对象，因此可以节约系统资源，对于一些需要频繁创建和销毁的对象，单例模式可以提高系统的性能。</li><li>允许可变数目的实例。基于单例模式我们可以进行扩展，使用与单例控制相似的方法来获得指定个数的对象实例，既节省系统资源，又解决了单例单例对象共享过多有损性能的问题。</li></ul><h4 id="单例模式的主要缺点"><a href="#单例模式的主要缺点" class="headerlink" title="单例模式的主要缺点"></a>单例模式的主要缺点</h4><ul><li>由于单例模式中没有抽象层，因此单例类的扩展有很大的困难。</li><li>单例类的职责过重，在一定程度上违背了 “单一职责原则”。</li><li>如果实例化的共享对象长时间不被利用，系统可能会认为它是垃圾，会自动销毁并回收资源，下次利用时又将重新实例化，这将导致共享的单例对象状态的丢失。</li></ul><h4 id="适用场景"><a href="#适用场景" class="headerlink" title="适用场景"></a>适用场景</h4><ul><li>系统只需要一个实例对象，如系统要求提供一个唯一的序列号生成器或资源管理器，或者需要考虑资源消耗太大而只允许创建一个对象。</li><li>客户调用类的单个实例只允许使用一个公共访问点，除了该公共访问点，不能通过其他途径访问该实例。</li></ul><h3 id="单例模式的典型应用"><a href="#单例模式的典型应用" class="headerlink" title="单例模式的典型应用"></a>单例模式的典型应用</h3><h4 id="JDK-Runtime-饿汉单例"><a href="#JDK-Runtime-饿汉单例" class="headerlink" title="JDK Runtime 饿汉单例"></a>JDK Runtime 饿汉单例</h4><p>JDK Runtime类代表着Java程序的运行时环境，每个Java程序都有一个Runtime实例，该类会被自动创建，我们可以通过 Runtime.getRuntime() 方法来获取当前程序的Runtime实例。一旦得到了一个当前的Runtime对象的引用，就可以调用Runtime对象的方法去控制Java虚拟机的状态和行为。</p><p>Runtime 应用了饿汉式单例模式</p><pre><code>public class Runtime {    private static Runtime currentRuntime = new Runtime();    public static Runtime getRuntime() {        return currentRuntime;    }    private Runtime() {    }    //....}</code></pre><p>API 介绍</p><pre><code>addShutdownHook(Thread hook) 注册新的虚拟机来关闭挂钩。 availableProcessors() 向 Java 虚拟机返回可用处理器的数目。 exec(String command) 在单独的进程中执行指定的字符串命令。 exec(String[] cmdarray) 在单独的进程中执行指定命令和变量。 exec(String[] cmdarray, String[] envp) 在指定环境的独立进程中执行指定命令和变量。 exec(String[] cmdarray, String[] envp, File dir) 在指定环境和工作目录的独立进程中执行指定的命令和变量。 exec(String command, String[] envp) 在指定环境的单独进程中执行指定的字符串命令。 exec(String command, String[] envp, File dir) 在有指定环境和工作目录的独立进程中执行指定的字符串命令。 exit(int status) 通过启动虚拟机的关闭序列，终止当前正在运行的 Java 虚拟机。 freeMemory() 返回 Java 虚拟机中的空闲内存量。 gc() 运行垃圾回收器。  getRuntime() 返回与当前 Java 应用程序相关的运行时对象。 halt(int status) 强行终止目前正在运行的 Java 虚拟机。 load(String filename) 加载作为动态库的指定文件名。 loadLibrary(String libname) 加载具有指定库名的动态库。 maxMemory() 返回 Java 虚拟机试图使用的最大内存量。 removeShutdownHook(Thread hook) 取消注册某个先前已注册的虚拟机关闭挂钩。 runFinalization() 运行挂起 finalization 的所有对象的终止方法。 totalMemory() 返回 Java 虚拟机中的内存总量。 traceInstructions(on) 启用／禁用指令跟踪。 traceMethodCalls(on) 启用／禁用方法调用跟踪。</code></pre><h4 id="AWT-Desktop-容器单例"><a href="#AWT-Desktop-容器单例" class="headerlink" title="AWT Desktop 容器单例"></a>AWT Desktop 容器单例</h4><p>Desktop 类允许 Java 应用程序启动已在本机桌面上注册的关联应用程序，以处理 URI 或文件。支持的操作包括:</p><ul><li>打开浏览器: 启动用户默认浏览器来显示指定的 URI；</li><li>打开邮件客户端: 启动带有可选 mailto URI 的用户默认邮件客户端；</li><li>打开文件/文件夹: 启动已注册的应用程序，以打开、编辑 或 打印 指定的文件。</li></ul><p>Desktop 通过一个容器来管理单例对象</p><pre><code>public class Desktop {    // synchronized 同步方法    public static synchronized Desktop getDesktop(){        if (GraphicsEnvironment.isHeadless()) throw new HeadlessException();        if (!Desktop.isDesktopSupported()) {            throw new UnsupportedOperationException(&quot;Desktop API is not &quot; + &quot;supported on the current platform&quot;);        }        sun.awt.AppContext context = sun.awt.AppContext.getAppContext();        Desktop desktop = (Desktop)context.get(Desktop.class); // 获取单例对象        // 存在则返回，不存在则创建，创建后put进容器        if (desktop == null) {            desktop = new Desktop();             context.put(Desktop.class, desktop);        }        return desktop;    }</code></pre><p>AppContext 中有一个 HashMap 对象table，是实际的容器对象</p><pre><code>private final Map&lt;Object, Object&gt; table = new HashMap();</code></pre><h4 id="spring-AbstractFactoryBean"><a href="#spring-AbstractFactoryBean" class="headerlink" title="spring AbstractFactoryBean"></a>spring AbstractFactoryBean</h4><p>AbstractFactoryBean 类</p><pre><code>public final T getObject() throws Exception {    if (this.isSingleton()) {        return this.initialized ? this.singletonInstance : this.getEarlySingletonInstance();    } else {        return this.createInstance();    }}private T getEarlySingletonInstance() throws Exception {    Class&lt;?&gt;[] ifcs = this.getEarlySingletonInterfaces();    if (ifcs == null) {        throw new FactoryBeanNotInitializedException(this.getClass().getName() + &quot; does not support circular references&quot;);    } else {        if (this.earlySingletonInstance == null) {            // 通过代理创建对象            this.earlySingletonInstance = Proxy.newProxyInstance(this.beanClassLoader, ifcs, new AbstractFactoryBean.EarlySingletonInvocationHandler());        }        return this.earlySingletonInstance;    }}</code></pre><h4 id="Mybatis-ErrorContext-ThreadLocal"><a href="#Mybatis-ErrorContext-ThreadLocal" class="headerlink" title="Mybatis ErrorContext ThreadLocal"></a>Mybatis ErrorContext ThreadLocal</h4><p>ErrorContext 类，通过 ThreadLocal 管理单例对象，一个线程一个ErrorContext对象，ThreadLocal可以保证线程安全</p><pre><code>public class ErrorContext {    private static final ThreadLocal&lt;ErrorContext&gt; LOCAL = new ThreadLocal&lt;ErrorContext&gt;();    private ErrorContext() {    }    public static ErrorContext instance() {        ErrorContext context = LOCAL.get();        if (context == null) {          context = new ErrorContext();          LOCAL.set(context);        }        return context;    }    //...}</code></pre><blockquote><p>参考：<br><a href="http://www.hollischuang.com/archives/197" target="_blank" rel="noopener">http://www.hollischuang.com/archives/197</a><br><a href="https://www.cnblogs.com/chiclee/p/9097772.html" target="_blank" rel="noopener">https://www.cnblogs.com/chiclee/p/9097772.html</a><br><a href="https://blog.csdn.net/abc123lzf/article/details/82318148" target="_blank" rel="noopener">https://blog.csdn.net/abc123lzf/article/details/82318148</a></p></blockquote><h3 id="后记"><a href="#后记" class="headerlink" title="后记"></a>后记</h3><p>欢迎评论、转发、分享，您的支持是我最大的动力</p><p>更多内容可访问我的个人博客：<a href="http://laijianfeng.org">http://laijianfeng.org</a></p><p>关注【小旋锋】微信公众号，及时接收博文推送</p><p><img src="http://image.laijianfeng.org/20180913_001328.png" alt="关注_小旋锋_微信公众号"></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;单例是最常见的设计模式之一，实现的方式非常多，同时需要注意的问题也非常多。&lt;/p&gt;
&lt;p&gt;本文主要内容：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;介绍单例模式&lt;/li&gt;
&lt;li&gt;介绍单例模式的N中写法&lt;/li&gt;
&lt;li&gt;单例模式的安全性&lt;ul&gt;
&lt;li&gt;序列化攻击&lt;/li&gt;
&lt;li&gt;反射
      
    
    </summary>
    
      <category term="后端" scheme="http://laijianfeng.org/categories/%E5%90%8E%E7%AB%AF/"/>
    
    
      <category term="设计模式" scheme="http://laijianfeng.org/tags/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/"/>
    
  </entry>
  
  <entry>
    <title>Java 动态代理详解</title>
    <link href="http://laijianfeng.org/2018/12/Java-%E5%8A%A8%E6%80%81%E4%BB%A3%E7%90%86%E8%AF%A6%E8%A7%A3/"/>
    <id>http://laijianfeng.org/2018/12/Java-动态代理详解/</id>
    <published>2018-12-20T17:46:11.000Z</published>
    <updated>2018-12-20T17:54:09.592Z</updated>
    
    <content type="html"><![CDATA[<p>动态代理在Java中有着广泛的应用，比如Spring AOP、Hibernate数据查询、测试框架的后端mock、RPC远程调用、Java注解对象获取、日志、用户鉴权、全局性异常处理、性能监控，甚至事务处理等。</p><p>本文主要介绍Java中两种常见的动态代理方式：JDK原生动态代理和CGLIB动态代理。</p><p>由于Java动态代理与java反射机制关系紧密，请读者确保已经了解了Java反射机制，可参考上一篇文章《<a href="https://mp.weixin.qq.com/s?__biz=MzI1NDU0MTE1NA==&amp;mid=2247483785&amp;idx=1&amp;sn=f696c8c49cb7ecce9818247683482a1c&amp;chksm=e9c2ed84deb564925172b2dd78d307d4dc345fa313d3e44f01e84fa22ac5561b37aec5cbd5b4&amp;scene=0#rd" target="_blank" rel="noopener">Java反射机制详解</a>》</p><h3 id="代理模式"><a href="#代理模式" class="headerlink" title="代理模式"></a>代理模式</h3><p>本文将介绍的Java动态代理与设计模式中的代理模式有关，什么是代理模式呢？</p><p><strong>代理模式</strong>：给某一个对象提供一个代理，并由代理对象来控制对真实对象的访问。代理模式是一种结构型设计模式。</p><p>代理模式角色分为 3 种：</p><p><strong>Subject（抽象主题角色）</strong>：定义代理类和真实主题的公共对外方法，也是代理类代理真实主题的方法；</p><p><strong>RealSubject（真实主题角色</strong>）：真正实现业务逻辑的类；</p><p><strong>Proxy（代理主题角色）</strong>：用来代理和封装真实主题；</p><p>代理模式的结构比较简单，其核心是代理类，为了让客户端能够<strong>一致性地对待</strong>真实对象和代理对象，在代理模式中引入了抽象层</p><p><img src="http://image.laijianfeng.org/2018_12_20_proxyUML.jpg" alt="代理模式类图"></p><p>代理模式<strong>按照职责</strong>（使用场景）来分类，至少可以分为以下几类：1、远程代理。 2、虚拟代理。 3、Copy-on-Write 代理。 4、保护（Protect or Access）代理。 5、Cache代理。 6、防火墙（Firewall）代理。 7、同步化（Synchronization）代理。 8、智能引用（Smart Reference）代理等等。</p><p>如果<strong>根据字节码的创建时机</strong>来分类，可以分为静态代理和动态代理：</p><ul><li>所谓<strong>静态</strong>也就是在<strong>程序运行前</strong>就已经存在代理类的<strong>字节码文件</strong>，代理类和真实主题角色的关系在运行前就确定了。</li><li>而动态代理的源码是在程序运行期间由<strong>JVM</strong>根据反射等机制<strong>动态的生成</strong>，所以在运行前并不存在代理类的字节码文件</li></ul><h3 id="静态代理"><a href="#静态代理" class="headerlink" title="静态代理"></a>静态代理</h3><p>我们先通过实例来学习静态代理，然后理解静态代理的缺点，再来学习本文的主角：动态代理</p><p>编写一个接口 UserService ，以及该接口的一个实现类 UserServiceImpl</p><pre><code class="java">public interface UserService {    public void select();       public void update();}public class UserServiceImpl implements UserService {      public void select() {          System.out.println(&quot;查询 selectById&quot;);    }    public void update() {        System.out.println(&quot;更新 update&quot;);    }}</code></pre><p>我们将通过静态代理对 UserServiceImpl 进行功能增强，在调用 <code>select</code> 和 <code>update</code> 之前记录一些日志。写一个代理类 UserServiceProxy，代理类需要实现 UserService</p><pre><code class="java">public class UserServiceProxy implements UserService {    private UserService target; // 被代理的对象    public UserServiceProxy(UserService target) {        this.target = target;    }    public void select() {        before();        target.select();    // 这里才实际调用真实主题角色的方法        after();    }    public void update() {        before();        target.update();    // 这里才实际调用真实主题角色的方法        after();    }    private void before() {     // 在执行方法之前执行        System.out.println(String.format(&quot;log start time [%s] &quot;, new Date()));    }    private void after() {      // 在执行方法之后执行        System.out.println(String.format(&quot;log end time [%s] &quot;, new Date()));    }}</code></pre><p>客户端测试</p><pre><code class="java">public class Client1 {    public static void main(String[] args) {        UserService userServiceImpl = new UserServiceImpl();        UserService proxy = new UserServiceProxy(userServiceImpl);        proxy.select();        proxy.update();    }}</code></pre><p>输出</p><pre><code>log start time [Thu Dec 20 14:13:25 CST 2018] 查询 selectByIdlog end time [Thu Dec 20 14:13:25 CST 2018] log start time [Thu Dec 20 14:13:25 CST 2018] 更新 updatelog end time [Thu Dec 20 14:13:25 CST 2018] </code></pre><p>通过静态代理，我们达到了功能增强的目的，而且没有侵入原代码，这是静态代理的一个优点。</p><h4 id="静态代理的缺点"><a href="#静态代理的缺点" class="headerlink" title="静态代理的缺点"></a>静态代理的缺点</h4><p>虽然静态代理实现简单，且不侵入原代码，但是，当场景稍微复杂一些的时候，静态代理的缺点也会暴露出来。</p><p>1、 当需要代理多个类的时候，由于代理对象要实现与目标对象一致的接口，有两种方式：</p><ul><li>只维护一个代理类，由这个代理类实现多个接口，但是这样就导致<strong>代理类过于庞大</strong></li><li>新建多个代理类，每个目标对象对应一个代理类，但是这样会<strong>产生过多的代理类</strong></li></ul><p>2、 当接口需要增加、删除、修改方法的时候，目标对象与代理类都要同时修改，<strong>不易维护</strong>。</p><h4 id="如何改进？"><a href="#如何改进？" class="headerlink" title="如何改进？"></a>如何改进？</h4><p>当然是让代理类<strong>动态的生成</strong>啦，也就是动态代理。</p><p><strong>为什么类可以动态的生成？</strong></p><p>这就涉及到Java虚拟机的<strong>类加载机制</strong>了，推荐翻看《深入理解Java虚拟机》7.3节 类加载的过程。</p><p>Java虚拟机类加载过程主要分为五个阶段：加载、验证、准备、解析、初始化。其中加载阶段需要完成以下3件事情：</p><ol><li>通过一个类的全限定名来获取定义此类的二进制字节流</li><li>将这个字节流所代表的静态存储结构转化为方法区的运行时数据结构</li><li>在内存中生成一个代表这个类的 <code>java.lang.Class</code> 对象，作为方法区这个类的各种数据访问入口</li></ol><p>由于虚拟机规范对这3点要求并不具体，所以实际的实现是非常灵活的，关于第1点，<strong>获取类的二进制字节流</strong>（class字节码）就有很多途径：</p><ul><li>从ZIP包获取，这是JAR、EAR、WAR等格式的基础</li><li>从网络中获取，典型的应用是 Applet</li><li><strong>运行时计算生成</strong>，这种场景使用最多的是动态代理技术，在 java.lang.reflect.Proxy 类中，就是用了 ProxyGenerator.generateProxyClass 来为特定接口生成形式为 <code>*$Proxy</code> 的代理类的二进制字节流</li><li>由其它文件生成，典型应用是JSP，即由JSP文件生成对应的Class类</li><li>从数据库中获取等等</li></ul><p>所以，动态代理就是想办法，根据接口或目标对象，计算出代理类的字节码，然后再加载到JVM中使用。但是如何计算？如何生成？情况也许比想象的复杂得多，我们需要借助现有的方案。</p><h4 id="常见的字节码操作类库"><a href="#常见的字节码操作类库" class="headerlink" title="常见的字节码操作类库"></a>常见的字节码操作类库</h4><blockquote><p>这里有一些介绍：<a href="https://java-source.net/open-source/bytecode-libraries" target="_blank" rel="noopener">https://java-source.net/open-source/bytecode-libraries</a></p></blockquote><ul><li>Apache BCEL (Byte Code Engineering Library)：是Java classworking广泛使用的一种框架，它可以深入到JVM汇编语言进行类操作的细节。</li><li>ObjectWeb ASM：是一个Java字节码操作框架。它可以用于直接以二进制形式动态生成stub根类或其他代理类，或者在加载时动态修改类。</li><li>CGLIB(Code Generation Library)：是一个功能强大，高性能和高质量的代码生成库，用于扩展JAVA类并在运行时实现接口。</li><li>Javassist：是Java的加载时反射系统，它是一个用于在Java中编辑字节码的类库; 它使Java程序能够在运行时定义新类，并在JVM加载之前修改类文件。</li><li>…</li></ul><h4 id="实现动态代理的思考方向"><a href="#实现动态代理的思考方向" class="headerlink" title="实现动态代理的思考方向"></a>实现动态代理的思考方向</h4><p>为了让生成的代理类与目标对象（真实主题角色）保持一致性，从现在开始将介绍以下两种最常见的方式：</p><ol><li>通过实现接口的方式 -&gt; JDK动态代理</li><li>通过继承类的方式 -&gt; CGLIB动态代理</li></ol><p>注：使用ASM对使用者要求比较高，使用Javassist会比较麻烦</p><h3 id="JDK动态代理"><a href="#JDK动态代理" class="headerlink" title="JDK动态代理"></a>JDK动态代理</h3><p>JDK动态代理主要涉及两个类：<code>java.lang.reflect.Proxy</code> 和 <code>java.lang.reflect.InvocationHandler</code>，我们仍然通过案例来学习</p><p>编写一个调用逻辑处理器 LogHandler 类，提供日志增强功能，并实现 InvocationHandler 接口；在 LogHandler 中维护一个目标对象，这个对象是被代理的对象（真实主题角色）；在 <code>invoke</code> 方法中编写方法调用的逻辑处理</p><pre><code class="java">import java.lang.reflect.InvocationHandler;import java.lang.reflect.Method;import java.util.Date;public class LogHandler implements InvocationHandler {    Object target;  // 被代理的对象，实际的方法执行者    public LogHandler(Object target) {        this.target = target;    }    @Override    public Object invoke(Object proxy, Method method, Object[] args) throws Throwable {        before();        Object result = method.invoke(target, args);  // 调用 target 的 method 方法        after();        return result;  // 返回方法的执行结果    }    // 调用invoke方法之前执行    private void before() {        System.out.println(String.format(&quot;log start time [%s] &quot;, new Date()));    }    // 调用invoke方法之后执行    private void after() {        System.out.println(String.format(&quot;log end time [%s] &quot;, new Date()));    }}</code></pre><p>编写客户端，获取动态生成的代理类的对象须借助 Proxy 类的 newProxyInstance 方法，具体步骤可见代码和注释</p><pre><code class="java">import proxy.UserService;import proxy.UserServiceImpl;import java.lang.reflect.InvocationHandler;import java.lang.reflect.Proxy;public class Client2 {    public static void main(String[] args) throws IllegalAccessException, InstantiationException {        // 设置变量可以保存动态代理类，默认名称以 $Proxy0 格式命名        // System.getProperties().setProperty(&quot;sun.misc.ProxyGenerator.saveGeneratedFiles&quot;, &quot;true&quot;);        // 1. 创建被代理的对象，UserService接口的实现类        UserServiceImpl userServiceImpl = new UserServiceImpl();        // 2. 获取对应的 ClassLoader        ClassLoader classLoader = userServiceImpl.getClass().getClassLoader();        // 3. 获取所有接口的Class，这里的UserServiceImpl只实现了一个接口UserService，        Class[] interfaces = userServiceImpl.getClass().getInterfaces();        // 4. 创建一个将传给代理类的调用请求处理器，处理所有的代理对象上的方法调用        //     这里创建的是一个自定义的日志处理器，须传入实际的执行对象 userServiceImpl        InvocationHandler logHandler = new LogHandler(userServiceImpl);        /*           5.根据上面提供的信息，创建代理对象 在这个过程中，               a.JDK会通过根据传入的参数信息动态地在内存中创建和.class 文件等同的字节码               b.然后根据相应的字节码转换成对应的class，               c.然后调用newInstance()创建代理实例         */        UserService proxy = (UserService) Proxy.newProxyInstance(classLoader, interfaces, logHandler);        // 调用代理的方法        proxy.select();        proxy.update();        // 保存JDK动态代理生成的代理类，类名保存为 UserServiceProxy        // ProxyUtils.generateClassFile(userServiceImpl.getClass(), &quot;UserServiceProxy&quot;);    }}</code></pre><p>运行结果</p><pre><code>log start time [Thu Dec 20 16:55:19 CST 2018] 查询 selectByIdlog end time [Thu Dec 20 16:55:19 CST 2018] log start time [Thu Dec 20 16:55:19 CST 2018] 更新 updatelog end time [Thu Dec 20 16:55:19 CST 2018] </code></pre><p>InvocationHandler 和 Proxy 的主要方法介绍如下：</p><p><strong>java.lang.reflect.InvocationHandler</strong></p><p><code>Object invoke(Object proxy, Method method, Object[] args)</code> 定义了代理对象调用方法时希望执行的动作，用于集中处理在动态代理类对象上的方法调用</p><p><strong>java.lang.reflect.Proxy</strong></p><p><code>static InvocationHandler getInvocationHandler(Object proxy)</code>  用于获取指定代理对象所关联的调用处理器</p><p><code>static Class&lt;?&gt; getProxyClass(ClassLoader loader, Class&lt;?&gt;... interfaces)</code> 返回指定接口的代理类</p><p><code>static Object newProxyInstance(ClassLoader loader, Class&lt;?&gt;[] interfaces, InvocationHandler h)</code> 构造实现指定接口的代理类的一个新实例，所有方法会调用给定处理器对象的 invoke 方法</p><p><code>static boolean isProxyClass(Class&lt;?&gt; cl)</code> 返回 cl 是否为一个代理类</p><h4 id="代理类的调用过程"><a href="#代理类的调用过程" class="headerlink" title="代理类的调用过程"></a>代理类的调用过程</h4><p>生成的代理类到底长什么样子呢？借助下面的工具类，把代理类保存下来再探个究竟<br>（通过设置环境变量sun.misc.ProxyGenerator.saveGeneratedFiles=true也可以保存代理类）</p><pre><code class="java">import sun.misc.ProxyGenerator;import java.io.FileOutputStream;import java.io.IOException;public class ProxyUtils {    /**     * 将根据类信息动态生成的二进制字节码保存到硬盘中，默认的是clazz目录下     * params: clazz 需要生成动态代理类的类     * proxyName: 为动态生成的代理类的名称     */    public static void generateClassFile(Class clazz, String proxyName) {        // 根据类信息和提供的代理类名称，生成字节码        byte[] classFile = ProxyGenerator.generateProxyClass(proxyName, clazz.getInterfaces());        String paths = clazz.getResource(&quot;.&quot;).getPath();        System.out.println(paths);        FileOutputStream out = null;        try {            //保留到硬盘中            out = new FileOutputStream(paths + proxyName + &quot;.class&quot;);            out.write(classFile);            out.flush();        } catch (Exception e) {            e.printStackTrace();        } finally {            try {                out.close();            } catch (IOException e) {                e.printStackTrace();            }        }    }}</code></pre><p>然后在 Client2 测试类的main的最后面加入一行代码</p><pre><code class="java">// 保存JDK动态代理生成的代理类，类名保存为 UserServiceProxyProxyUtils.generateClassFile(userServiceImpl.getClass(), &quot;UserServiceProxy&quot;);</code></pre><p>IDEA 再次运行之后就可以在 target 的类路径下找到 UserServiceProxy.class，双击后IDEA的反编译插件会将该二进制class文件</p><p><img src="http://image.laijianfeng.org/20181220_171031.png" alt="JDK 动态代理生成的代理类"></p><p>UserServiceProxy 的代码如下所示：</p><pre><code class="java">import java.lang.reflect.InvocationHandler;import java.lang.reflect.Method;import java.lang.reflect.Proxy;import java.lang.reflect.UndeclaredThrowableException;import proxy.UserService;public final class UserServiceProxy extends Proxy implements UserService {    private static Method m1;    private static Method m2;    private static Method m4;    private static Method m0;    private static Method m3;    public UserServiceProxy(InvocationHandler var1) throws  {        super(var1);    }    public final boolean equals(Object var1) throws  {        // 省略...    }    public final String toString() throws  {        // 省略...    }    public final void select() throws  {        try {            super.h.invoke(this, m4, (Object[])null);        } catch (RuntimeException | Error var2) {            throw var2;        } catch (Throwable var3) {            throw new UndeclaredThrowableException(var3);        }    }    public final int hashCode() throws  {        // 省略...    }    public final void update() throws  {        try {            super.h.invoke(this, m3, (Object[])null);        } catch (RuntimeException | Error var2) {            throw var2;        } catch (Throwable var3) {            throw new UndeclaredThrowableException(var3);        }    }    static {        try {            m1 = Class.forName(&quot;java.lang.Object&quot;).getMethod(&quot;equals&quot;, Class.forName(&quot;java.lang.Object&quot;));            m2 = Class.forName(&quot;java.lang.Object&quot;).getMethod(&quot;toString&quot;);            m4 = Class.forName(&quot;proxy.UserService&quot;).getMethod(&quot;select&quot;);            m0 = Class.forName(&quot;java.lang.Object&quot;).getMethod(&quot;hashCode&quot;);            m3 = Class.forName(&quot;proxy.UserService&quot;).getMethod(&quot;update&quot;);        } catch (NoSuchMethodException var2) {            throw new NoSuchMethodError(var2.getMessage());        } catch (ClassNotFoundException var3) {            throw new NoClassDefFoundError(var3.getMessage());        }    }}</code></pre><p>从 UserServiceProxy 的代码中我们可以发现：</p><ul><li>UserServiceProxy 继承了 Proxy 类，并且实现了被代理的所有接口，以及equals、hashCode、toString等方法</li><li>由于 UserServiceProxy 继承了 Proxy 类，所以每个代理类都会关联一个 InvocationHandler 方法调用处理器</li><li>类和所有方法都被 <code>public final</code> 修饰，所以代理类只可被使用，不可以再被继承</li><li>每个方法都有一个 Method 对象来描述，Method 对象在static静态代码块中创建，以 <code>m + 数字</code> 的格式命名</li><li>调用方法的时候通过 <code>super.h.invoke(this, m1, (Object[])null);</code> 调用，其中的 <code>super.h.invoke</code> 实际上是在创建代理的时候传递给 <code>Proxy.newProxyInstance</code> 的 LogHandler 对象，它继承 InvocationHandler 类，负责实际的调用处理逻辑</li></ul><p>而 LogHandler 的 invoke 方法接收到 method、args 等参数后，进行一些处理，然后通过反射让被代理的对象 target 执行方法</p><pre><code class="java">    @Override    public Object invoke(Object proxy, Method method, Object[] args) throws Throwable {        before();        Object result = method.invoke(target, args);       // 调用 target 的 method 方法        after();        return result;  // 返回方法的执行结果    }</code></pre><p>JDK动态代理执行方法调用的过程简图如下：</p><p><img src="http://image.laijianfeng.org/2018_12_20_JDKProxy.png" alt="JDK动态代理执行方法调用过程"></p><p>代理类的调用过程相信大家都明了了，而关于Proxy的源码解析，还请大家另外查阅其他文章或者直接看源码</p><h3 id="CGLIB动态代理"><a href="#CGLIB动态代理" class="headerlink" title="CGLIB动态代理"></a>CGLIB动态代理</h3><p>maven引入CGLIB包，然后编写一个UserDao类，它没有接口，只有两个方法，select() 和 update()</p><pre><code class="java">public class UserDao {    public void select() {        System.out.println(&quot;UserDao 查询 selectById&quot;);    }    public void update() {        System.out.println(&quot;UserDao 更新 update&quot;);    }}</code></pre><p>编写一个 LogInterceptor ，继承了 MethodInterceptor，用于方法的拦截回调</p><pre><code class="java">import java.lang.reflect.Method;import java.util.Date;public class LogInterceptor implements MethodInterceptor {    /**     * @param object 表示要进行增强的对象     * @param method 表示拦截的方法     * @param objects 数组表示参数列表，基本数据类型需要传入其包装类型，如int--&gt;Integer、long-Long、double--&gt;Double     * @param methodProxy 表示对方法的代理，invokeSuper方法表示对被代理对象方法的调用     * @return 执行结果     * @throws Throwable     */    @Override    public Object intercept(Object object, Method method, Object[] objects, MethodProxy methodProxy) throws Throwable {        before();        Object result = methodProxy.invokeSuper(object, objects);   // 注意这里是调用 invokeSuper 而不是 invoke，否则死循环，methodProxy.invokesuper执行的是原始类的方法，method.invoke执行的是子类的方法        after();        return result;    }    private void before() {        System.out.println(String.format(&quot;log start time [%s] &quot;, new Date()));    }    private void after() {        System.out.println(String.format(&quot;log end time [%s] &quot;, new Date()));    }}</code></pre><p>测试</p><pre><code class="java">import net.sf.cglib.proxy.Enhancer;public class CglibTest {    public static void main(String[] args) {        DaoProxy daoProxy = new DaoProxy();         Enhancer enhancer = new Enhancer();        enhancer.setSuperclass(Dao.class);  // 设置超类，cglib是通过继承来实现的        enhancer.setCallback(daoProxy);        Dao dao = (Dao)enhancer.create();   // 创建代理类        dao.update();        dao.select();    }}</code></pre><p>运行结果</p><pre><code>log start time [Fri Dec 21 00:06:40 CST 2018] UserDao 查询 selectByIdlog end time [Fri Dec 21 00:06:40 CST 2018] log start time [Fri Dec 21 00:06:40 CST 2018] UserDao 更新 updatelog end time [Fri Dec 21 00:06:40 CST 2018] </code></pre><p>还可以进一步多个 MethodInterceptor 进行过滤筛选</p><pre><code class="java">public class LogInterceptor2 implements MethodInterceptor {    @Override    public Object intercept(Object object, Method method, Object[] objects, MethodProxy methodProxy) throws Throwable {        before();        Object result = methodProxy.invokeSuper(object, objects);        after();        return result;    }    private void before() {        System.out.println(String.format(&quot;log2 start time [%s] &quot;, new Date()));    }    private void after() {        System.out.println(String.format(&quot;log2 end time [%s] &quot;, new Date()));    }}// 回调过滤器: 在CGLib回调时可以设置对不同方法执行不同的回调逻辑，或者根本不执行回调。public class DaoFilter implements CallbackFilter {    @Override    public int accept(Method method) {        if (&quot;select&quot;.equals(method.getName())) {            return 0;   // Callback 列表第1个拦截器        }        return 1;   // Callback 列表第2个拦截器，return 2 则为第3个，以此类推    }}</code></pre><p>再次测试</p><pre><code class="java">public class CglibTest2 {    public static void main(String[] args) {        LogInterceptor logInterceptor = new LogInterceptor();        LogInterceptor2 logInterceptor2 = new LogInterceptor2();        Enhancer enhancer = new Enhancer();        enhancer.setSuperclass(UserDao.class);   // 设置超类，cglib是通过继承来实现的        enhancer.setCallbacks(new Callback[]{logInterceptor, logInterceptor2, NoOp.INSTANCE});   // 设置多个拦截器，NoOp.INSTANCE是一个空拦截器，不做任何处理        enhancer.setCallbackFilter(new DaoFilter());        UserDao proxy = (UserDao) enhancer.create();   // 创建代理类        proxy.select();        proxy.update();    }}</code></pre><p>运行结果</p><pre><code class="java">log start time [Fri Dec 21 00:22:39 CST 2018] UserDao 查询 selectByIdlog end time [Fri Dec 21 00:22:39 CST 2018] log2 start time [Fri Dec 21 00:22:39 CST 2018] UserDao 更新 updatelog2 end time [Fri Dec 21 00:22:39 CST 2018] </code></pre><p>CGLIB 创建动态代理类的模式是：</p><ol><li>查找目标类上的所有非final 的public类型的方法定义；</li><li>将这些方法的定义转换成字节码；</li><li>将组成的字节码转换成相应的代理的class对象；</li><li>实现 MethodInterceptor接口，用来处理对代理类上所有方法的请求</li></ol><h3 id="JDK动态代理与CGLIB动态代理对比"><a href="#JDK动态代理与CGLIB动态代理对比" class="headerlink" title="JDK动态代理与CGLIB动态代理对比"></a>JDK动态代理与CGLIB动态代理对比</h3><p>JDK动态代理：基于Java反射机制实现，必须要实现了接口的业务类才能用这种办法生成代理对象。</p><p>cglib动态代理：基于ASM机制实现，通过生成业务类的子类作为代理类。</p><p>JDK Proxy 的优势：</p><ul><li>最小化依赖关系，减少依赖意味着简化开发和维护，JDK 本身的支持，可能比 cglib 更加可靠。</li><li>平滑进行 JDK 版本升级，而字节码类库通常需要进行更新以保证在新版 Java 上能够使用。</li><li>代码实现简单。</li></ul><p>基于类似 cglib 框架的优势：</p><ul><li>无需实现接口，达到代理类无侵入</li><li>只操作我们关心的类，而不必为其他相关类增加工作量。</li><li>高性能</li></ul><h3 id="面试题"><a href="#面试题" class="headerlink" title="面试题"></a>面试题</h3><blockquote><p>来源于网上，用于帮助理解和掌握，欢迎补充</p></blockquote><h4 id="描述动态代理的几种实现方式？分别说出相应的优缺点"><a href="#描述动态代理的几种实现方式？分别说出相应的优缺点" class="headerlink" title="描述动态代理的几种实现方式？分别说出相应的优缺点"></a>描述动态代理的几种实现方式？分别说出相应的优缺点</h4><p>代理可以分为 “静态代理” 和 “动态代理”，动态代理又分为 “JDK动态代理” 和 “CGLIB动态代理” 实现。</p><p><strong>静态代理</strong>：代理对象和实际对象都继承了同一个接口，在代理对象中指向的是实际对象的实例，这样对外暴露的是代理对象而真正调用的是 Real Object</p><ul><li><strong>优点</strong>：可以很好的保护实际对象的业务逻辑对外暴露，从而提高安全性。</li><li><strong>缺点</strong>：不同的接口要有不同的代理类实现，会很冗余</li></ul><p><strong>JDK 动态代理</strong>：</p><ul><li>为了解决静态代理中，生成大量的代理类造成的冗余；</li><li>JDK 动态代理只需要实现 InvocationHandler 接口，重写 invoke 方法便可以完成代理的实现， </li><li>jdk的代理是利用反射生成代理类 Proxyxx.class 代理类字节码，并生成对象</li><li>jdk动态代理之所以<strong>只能代理接口</strong>是因为<strong>代理类本身已经extends了Proxy，而java是不允许多重继承的</strong>，但是允许实现多个接口</li></ul><ul><li><strong>优点</strong>：解决了静态代理中冗余的代理实现类问题。</li><li><strong>缺点</strong>：JDK 动态代理是基于接口设计实现的，如果没有接口，会抛异常。</li></ul><p><strong>CGLIB 代理</strong>：</p><ul><li>由于 JDK 动态代理限制了只能基于接口设计，而对于没有接口的情况，JDK方式解决不了；</li><li>CGLib 采用了非常底层的字节码技术，其原理是通过字节码技术为一个类创建子类，并在子类中采用方法拦截的技术拦截所有父类方法的调用，顺势织入横切逻辑，来完成动态代理的实现。</li><li>实现方式实现 MethodInterceptor 接口，重写 intercept 方法，通过 Enhancer 类的回调方法来实现。</li><li>但是CGLib在创建代理对象时所花费的时间却比JDK多得多，所以对于单例的对象，因为无需频繁创建对象，用CGLib合适，反之，使用JDK方式要更为合适一些。</li><li>同时，由于CGLib由于是采用动态创建子类的方法，对于final方法，无法进行代理。</li></ul><ul><li><strong>优点</strong>：没有接口也能实现动态代理，而且采用字节码增强技术，性能也不错。</li><li><strong>缺点</strong>：技术实现相对难理解些。</li></ul><h4 id="CGlib-对接口实现代理？"><a href="#CGlib-对接口实现代理？" class="headerlink" title="CGlib 对接口实现代理？"></a>CGlib 对接口实现代理？</h4><pre><code class="java">import net.sf.cglib.proxy.Enhancer;import net.sf.cglib.proxy.MethodInterceptor;import net.sf.cglib.proxy.MethodProxy;import proxy.UserService;import java.lang.reflect.Method;/** * 创建代理类的工厂 该类要实现 MethodInterceptor 接口。 * 该类中完成三样工作： * （1）声明目标类的成员变量，并创建以目标类对象为参数的构造器。用于接收目标对象 * （2）定义代理的生成方法，用于创建代理对象。方法名是任意的。代理对象即目标类的子类 * （3）定义回调接口方法。对目标类的增强这在这里完成 */public class CGLibFactory implements MethodInterceptor {    // 声明目标类的成员变量    private UserService target;    public CGLibFactory(UserService target) {        this.target = target;    }    // 定义代理的生成方法,用于创建代理对象    public UserService myCGLibCreator() {        Enhancer enhancer = new Enhancer();        // 为代理对象设置父类，即指定目标类        enhancer.setSuperclass(UserService.class);        /**         * 设置回调接口对象 注意，只所以在setCallback()方法中可以写上this，         * 是因为MethodIntecepter接口继承自Callback，是其子接口         */        enhancer.setCallback(this);        return (UserService) enhancer.create();// create用以生成CGLib代理对象    }    @Override    public Object intercept(Object obj, Method method, Object[] args, MethodProxy proxy) throws Throwable {        System.out.println(&quot;start invoke &quot; + method.getName());        Object result = method.invoke(target, args);        System.out.println(&quot;end invoke &quot; + method.getName());        return result;    }}</code></pre><blockquote><p>参考：<br>《Java核心技术》卷1<br>《深入理解Java虚拟机》7.3<br>java docs: <a href="https://docs.oracle.com/javase/8/docs/api/java/lang/reflect/Proxy.html" target="_blank" rel="noopener">https://docs.oracle.com/javase/8/docs/api/java/lang/reflect/Proxy.html</a><br><a href="https://segmentfault.com/a/1190000011291179" target="_blank" rel="noopener">Java三种代理模式：静态代理、动态代理和cglib代理</a><br><a href="http://xzc.fun/w/index.php?title=%E6%8F%8F%E8%BF%B0%E5%8A%A8%E6%80%81%E4%BB%A3%E7%90%86%E7%9A%84%E5%87%A0%E7%A7%8D%E5%AE%9E%E7%8E%B0%E6%96%B9%E5%BC%8F_%E5%88%86%E5%88%AB%E8%AF%B4%E5%87%BA%E7%9B%B8%E5%BA%94%E7%9A%84%E4%BC%98%E7%BC%BA%E7%82%B9" target="_blank" rel="noopener">描述动态代理的几种实现方式 分别说出相应的优缺点</a><br><a href="https://my.oschina.net/robinyao/blog/811193" target="_blank" rel="noopener">JDK动态代理详解</a><br><a href="https://blog.csdn.net/luanlouis/article/details/24589193" target="_blank" rel="noopener">Java动态代理机制详解（JDK 和CGLIB，Javassist，ASM）</a><br><a href="https://blog.csdn.net/WangQYoho/article/details/77584832" target="_blank" rel="noopener">静态代理和动态代理的理解</a></p></blockquote><h3 id="后记"><a href="#后记" class="headerlink" title="后记"></a>后记</h3><p>欢迎评论、转发、分享，您的支持是我最大的动力</p><p>更多内容可访问我的个人博客：<a href="http://laijianfeng.org">http://laijianfeng.org</a></p><p>关注【小旋锋】微信公众号，及时接收博文推送</p><p><img src="http://image.laijianfeng.org/20180913_001328.png" alt="关注_小旋锋_微信公众号"></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;动态代理在Java中有着广泛的应用，比如Spring AOP、Hibernate数据查询、测试框架的后端mock、RPC远程调用、Java注解对象获取、日志、用户鉴权、全局性异常处理、性能监控，甚至事务处理等。&lt;/p&gt;
&lt;p&gt;本文主要介绍Java中两种常见的动态代理方式：J
      
    
    </summary>
    
      <category term="后端" scheme="http://laijianfeng.org/categories/%E5%90%8E%E7%AB%AF/"/>
    
    
      <category term="Java编程" scheme="http://laijianfeng.org/tags/Java%E7%BC%96%E7%A8%8B/"/>
    
  </entry>
  
  <entry>
    <title>Java反射机制详解</title>
    <link href="http://laijianfeng.org/2018/12/Java%E5%8F%8D%E5%B0%84%E6%9C%BA%E5%88%B6%E8%AF%A6%E8%A7%A3/"/>
    <id>http://laijianfeng.org/2018/12/Java反射机制详解/</id>
    <published>2018-12-18T18:08:32.000Z</published>
    <updated>2018-12-18T18:09:19.243Z</updated>
    
    <content type="html"><![CDATA[<p>对于一般的开发者，很少需要直接使用Java反射机制来完成功能开发，但是反射是很多框架譬如 Spring， Mybatis 实现的核心，反射虽小，能量却很大。</p><p>本文主要介绍反射相关的概念以及API的使用，关于反射的应用将在下一篇文章中介绍</p><h3 id="反射的介绍"><a href="#反射的介绍" class="headerlink" title="反射的介绍"></a>反射的介绍</h3><p><strong>反射(Reflection)</strong> 是 Java 在运行时（Run time）可以访问、检测和修改它本身状态或行为的一种能力，它允许运行中的 Java 程序获取自身的信息，并且可以操作类或对象的内部属性。</p><p><strong>Class 类介绍</strong>：Java虚拟机为每个类型管理一个Class对象，包含了与类有关的信息，当通过 javac 编译Java类文件时，生成的同名 .class 文件保存着该类的 Class 对象，JVM 加载一个类即是加载该 .class 文件。</p><p><code>Class</code> 和 <code>java.lang.reflect</code> 一起对反射提供了支持，java.lang.reflect 包中最常用的几个类的关系如下：</p><p><img src="http://image.laijianfeng.org/20181218_182511.png" alt="reflect package"></p><p>其中最主要的三个类 <code>Field</code>、<code>Method</code> 和 <code>Constructor</code> 分别用于描述类的域、方法和构造器，它们有一个共同的父类 <code>AccessibleObject</code>，它提供了访问控制检查的功能。</p><ul><li>Field ：描述类的域（属性），可以使用 get() 和 set() 方法读取和修改 Field 对象关联的字段；</li><li>Method ：描述类的方法，可以使用 invoke() 方法调用与 Method 对象关联的方法；</li><li>Constructor ：描述类的构造器，可以用 Constructor 创建新的对象。</li></ul><p>下面将通过几个程序来学习Java反射机制。</p><h3 id="准备两个类用于实验"><a href="#准备两个类用于实验" class="headerlink" title="准备两个类用于实验"></a>准备两个类用于实验</h3><p>我们特别定义两个类，Person和Employee，其中Employee继承自Person，且各自都有一个private，protected，public修饰的域（属性），Employee还有private，public修饰的方法</p><pre><code class="java">public class Person {    public String name; // 姓名 公有    protected String age;   // 年龄 保护    private String hobby;   // 爱好   私有    public Person(String name, String age, String hobby) {        this.name = name;        this.age = age;        this.hobby = hobby;    }    public String getHobby() {        return hobby;    }}public class Employee extends Person {    public static Integer totalNum = 0; // 员工数    public int empNo;   // 员工编号 公有    protected String position;  // 职位 保护    private int salary; // 工资   私有    public void sayHello() {        System.out.println(String.format(&quot;Hello, 我是 %s, 今年 %s 岁, 爱好是%s, 我目前的工作是%s, 月入%s元\n&quot;, name, age, getHobby(), position, salary));    }    private void work() {        System.out.println(String.format(&quot;My name is %s, 工作中勿扰.&quot;, name));    }    public Employee(String name, String age, String hobby, int empNo, String position, int salary) {        super(name, age, hobby);        this.empNo = empNo;        this.position = position;        this.salary = salary;        Employee.totalNum++;    }}</code></pre><h3 id="获取-Class-对象"><a href="#获取-Class-对象" class="headerlink" title="获取 Class 对象"></a>获取 Class 对象</h3><p>获取 Class 对象的方式有三种：使用 Class 类的 forName 静态方法；直接获取某一个对象的 class；调用某个对象的 getClass() 方法</p><pre><code>public class ClassTest {    public static void main(String[] args) throws ClassNotFoundException, IllegalAccessException, InstantiationException {        Class c1 = Class.forName(&quot;reflect.Employee&quot;);   // 第1种，forName 方式获取Class对象        Class c2 = Employee.class;      // 第2种，直接通过类获取Class对象        Employee employee = new Employee(&quot;小明&quot;, &quot;18&quot;, &quot;写代码&quot;, 1, &quot;Java攻城狮&quot;, 100000);        Class c3 = employee.getClass();    // 第3种，通过调用对象的getClass()方法获取Class对象        if (c1 == c2 &amp;&amp; c1 == c3) {     // 可以通过 == 比较Class对象是否为同一个对象            System.out.println(&quot;c1、c2、c3 为同一个对象&quot;);            System.out.println(c1);     // class reflect.Employee        }    }}</code></pre><h4 id="通过反射来创建实例"><a href="#通过反射来创建实例" class="headerlink" title="通过反射来创建实例"></a>通过反射来创建实例</h4><p>通过反射来生成对象主要有两种方式</p><ul><li>使用Class对象的newInstance()方法来创建Class对象对应类的实例</li><li>先通过Class对象获取指定的Constructor对象，再调用Constructor对象的newInstance()方法来创建实例</li></ul><pre><code class="java">public class NewInstanceTest {    public static void main(String[] args) throws IllegalAccessException, InstantiationException, NoSuchMethodException, InvocationTargetException {        Class c = Date.class;        Date date1 = (Date) c.newInstance();    // 第1种方式：使用Class对象的newInstance()方法来创建Class对象对应类的实例        System.out.println(date1);      // Wed Dec 19 22:57:16 CST 2018        long timestamp =date1.getTime();        Constructor constructor = c.getConstructor(long.class);         Date date2 = (Date)constructor.newInstance(timestamp);  // 第2种方式：先通过Class对象获取指定的Constructor对象，再调用Constructor对象的newInstance()方法来创建实例        System.out.println(date2);  // Wed Dec 19 22:57:16 CST 2018    }}</code></pre><h3 id="获取类的全部信息"><a href="#获取类的全部信息" class="headerlink" title="获取类的全部信息"></a>获取类的全部信息</h3><p>上面我们定义了两个类，现在有个需求：获取Employee的类名，构造器签名，所有的方法，所有的域（属性）和值，然后打印出来。该通过什么方式来实现呢？</p><p>没错，猜对了，就是通过反射来获取这些类的信息，在上面介绍中我们知道JVM虚拟机为每个类型管理一个Class对象，</p><p>为了完成我们的需求，我们需要知道一些API如下：</p><h4 id="获取类信息的部分API"><a href="#获取类信息的部分API" class="headerlink" title="获取类信息的部分API"></a>获取类信息的部分API</h4><p><code>String getName()</code> 获取这个Class的类名</p><p><code>Constructor[] getDeclaredConstructors()</code> 返回这个类的所有构造器的对象数组，包含保护和私有的构造器；相近的方法 getConstructors() 则返回这个类的所有<strong>公有</strong>构造器的对象数组，不包含保护和私有的构造器</p><p><code>Method[] getDeclaredMethods()</code> 返回这个类或接口的所有方法，包括保护和私有的方法，不包括超类的方法；相近的方法 getMethods() 则返回这个类及其超类的<strong>公有</strong>方法的对象数组，不含保护和私有的方法</p><p><code>Field[] getDeclaredFields()</code> 返回这个类的所有域的对象数组，包括保护域和私有域，不包括超类的域；还有一个相近的API <code>getFields()</code>，返回这个类及其超类的<strong>公有</strong>域的对象数组，不含保护域和私有域</p><p><code>int getModifiers()</code> 返回一个用于描述Field、Method和Constructor的<strong>修饰符</strong>的整形数值，该数值代表的含义可通过Modifier这个类分析</p><p><code>Modifier 类</code> 它提供了有关Field、Method和Constructor等的访问修饰符的信息，主要的方法有：toString(int modifiers)返回整形数值modifiers代表的修饰符的字符串；isAbstract是否被abstract修饰；isVolatile是否被volatile修饰；isPrivate是否为private；isProtected是否为protected；isPublic是否为public；isStatic是否为static修饰；等等，见名知义</p><h4 id="打印类信息程序"><a href="#打印类信息程序" class="headerlink" title="打印类信息程序"></a>打印类信息程序</h4><pre><code class="java">public class ReflectionTest {    public static void main(String[] args) throws ClassNotFoundException {        String name;        if (args.length &gt; 0) {            name = args[0];        } else {            Scanner in = new Scanner(System.in);            System.out.println(&quot;输入一个类名（e.g. java.util.Date）：&quot;); // reflect.Employee            name = in.next();        }        try {            Class cl = Class.forName(name);            Class superCl = cl.getSuperclass();            String modifiers = Modifier.toString(cl.getModifiers());            if (modifiers.length() &gt; 0) {                System.out.print(modifiers + &quot; &quot;);            }            System.out.print(&quot;class &quot; + name);            if (superCl != null &amp;&amp; superCl != Object.class) {                System.out.print(&quot; extends &quot; + superCl.getName());            }            System.out.println(&quot;\n{&quot;);            printConstructors(cl); // 打印构造方法            System.out.println();            printMethods(cl);   // 打印方法            System.out.println();            printFields(cl);    // 打印属性            System.out.println(&quot;}&quot;);        } catch (ClassNotFoundException e) {            e.printStackTrace();        }        System.exit(0);    }    /**     * 打印Class对象的所有构造方法     */    public static void printConstructors(Class cl) {        Constructor[] constructors = cl.getDeclaredConstructors();        for (Constructor c : constructors) {            String name = c.getName();            System.out.print(&quot;  &quot;);            String modifiers = Modifier.toString(c.getModifiers());            if (modifiers.length() &gt; 0) {                System.out.print(modifiers + &quot; &quot;);            }            System.out.print(name + &quot;(&quot;);            // 打印构造参数            Class[] paramTypes = c.getParameterTypes();            for (int i = 0; i &lt; paramTypes.length; i++) {                if (i &gt; 0) {                    System.out.print(&quot;, &quot;);                }                System.out.print(paramTypes[i].getName());            }            System.out.println(&quot;);&quot;);        }    }    /**     * 打印Class的所有方法     */    public static void printMethods(Class cl) {        Method[] methods = cl.getDeclaredMethods();        //Method[] methods = cl.getMethods();        for (Method m : methods) {            Class retType = m.getReturnType();  // 返回类型            System.out.print(&quot;  &quot;);            String modifiers = Modifier.toString(m.getModifiers());            if (modifiers.length() &gt; 0) {                System.out.print(modifiers + &quot; &quot;);            }            System.out.print(retType.getName() + &quot; &quot; + m.getName() + &quot;(&quot;);            Class[] paramTypes = m.getParameterTypes();            for (int i = 0; i &lt; paramTypes.length; i++) {                if (i &gt; 0) {                    System.out.print(&quot;, &quot;);                }                System.out.print(paramTypes[i].getName());            }            System.out.println(&quot;);&quot;);        }    }    /**     * 打印Class的所有属性     */    public static void printFields(Class cl) {        Field[] fields = cl.getDeclaredFields();        for (Field f: fields) {            Class type = f.getType();            System.out.print(&quot;  &quot;);            String modifiers = Modifier.toString(f.getModifiers());            if (modifiers.length()&gt; 0) {                System.out.print(modifiers + &quot; &quot;);            }            System.out.println(type.getName() + &quot; &quot; + f.getName() + &quot;;&quot;);        }    }}</code></pre><p>运行程序，然后在控制台输入一个我们想分析的类的全名，譬如 reflect.Employee，可得到下面的输出</p><pre><code>输入一个类名（e.g. java.util.Date）：reflect.Employeepublic class reflect.Employee extends reflect.Person{  private reflect.Employee(java.lang.String, java.lang.String, java.lang.String);  public reflect.Employee(java.lang.String, java.lang.String, java.lang.String, int, java.lang.String, int);  public static void main([Ljava.lang.String;);  public void sayHello();  private void work();  public static java.lang.Integer totalNum;  public int empNo;  protected java.lang.String position;  private int salary;}</code></pre><p>上面的输出中我们得到的类的构造器，所有方法和所有的域（属性），包括修饰符，名称和参数类型都是准确的，看来反射机制能完成我们的需求。</p><p>小结一下，我们通过 getDeclaredConstructors() 获取构造器信息，通过 getDeclaredMethods() 获得方法信息，通过 getDeclaredFields() 获得域信息，再通过 getModifiers() 和 Modifier类 获得修饰符信息，汇总起来就得到了整个类的类信息。</p><h3 id="运行时查看对象数据域的实际内容"><a href="#运行时查看对象数据域的实际内容" class="headerlink" title="运行时查看对象数据域的实际内容"></a>运行时查看对象数据域的实际内容</h3><p>上面我们已经获取到了类的信息，现在又有一个需求：在运行时查看对象的数据域的实际值。这个场景就像我们通过IDEA调试程序，设置断点拦截到程序后，查看某个对象的属性的值。</p><p>我们知道java反射机制提供了查看类信息的API，那么它应该也提供了查看Field域实际值和设置Field域实际值的API，没错，猜对了，确实有相关的API，但是有个疑问，有一些属性是private修饰的私有域，这种是否也能直接查看和设置呢？看完下面的API即可知道答案</p><h4 id="运行时查看对象数据域实际内容的相关API"><a href="#运行时查看对象数据域实际内容的相关API" class="headerlink" title="运行时查看对象数据域实际内容的相关API"></a>运行时查看对象数据域实际内容的相关API</h4><p><code>Class&lt;?&gt; getComponentType()</code> 返回数组类里组件类型的 Class，如果不是数组类则返回null</p><p><code>boolean isArray()</code> 返回这个类是否为数组，同类型的API还有 isAnnotation、isAsciiDigit、isEnum、isInstance、isInterface、isLocalClass、isPrimitive 等</p><p><code>int Array.getLength(obj)</code> 返回数组对象obj的长度</p><p><code>Object Array.get(obj, i)</code> 获取数组对象下标为i的元素</p><p><code>boolean isPrimitive()</code> 返回这个类是否为8种基本类型之一，即是否为boolean, byte, char, short, int, long, float, 和double 等原始类型</p><p><code>Field getField(String name)</code> 获取指定名称的域对象</p><p><code>AccessibleObject.setAccessible(fields, true)</code> 当访问 Field、Method 和 Constructor 的时候Java会执行访问检查，如果访问者没有权限将抛出SecurityException，譬如访问者是无法访问private修饰的域的。通过设置 setAccessible(true) 可以取消Java的执行访问检查，这样访问者就获得了指定 Field、Method 或 Constructor 访问权限</p><p><code>Class&lt;?&gt; Field.getType()</code> 返回一个Class 对象，它标识了此 Field 对象所表示字段的声明类型</p><p><code>Object Field.get(Object obj)</code> 获取obj对象上当前域对象表示的属性的实际值，获取到的是一个Object对象，实际使用中还需要转换成实际的类型，或者可以通过 getByte()、getChar、getInt() 等直接获取具体类型的值</p><p><code>void Field.set(Object obj, Object value)</code> 设置obj对象上当前域表示的属性的实际值</p><h4 id="查看对象数据域实际内容程序"><a href="#查看对象数据域实际内容程序" class="headerlink" title="查看对象数据域实际内容程序"></a>查看对象数据域实际内容程序</h4><p>了解完上述相关API之后，我们敲出下面的程序来验证</p><pre><code class="java">public class ObjectAnalyzer {    private ArrayList&lt;Object&gt; visited = new ArrayList&lt;&gt;();    public String toString(Object obj) {        if (obj == null) {            return &quot;null&quot;;        }        if (visited.contains(obj)) {    // 如果该对象已经处理过，则不再处理            return &quot;...&quot;;        }        visited.add(obj);        Class cl = obj.getClass(); // 获取Class对象        if (cl == String.class) {   // 如果是String类型则直接转为String            return (String) obj;        }        if (cl.isArray()) {        // 如果是数组            String r = cl.getComponentType() + &quot;[]{\n&quot;;     // 数组的元素的类型            for (int i = 0; i &lt; Array.getLength(obj); i++) {                if (i &gt; 0) {   // 不是数组的第一个元素加逗号和换行，显示更加美观                    r += &quot;,\n&quot;;                }                r += &quot;\t&quot;;                Object val = Array.get(obj, i);                if (cl.getComponentType().isPrimitive()) { // Class为8种基本类型的时候为 true，直接输出                    r += val;                } else {                    r += toString(val); // 不是8中基本类型时，说明是类，递归调用toString                }            }            return r + &quot;\n}&quot;;        }        // 既不是String，也不是数组时，输出该对象的类型和属性值        String r = cl.getName();        do {            r += &quot;[&quot;;            Field[] fields = cl.getDeclaredFields();    // 获取该类自己定义的所有域，包括私有的，不包括父类的            AccessibleObject.setAccessible(fields, true); // 访问私有的属性，需要打开这个设置，否则会报非法访问异常            for (Field f : fields) {                if (!Modifier.isStatic(f.getModifiers())) { // 通过 Modifier 可获取该域的修饰符，这里判断是否为 static                    if (!r.endsWith(&quot;[&quot;)) {                        r += &quot;,&quot;;                    }                    r += f.getName() + &quot;=&quot;;     // 域名称                    try {                        Class t = f.getType();  // 域（属性）的类型                        Object val = f.get(obj);   // 获取obj对象上该域的实际值                        if (t.isPrimitive()) {     // 如果类型为8种基本类型，则直接输出                            r += val;                        } else {                            r += toString(val);     // 不是8种基本类型，递归调用toString                        }                    } catch (IllegalAccessException e) {                        e.printStackTrace();                    }                }            }            r += &quot;]&quot;;            cl = cl.getSuperclass(); // 继续打印超类的类信息        } while (cl != null);        return r;    }}</code></pre><h4 id="测试验证结果"><a href="#测试验证结果" class="headerlink" title="测试验证结果"></a>测试验证结果</h4><p>接下来验证一下获取数据域实际值是否正确，分别打印数组、自定义类的对象的实际值</p><pre><code class="java">public class ObjectAnalyzerTest {    public static void main(String[] args) {        int size = 4;        ArrayList&lt;Integer&gt; squares = new ArrayList&lt;&gt;(size);        for (int i = 0; i &lt; size; i++) {            squares.add(i * i);        }        ObjectAnalyzer objectAnalyzer = new ObjectAnalyzer(); // 创建一个上面定义的分析类ObjectAnalyzer的对象        System.out.println(objectAnalyzer.toString(squares)); // 分析ArrayList&lt;Integer&gt;对象的实际值        Employee employee = new Employee(&quot;小明&quot;, &quot;18&quot;, &quot;爱好写代码&quot;, 1, &quot;Java攻城狮&quot;, 100); // 分析自定义类Employee的对象的实际值        System.out.println(objectAnalyzer.toString(employee));    }}</code></pre><p>输出如下</p><pre><code class="java">java.util.ArrayList[elementData=class java.lang.Object[]{    java.lang.Integer[value=0][][],    java.lang.Integer[value=1][][],    java.lang.Integer[value=4][][],    java.lang.Integer[value=9][][]},size=4][modCount=4][][]reflect.Employee[empNo=1,position=Java攻城狮,salary=100][name=小明,age=18,hobby=爱好写代码][]</code></pre><p>其中<code>ArrayList&lt;Integer&gt;</code>打印了类名和5个元素的类型和值，<code>Employee</code> 打印了类名，自己定义的3个基本类型的属性的实际值，和父类Person的3个基本类型的属性的实际值</p><p>需要注意的是，position，age 是 protected 保护域，salary，hobby 是 private 私有域，Java的安全机制只允许查看任意对象有哪些域，但是不允许读取它们的值</p><p>程序中是通过 <code>AccessibleObject.setAccessible(fields, true)</code> 将域设置为了可访问，取消了Java的执行访问检查，因此可以访问，如果不加会报异常 IllegalAccessException</p><p>小结一下，我们通过 setAccessible(true) 绕过了Java执行访问检查，因此能够访问私有域，通过 Field.getType() 获得了属性的声明类型，通过了 Field.get(Object obj) 获得了该域属性的实际值，还有一个没用上的 Field.set(Object obj, Object value) 设置域属性的实际值</p><h3 id="调用任意方法"><a href="#调用任意方法" class="headerlink" title="调用任意方法"></a>调用任意方法</h3><p>上面我们已经获取了类的构造器，方法，域，查看和设置了域的实际值，那么是不是还可以在调用对象的方法呢？嘿嘿，又猜对了，机智，类的方法信息，获取都获取了，当然就要调用一下，来都来了</p><p>上面查看Field的实际值是通过 Field 类的 get() 方法，与之类似，Method 调用方法是通过 Method 类的 invoke 方法 </p><h4 id="调用任意方法相关的API"><a href="#调用任意方法相关的API" class="headerlink" title="调用任意方法相关的API"></a>调用任意方法相关的API</h4><p><code>Method getMethod(String name, Class&lt;?&gt;... parameterTypes)</code> 获取指定的 Method，参数 name 为要获取的方法名，parameterTypes 为指定方法的参数的 Class，由于可能存在多个同名的重载方法，所以只有提供正确的 parameterTypes 才能准确的获取到指定的 Method</p><p><code>Object invoke(Object obj, Object... args)</code> 执行方法，第一个参数执行该方法的对象，如果是static修饰的类方法，则传null即可；后面是传给该方法执行的具体的参数值</p><h4 id="调用任意方法程序"><a href="#调用任意方法程序" class="headerlink" title="调用任意方法程序"></a>调用任意方法程序</h4><pre><code class="java">public class MethodTableTest {    public static void main(String[] args) throws NoSuchMethodException, InvocationTargetException, IllegalAccessException {        Employee employee = new Employee(&quot;小明&quot;, &quot;18&quot;, &quot;写代码&quot;, 1, &quot;Java攻城狮&quot;, 100000);        Method sayHello = employee.getClass().getMethod(&quot;sayHello&quot;);        System.out.println(sayHello);   // 打印 sayHello 的方法信息        sayHello.invoke(employee);      // 让 employee 执行 sayHello 方法        double x = 3.0;        Method square = MethodTableTest.class.getMethod(&quot;square&quot;, double.class);  // 获取 MethodTableTest 的square方法        double y1 = (double) square.invoke(null, x);    // 调用类方法 square 求平方，方法参数 x         System.out.printf(&quot;square    %-10.4f -&gt; %10.4f%n&quot;, x, y1);        Method sqrt = Math.class.getMethod(&quot;sqrt&quot;, double.class);   // 获取 Math 的 sqrt 方法        double y2 = (double) sqrt.invoke(null, x);  // 调用类方法 sqrt 求根，方法参数 x         System.out.printf(&quot;sqrt      %-10.4f -&gt; %10.4f%n&quot;, x, y2);    }    // static静态方法 计算乘方    public static double square(double x) {        return x * x;    }}</code></pre><p>执行结果</p><pre><code>public void reflect.Employee.sayHello()Hello, 我是 小明, 今年 18 岁, 爱好是写代码, 我目前的工作是Java攻城狮, 月入100000元square    3.0000     -&gt;     9.0000sqrt      3.0000     -&gt;     1.7321</code></pre><p>相信大家都看懂啦，通过 getMethod() 获取指定的 Method，再调用 Method.invoke() 执行该方法</p><h3 id="反射的优缺点"><a href="#反射的优缺点" class="headerlink" title="反射的优缺点"></a>反射的优缺点</h3><h4 id="反射的优点："><a href="#反射的优点：" class="headerlink" title="反射的优点："></a>反射的优点：</h4><ul><li><p><strong>可扩展性</strong> ：应用程序可以利用全限定名创建可扩展对象的实例，来使用来自外部的用户自定义类。</p></li><li><p><strong>类浏览器和可视化开发环境</strong> ：一个类浏览器需要可以枚举类的成员。可视化开发环境（如 IDE）可以从利用反射中可用的类型信息中受益，以帮助程序员编写正确的代码。</p></li><li><p><strong>调试器和测试工具</strong> ： 调试器需要能够检查一个类里的私有成员。测试工具可以利用反射来自动地调用类里定义的可被发现的 API 定义，以确保一组测试中有较高的代码覆盖率。</p></li></ul><h4 id="反射的缺点："><a href="#反射的缺点：" class="headerlink" title="反射的缺点："></a>反射的缺点：</h4><p>尽管反射非常强大，但也不能滥用。如果一个功能可以不用反射完成，那么最好就不用。在我们使用反射技术时，下面几条内容应该牢记于心。</p><ul><li><p><strong>性能开销</strong> ：反射涉及了动态类型的解析，所以 JVM 无法对这些代码进行优化。因此，反射操作的效率要比那些非反射操作低得多。我们应该避免在经常被执行的代码或对性能要求很高的程序中使用反射。</p></li><li><p><strong>安全限制</strong> ：使用反射技术要求程序必须在一个没有安全限制的环境中运行。如果一个程序必须在有安全限制的环境中运行，如 Applet，那么这就是个问题了。</p></li><li><p><strong>内部暴露</strong> ：由于反射允许代码执行一些在正常情况下不被允许的操作（比如访问私有的属性和方法），所以使用反射可能会导致意料之外的副作用，这可能导致代码功能失调并破坏可移植性。反射代码破坏了抽象性，因此当平台发生改变的时候，代码的行为就有可能也随着变化。</p></li></ul><blockquote><p>参考：<br>《Java核心技术》卷一<br><a href="https://github.com/CyC2018/CS-Notes/blob/master/docs/notes/Java%20%E5%9F%BA%E7%A1%80.md#%E4%B8%83%E5%8F%8D%E5%B0%84" target="_blank" rel="noopener">https://github.com/CyC2018/CS-Notes/blob/master/docs/notes/Java%20%E5%9F%BA%E7%A1%80.md#%E4%B8%83%E5%8F%8D%E5%B0%84</a>   </p></blockquote><p><img src="http://image.laijianfeng.org/20180913_001328.png" alt="关注_小旋锋_微信公众号"></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;对于一般的开发者，很少需要直接使用Java反射机制来完成功能开发，但是反射是很多框架譬如 Spring， Mybatis 实现的核心，反射虽小，能量却很大。&lt;/p&gt;
&lt;p&gt;本文主要介绍反射相关的概念以及API的使用，关于反射的应用将在下一篇文章中介绍&lt;/p&gt;
&lt;h3 id=
      
    
    </summary>
    
      <category term="后端" scheme="http://laijianfeng.org/categories/%E5%90%8E%E7%AB%AF/"/>
    
    
      <category term="Java编程" scheme="http://laijianfeng.org/tags/Java%E7%BC%96%E7%A8%8B/"/>
    
  </entry>
  
  <entry>
    <title>Spark SQL 分析 Nginx 访问日志</title>
    <link href="http://laijianfeng.org/2018/12/Spark-SQL-%E5%88%86%E6%9E%90-Imooc-%E8%AE%BF%E9%97%AE%E6%97%A5%E5%BF%97/"/>
    <id>http://laijianfeng.org/2018/12/Spark-SQL-分析-Imooc-访问日志/</id>
    <published>2018-12-16T11:45:35.000Z</published>
    <updated>2018-12-16T15:15:35.531Z</updated>
    
    <content type="html"><![CDATA[<h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><h3 id="项目地址"><a href="#项目地址" class="headerlink" title="项目地址"></a>项目地址</h3><p><a href="https://github.com/whirlys/BigData-In-Practice/tree/master/ImoocLogAnalysis" target="_blank" rel="noopener">Spark SQL 分析 Imooc 访问日志</a></p><h3 id="环境说明"><a href="#环境说明" class="headerlink" title="环境说明"></a>环境说明</h3><ul><li>Java版本：1.8</li><li>Scala版本：2.11.12</li><li>Hadoop版本：hadoop-2.6.0-cdh5.14.0</li><li>spark版本：spark-2.3.1-bin-2.6.0-cdh5.14.0（自己编译）</li><li>MySQL版本：5.7.22</li><li>zeppelin版本：0.8</li></ul><h3 id="数据集"><a href="#数据集" class="headerlink" title="数据集"></a>数据集</h3><p><strong>Imooc 访问日志文件</strong>：access.20161111.log     </p><p><strong>数据量</strong>：一千多万条访问日志、5G多   </p><p><strong>日志格式</strong>：   </p><pre><code>60.165.39.1 - - [10/Nov/2016:00:01:53 +0800] &quot;POST /course/ajaxmediauser HTTP/1.1&quot; 200 54 &quot;www.imooc.com&quot; &quot;http://www.imooc.com/code/1431&quot; mid=1431&amp;time=60 &quot;Mozilla/5.0 (Windows NT 6.1; WOW64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/38.0.2125.122 Safari/537.36 SE 2.X MetaSr 1.0&quot; &quot;-&quot; 10.100.136.64:80 200 0.014 0.01414.145.74.175 - - [10/Nov/2016:00:01:53 +0800] &quot;POST /course/ajaxmediauser/ HTTP/1.1&quot; 200 54 &quot;www.imooc.com&quot; &quot;http://www.imooc.com/video/678&quot; mid=678&amp;time=60&amp;learn_time=551.5 &quot;Mozilla/5.0 (Windows NT 6.1; WOW64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/45.0.2454.101 Safari/537.36&quot; &quot;-&quot; 10.100.136.64:80 200 0.014 0.014</code></pre><p><strong>百度云盘下载地址</strong>：链接：<a href="https://pan.baidu.com/s/1VfOG14mGW4P4kj20nzKx8g" target="_blank" rel="noopener">https://pan.baidu.com/s/1VfOG14mGW4P4kj20nzKx8g</a> 提取码：uwjg    </p><p><strong>开发测试数据</strong>：access.1w.log（10000条）   </p><h3 id="需求"><a href="#需求" class="headerlink" title="需求"></a>需求</h3><ul><li>统计某天最受欢迎的TopN课程</li><li>统计某天各个省市各自的 TopN 课程</li><li>按照流量进行统计 TopN 课程</li><li>某天最受欢迎的文章</li><li>某天进行code最多的课程</li><li>统计某天最勤奋的 IP</li><li>欢迎补充……</li></ul><h3 id="统计结果可视化-zeppelin展示"><a href="#统计结果可视化-zeppelin展示" class="headerlink" title="统计结果可视化(zeppelin展示)"></a>统计结果可视化(zeppelin展示)</h3><p><img src="https://user-gold-cdn.xitu.io/2018/12/16/167b6d3d71368a66?w=1861&amp;h=606&amp;f=png&amp;s=71269" alt=""></p><p><img src="https://user-gold-cdn.xitu.io/2018/12/16/167b6d42299204f6?w=1852&amp;h=603&amp;f=png&amp;s=57034" alt=""></p><p><img src="https://user-gold-cdn.xitu.io/2018/12/16/167b6d470fdc4e51?w=1856&amp;h=602&amp;f=png&amp;s=53017" alt=""></p><p><img src="https://user-gold-cdn.xitu.io/2018/12/16/167b6d4b68b1a130?w=1856&amp;h=613&amp;f=png&amp;s=38529" alt=""></p><h2 id="开发步骤"><a href="#开发步骤" class="headerlink" title="开发步骤"></a>开发步骤</h2><h3 id="数据清洗"><a href="#数据清洗" class="headerlink" title="数据清洗"></a>数据清洗</h3><p>根据需求，从日志中解析出我们需要的信息，譬如可能有：</p><ol><li>访问的系统属性： 操作系统、浏览器等等</li><li>访问特征：url、referer (从哪个url跳转过来的)、页面上的停留时间等</li><li>访问信息：session_id、访问ip(访问城市)等</li></ol><h4 id="主程序"><a href="#主程序" class="headerlink" title="主程序"></a>主程序</h4><ul><li><p>SparkStatFormatJob.scala  第一步，清洗出 ip, time, url, traffic</p></li><li><p>SparkStatCleanJob.scala 第二步，最终清洗转换得到  url、cmsType、cmsId、traffic、ip、city、time、day</p></li><li>AccessConvertUtil.scala 定义DataFrame schema，将日志信息转为对象，帮助RDD转为DataFrame</li><li>DateUtils.scala 时间格式转换</li></ul><h4 id="步骤"><a href="#步骤" class="headerlink" title="步骤"></a>步骤</h4><ol><li>使用 Spark SQL 解析访问日志</li><li>解析出课程编号类型</li><li>根据IP解析出城市名称</li><li>使用 Spark SQL 将访问时间按天进行分区输出</li></ol><h4 id="关键代码"><a href="#关键代码" class="headerlink" title="关键代码"></a>关键代码</h4><p>清洗第一步</p><pre><code class="scala">accessFile.map(line =&gt; {      val splits = line.split(&quot; &quot;) // 按空格分割      val ip = splits(0) // 第一个是IP      // 原始日志的第三个和第四个字段拼接起来就是完整的访问时间： [10/Nov/2016:00:01:02 +0800] ==&gt; yyyy-MM-dd HH:mm:ss      val time = splits(3) + &quot; &quot; + splits(4)      val url = splits(11).replaceAll(&quot;\&quot;&quot;, &quot;&quot;) // 第11个是 URL      val traffic = splits(9) // 第9个是流量      List(DateUtils.parse(time), url, traffic, ip)    })      // 过滤      .filter(item =&gt; !&quot;10.100.0.1&quot;.equals(item(3)))      .filter(item =&gt; !&quot;-&quot;.equals(item(1)))      // 拼成一个对象 (DateUtils.parse(time), url, traffic, ip)      .map(item =&gt; item(0) + &quot;\t&quot; + item(1) + &quot;\t&quot; + item(2) + &quot;\t&quot; + item(3))      // 保存      .saveAsTextFile(Constants.protocol + Constants.tempOut)</code></pre><p>清洗第二步</p><pre><code>val filterRDD = accessRDD.map(line =&gt; AccessConvertUtil.parseLog(line))val accessDF = spark.createDataFrame(filterRDD, AccessConvertUtil.struct)// 保存到 parquetaccessDF.coalesce(1).write.format(&quot;parquet&quot;).mode(SaveMode.Overwrite).partitionBy(&quot;day&quot;).save(Constants.protocol + Constants.cleanedOut)</code></pre><p>清洗结果样例</p><pre><code>+--------------------------------------------+-------+-----+-------+---------------+----+-------------------+--------+|url                                         |cmsType|cmsId|traffic|ip             |city|time               |day     |+--------------------------------------------+-------+-----+-------+---------------+----+-------------------+--------+|http://www.imooc.com/code/1852              |code   |1852 |2345   |117.35.88.11   |陕西省 |2016-11-10 00:01:02|20161110||http://www.imooc.com/learn/85/?src=360onebox|learn  |85   |14531  |115.34.187.133 |北京市 |2016-11-10 00:01:27|20161110||http://www.imooc.com/course/list?c=fetool   |course |0    |66     |120.198.231.151|广东省 |2016-11-10 00:01:27|20161110||http://www.imooc.com/code/10047             |code   |10047|54     |101.36.73.155  |北京市 |2016-11-10 00:01:27|20161110|+--------------------------------------------+-------+-----+-------+---------------+----+-------------------+--------+</code></pre><h3 id="Spark-SQL-统计-TopN"><a href="#Spark-SQL-统计-TopN" class="headerlink" title="Spark SQL 统计 TopN"></a>Spark SQL 统计 TopN</h3><h4 id="主程序-1"><a href="#主程序-1" class="headerlink" title="主程序"></a>主程序</h4><ul><li>TopNStatJob.scala Spark SQL 统计主类</li><li>StatDao.scala 将各个统计作业的统计结果写到数据库</li><li>MySQLUtils.scala 管理 MySQL JDBC 连接</li></ul><h4 id="关键代码-1"><a href="#关键代码-1" class="headerlink" title="关键代码"></a>关键代码</h4><pre><code class="scala">/**  * 统计某天各个省市各自的 TopN 课程  */def cityAccessTopNStat(spark: SparkSession, accessDF: DataFrame, day: String): Unit = {  import spark.implicits._  val cityAccessTopNDF = accessDF.filter($&quot;day&quot; === day &amp;&amp; $&quot;cmsType&quot; === &quot;video&quot; &amp;&amp; $&quot;cmsId&quot; =!= &quot;0&quot;)    .groupBy(&quot;city&quot;, &quot;day&quot;, &quot;cmsId&quot;)    .agg(count(&quot;cmsId&quot;).as(&quot;times&quot;))  // Window 函数在Spark SQL的使用: 窗口函数 row_number 的作用是根据表中字段进行分组，然后根据表中的字段排序，  //  给组中的每条记录添加一个序号；且每组的序号都是从1开始，可利用它的这个特性进行分组取top-n  val top3DF = cityAccessTopNDF.select(    cityAccessTopNDF(&quot;day&quot;), cityAccessTopNDF(&quot;city&quot;),    cityAccessTopNDF(&quot;cmsId&quot;), cityAccessTopNDF(&quot;times&quot;),    row_number().over(Window.partitionBy(cityAccessTopNDF(&quot;city&quot;)) // 根据 city 分组，根据 times 降序排序      .orderBy(cityAccessTopNDF(&quot;times&quot;).desc)).as(&quot;times_rank&quot;)  ).filter(&quot;times_rank &lt;= 3&quot;)  // 保存到 MySQL，需创建结果表 day_video_city_access_topn_stat  try {    top3DF.foreachPartition(partition =&gt; {      val list = new ListBuffer[DayCityVideoAccessStat]      partition.foreach(item =&gt; {        val day = item.getAs[String](&quot;day&quot;)        val cmsId = item.getAs[Long](&quot;cmsId&quot;)        val city = item.getAs[String](&quot;city&quot;)        val times = item.getAs[Long](&quot;times&quot;)        val timesRank = item.getAs[Int](&quot;times_rank&quot;)        list.append(DayCityVideoAccessStat(day, cmsId, city, times, timesRank))      })      StatDao.insertDayCityVideoAccessTopN(list)    })  } catch {    case e: Exception =&gt; e.printStackTrace()  }}</code></pre><h4 id="统计结果样例"><a href="#统计结果样例" class="headerlink" title="统计结果样例"></a>统计结果样例</h4><pre><code>+--------+-------+-----+-----+----------+|day     |city   |cmsId|times|times_rank|+--------+-------+-----+-----+----------+|20161110|北京市    |1309 |20   |1         ||20161110|北京市    |3369 |16   |2         ||20161110|北京市    |4018 |15   |3         ||20161110|辽宁省    |1336 |2    |1         ||20161110|辽宁省    |9028 |1    |2         ||20161110|辽宁省    |8141 |1    |3         ||20161110|浙江省    |3078 |19   |1         ||20161110|浙江省    |12552|16   |2         ||20161110|浙江省    |3237 |14   |3         |+--------+-------+-----+-----+----------+</code></pre><h2 id="项目开发说明"><a href="#项目开发说明" class="headerlink" title="项目开发说明"></a>项目开发说明</h2><p>1、 CDH相关的软件下载地址：<a href="http://archive.cloudera.com/cdh5/cdh/5/，spark自己编译的，看官方文档即可" target="_blank" rel="noopener">http://archive.cloudera.com/cdh5/cdh/5/，spark自己编译的，看官方文档即可</a></p><p>2、IDEA需要安装Scala插件</p><p>3、 Windows上开发需解压Hadoop和spark源码，然后在环境变量中配置HADOOP_HOME和SPARK_HOME</p><p>4、 windows上需下载相应版本的 <a href="https://github.com/steveloughran/winutils/tree/master/hadoop-2.6.0/bin" target="_blank" rel="noopener">winutils.exe </a> 文件放到 $HADOOP_HOME/bin</p><p>5、 解析IP地址使用  <a href="https://github.com/wzhe06/ipdatabase" target="_blank" rel="noopener">ipdatabase </a> ，三个步骤：</p><pre><code>1）git clone https://github.com/wzhe06/ipdatabase.git2）编译下载的项目：mvn clean package -DskipTests3）安装jar包到自己的maven仓库mvn install:install-file -Dfile=/home/whirly/source/ipdatabase/target/ipdatabase-1.0-SNAPSHOT.jar -DgroupId=com.ggstar -DartifactId=ipdatabase -Dversion=1.0 -Dpackaging=jar</code></pre><p>6、 需要创建相应的数据库和数据表，用于存储统计结果，具体的表结构见 imooc_log.sql ，Navicat 导入MySQL即可，创建库表完毕后须修改 MySQLUtils.scala 中的配置信息</p><p>7、 zeppelin 可导入 最受欢迎的TopN课程.json 文件查看结果，也可以使用可视化方案，譬如echarts、highcharts、D3.js、HUE等等…</p><hr><p><img src="http://image.laijianfeng.org/20180913_001328.png" alt="关注_小旋锋_微信公众号"></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;前言&quot;&gt;&lt;a href=&quot;#前言&quot; class=&quot;headerlink&quot; title=&quot;前言&quot;&gt;&lt;/a&gt;前言&lt;/h2&gt;&lt;h3 id=&quot;项目地址&quot;&gt;&lt;a href=&quot;#项目地址&quot; class=&quot;headerlink&quot; title=&quot;项目地址&quot;&gt;&lt;/a&gt;项目地址&lt;/h
      
    
    </summary>
    
      <category term="大数据" scheme="http://laijianfeng.org/categories/%E5%A4%A7%E6%95%B0%E6%8D%AE/"/>
    
    
      <category term="spark" scheme="http://laijianfeng.org/tags/spark/"/>
    
  </entry>
  
  <entry>
    <title>设计模式 | 责任链模式及典型应用</title>
    <link href="http://laijianfeng.org/2018/10/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F-%E8%B4%A3%E4%BB%BB%E9%93%BE%E6%A8%A1%E5%BC%8F%E5%8F%8A%E5%85%B8%E5%9E%8B%E5%BA%94%E7%94%A8/"/>
    <id>http://laijianfeng.org/2018/10/设计模式-责任链模式及典型应用/</id>
    <published>2018-10-31T07:16:12.000Z</published>
    <updated>2018-10-31T07:18:59.386Z</updated>
    
    <content type="html"><![CDATA[<p>本文的主要内容：</p><ul><li>介绍责任链模式</li><li>请假流程示例</li><li>责任链模式总结</li><li>源码分析Tomcat Filter中的责任链模式</li></ul><h2 id="责任链模式"><a href="#责任链模式" class="headerlink" title="责任链模式"></a>责任链模式</h2><p>一个事件需要经过多个对象处理是一个挺常见的场景，譬如采购审批流程，请假流程，软件开发中的异常处理流程，web请求处理流程等各种各样的流程，可以考虑使用责任链模式来实现。</p><p>以请假流程为例，一般公司普通员工的请假流程简化如下：</p><p><img src="http://image.laijianfeng.org/20181030205552.jpg" alt="普通员工请假简化流程图"></p><p>普通员工发起一个请假申请，当请假天数小于3天时只需要得到主管批准即可；当请假天数大于3天时，主管批准后还需要提交给经理审批，经理审批通过，若请假天数大于7天还需要进一步提交给总经理审批。</p><p>使用 <code>if-else</code> 来实现这个请假流程的简化代码如下：</p><pre><code class="java">public class LeaveApproval {    public boolean process(String request, int number) {        boolean result = handleByDirector(request); // 主管处理        if (result == false) {  // 主管不批准            return false;        } else if (number &lt; 3) {    // 主管批准且天数小于 3            return true;        }        result = handleByManager(request); // 准管批准且天数大于等于 3，提交给经理处理        if (result == false) {   // 经理不批准            return false;        } else if (number &lt; 7) { // 经理批准且天数小于 7            return true;        }        result = handleByTopManager(request);   // 经理批准且天数大于等于 7，提交给总经理处理        if (result == false) { // 总经理不批准            return false;        }        return true;    // 总经理最后批准    }    public boolean handleByDirector(String request) {        // 主管处理该请假申请    }    public boolean handleByManager(String request) {        // 经理处理该请假申请    }    public boolean handleByTopManager(String request) {        // 总经理处理该请假申请    }}</code></pre><p>问题看起来很简单，三下五除二就搞定，但是<strong>该方案存在几个问题</strong>：</p><ol><li><p><code>LeaveApproval</code> 类比较庞大，各个上级的审批方法都集中在该类中，违反了 “单一职责原则”，测试和维护难度大</p></li><li><p>当需要修改该请假流程，譬如增加当天数大于30天时还需提交给董事长处理，必须修改该类源代码（并重新进行严格地测试），违反了 “开闭原则”</p></li><li><p>该流程缺乏灵活性，流程确定后不可再修改（除非修改源代码），客户端无法定制流程</p></li></ol><p>使用责任链模式可以解决上述问题。</p><h3 id="定义"><a href="#定义" class="headerlink" title="定义"></a>定义</h3><p><strong>责任链模式(Chain of Responsibility Pattern)</strong>：避免请求发送者与接收者耦合在一起，让多个对象都有可能接收请求，将这些对象连接成一条链，并且沿着这条链传递请求，直到有对象处理它为止。职责链模式是一种对象行为型模式。</p><h3 id="角色"><a href="#角色" class="headerlink" title="角色"></a>角色</h3><p><strong>Handler（抽象处理者）</strong>：它定义了一个处理请求的接口，一般设计为抽象类，由于不同的具体处理者处理请求的方式不同，因此在其中定义了抽象请求处理方法。因为每一个处理者的下家还是一个处理者，因此在抽象处理者中定义了一个抽象处理者类型的对象，作为其对下家的引用。通过该引用，处理者可以连成一条链。</p><p><strong>ConcreteHandler（具体处理者）</strong>：它是抽象处理者的子类，可以处理用户请求，在具体处理者类中实现了抽象处理者中定义的抽象请求处理方法，在处理请求之前需要进行判断，看是否有相应的处理权限，如果可以处理请求就处理它，否则将请求转发给后继者；在具体处理者中可以访问链中下一个对象，以便请求的转发。</p><p>类图如下所示：</p><p><img src="http://image.laijianfeng.org/20181030205553.jpg" alt="责任链模式.类图"></p><h3 id="纯与不纯的责任链模式"><a href="#纯与不纯的责任链模式" class="headerlink" title="纯与不纯的责任链模式"></a>纯与不纯的责任链模式</h3><p><strong>纯的责任链模式</strong>：</p><ul><li>一个具体处理者对象只能在两个行为中选择一个：要么承担全部责任，要么将责任推给下家，不允许出现某一个具体处理者对象在承担了一部分或全部责任后<br>又将责任向下传递的情况</li><li>一个请求必须被某一个处理者对象所接收，不能出现某个请求未被任何一个处理者对象处理的情况</li></ul><p><strong>不纯的责任链模式</strong>：</p><ul><li>允许某个请求被一个具体处理者部分处理后再向下传递</li><li>或者一个具体处理者处理完某请求后其后继处理者可以继续处理该请求</li><li>而且一个请求可以最终不被任何处理者对象所接收</li></ul><h2 id="示例"><a href="#示例" class="headerlink" title="示例"></a>示例</h2><p>使用责任链模式（不纯）重构请假流程</p><p>请假信息类，包含请假人姓名和请假天数</p><pre><code class="java">@Data@AllArgsConstructorpublic class LeaveRequest {    private String name;    // 请假人姓名    private int numOfDays;  // 请假天数}</code></pre><p>抽象处理者类 Handler，维护一个 <code>nextHandler</code> 属性，该属性为当前处理者的下一个处理者的引用；声明了抽象方法 <code>process</code></p><pre><code class="java">@Datapublic abstract class Handler {    protected String name; // 处理者姓名    protected Handler nextHandler;  // 下一个处理者    public Handler(String name) {        this.name = name;    }    public abstract boolean process(LeaveRequest leaveRequest); // 处理请假}</code></pre><p>三个具体处理类，分别实现了抽象处理类的 <code>process</code> 方法</p><pre><code class="java">// 主管处理者public class Director extends Handler {    public Director(String name) {        super(name);    }    @Override    public boolean process(LeaveRequest leaveRequest) {        boolean result = (new Random().nextInt(10)) &gt; 3; // 随机数大于3则为批准，否则不批准        String log = &quot;主管&lt;%s&gt; 审批 &lt;%s&gt; 的请假申请，请假天数： &lt;%d&gt; ，审批结果：&lt;%s&gt; &quot;;        System.out.println(String.format(log, this.name, leaveRequest.getName(), leaveRequest.getNumOfDays(), result == true ? &quot;批准&quot; : &quot;不批准&quot;));        if (result == false) {  // 不批准            return false;        } else if (leaveRequest.getNumOfDays() &lt; 3) { // 批准且天数小于3，返回true            return true;        }        return nextHandler.process(leaveRequest);   // 批准且天数大于等于3，提交给下一个处理者处理    }}// 经理public class Manager extends Handler {    public Manager(String name) {        super(name);    }    @Override    public boolean process(LeaveRequest leaveRequest) {        boolean result = (new Random().nextInt(10)) &gt; 3; // 随机数大于3则为批准，否则不批准        String log = &quot;经理&lt;%s&gt; 审批 &lt;%s&gt; 的请假申请，请假天数： &lt;%d&gt; ，审批结果：&lt;%s&gt; &quot;;        System.out.println(String.format(log, this.name, leaveRequest.getName(), leaveRequest.getNumOfDays(), result == true ? &quot;批准&quot; : &quot;不批准&quot;));        if (result == false) {  // 不批准            return false;        } else if (leaveRequest.getNumOfDays() &lt; 7) { // 批准且天数小于7            return true;        }        return nextHandler.process(leaveRequest);   // 批准且天数大于等于7，提交给下一个处理者处理    }}// 总经理public class TopManager extends Handler {    public TopManager(String name) {        super(name);    }    @Override    public boolean process(LeaveRequest leaveRequest) {        boolean result = (new Random().nextInt(10)) &gt; 3; // 随机数大于3则为批准，否则不批准        String log = &quot;总经理&lt;%s&gt; 审批 &lt;%s&gt; 的请假申请，请假天数： &lt;%d&gt; ，审批结果：&lt;%s&gt; &quot;;        System.out.println(String.format(log, this.name, leaveRequest.getName(), leaveRequest.getNumOfDays(), result == true ? &quot;批准&quot; : &quot;不批准&quot;));        if (result == false) { // 总经理不批准            return false;        }        return true;    // 总经理最后批准    }}</code></pre><p>客户端测试</p><pre><code class="java">public class Client {    public static void main(String[] args) {        Handler zhangsan = new Director(&quot;张三&quot;);        Handler lisi = new Manager(&quot;李四&quot;);        Handler wangwu = new TopManager(&quot;王五&quot;);        // 创建责任链        zhangsan.setNextHandler(lisi);        lisi.setNextHandler(wangwu);        // 发起请假申请        boolean result1 = zhangsan.process(new LeaveRequest(&quot;小旋锋&quot;, 1));        System.out.println(&quot;最终结果：&quot; + result1 + &quot;\n&quot;);        boolean result2 = zhangsan.process(new LeaveRequest(&quot;小旋锋&quot;, 4));        System.out.println(&quot;最终结果：&quot; + result2 + &quot;\n&quot;);        boolean result3 = zhangsan.process(new LeaveRequest(&quot;小旋锋&quot;, 8));        System.out.println(&quot;最终结果：&quot; + result3 + &quot;\n&quot;);    }}</code></pre><p>可能的结果如下：（由于是否批准是通过随机数模拟的，所以你的结果可能跟我不同）</p><pre><code>主管&lt;张三&gt; 审批 &lt;小旋锋&gt; 的请假申请，请假天数： &lt;1&gt; ，审批结果：&lt;批准&gt; 最终结果：true主管&lt;张三&gt; 审批 &lt;小旋锋&gt; 的请假申请，请假天数： &lt;4&gt; ，审批结果：&lt;不批准&gt; 最终结果：false主管&lt;张三&gt; 审批 &lt;小旋锋&gt; 的请假申请，请假天数： &lt;8&gt; ，审批结果：&lt;批准&gt; 经理&lt;李四&gt; 审批 &lt;小旋锋&gt; 的请假申请，请假天数： &lt;8&gt; ，审批结果：&lt;批准&gt; 总经理&lt;王五&gt; 审批 &lt;小旋锋&gt; 的请假申请，请假天数： &lt;8&gt; ，审批结果：&lt;批准&gt; 最终结果：true</code></pre><p>类图如下所示</p><p><img src="http://image.laijianfeng.org/20181030205554.png" alt="示例.责任链类图"></p><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><h3 id="职责链模式的主要优点"><a href="#职责链模式的主要优点" class="headerlink" title="职责链模式的主要优点"></a>职责链模式的主要优点</h3><ul><li><p>对象仅需知道该请求会被处理即可，且链中的对象不需要知道链的结构，由客户端负责链的创建，<strong>降低了系统的耦合度</strong></p></li><li><p>请求处理对象仅需维持一个指向其后继者的引用，而不需要维持它对所有的候选处理者的引用，<strong>可简化对象的相互连接</strong></p></li><li><p>在给对象分派职责时，职责链可以给我们更多的<strong>灵活性</strong>，可以在运行时对该链进行动态的增删改，改变处理一个请求的职责</p></li><li><p>新增一个新的具体请求处理者时无须修改原有代码，只需要在客户端重新建链即可，<strong>符合 “开闭原则”</strong></p></li></ul><h3 id="职责链模式的主要缺点"><a href="#职责链模式的主要缺点" class="headerlink" title="职责链模式的主要缺点"></a>职责链模式的主要缺点</h3><ul><li><p>一个请求可能因职责链没有被正确配置而<strong>得不到处理</strong></p></li><li><p>对于比较长的职责链，请求的处理可能涉及到多个处理对象，<strong>系统性能将受到一定影响</strong>，且不方便调试</p></li><li><p>可能因为职责链创建不当，造成循环调用，导致系统陷入<strong>死循环</strong></p></li></ul><h3 id="适用场景"><a href="#适用场景" class="headerlink" title="适用场景"></a>适用场景</h3><ul><li><p>有多个对象可以处理同一个请求，具体哪个对象处理该请求待运行时刻再确定，客户端只需将请求提交到链上，而无须关心请求的处理对象是谁以及它是如何处理的</p></li><li><p>在不明确指定接收者的情况下，向多个对象中的一个提交一个请求</p></li><li><p>可动态指定一组对象处理请求，客户端可以动态创建职责链来处理请求，还可以改变链中处理者之间的先后次序</p></li></ul><h2 id="责任链模式的典型应用"><a href="#责任链模式的典型应用" class="headerlink" title="责任链模式的典型应用"></a>责任链模式的典型应用</h2><h3 id="Tomcat-过滤器中的责任链模式"><a href="#Tomcat-过滤器中的责任链模式" class="headerlink" title="Tomcat 过滤器中的责任链模式"></a>Tomcat 过滤器中的责任链模式</h3><p><code>Servlet</code> 过滤器是可用于 <code>Servlet</code> 编程的 Java 类，可以实现以下目的：在客户端的请求访问后端资源之前，拦截这些请求；在服务器的响应发送回客户端之前，处理这些响应。</p><p><code>Servlet</code> 定义了过滤器接口 <code>Filter</code> 和过滤器链接口 <code>FilterChain</code> 的源码如下</p><pre><code class="java">public interface Filter {    public void init(FilterConfig filterConfig) throws ServletException;    public void doFilter(ServletRequest request, ServletResponse response, FilterChain chain) throws IOException, ServletException;    public void destroy();}public interface FilterChain {    void doFilter(ServletRequest var1, ServletResponse var2) throws IOException, ServletException;}</code></pre><p>我们<strong>自定义一个过滤器的步骤</strong>是：</p><p>1）写一个过滤器类，实现 <code>javax.servlet.Filter</code> 接口，如下所示</p><pre><code class="java">public class MyFilter implements Filter {    @Override    public void doFilter(ServletRequest request, ServletResponse response,                         FilterChain chain) throws IOException, ServletException {        // 做一些自定义处理....        System.out.println(&quot;执行doFilter()方法之前...&quot;);        chain.doFilter(request, response);              // 传递请求给下一个过滤器        System.out.println(&quot;执行doFilter()方法之后...&quot;);    }    @Override    public void destroy() {    }    @Override    public void init(FilterConfig filterConfig) throws ServletException {    }}</code></pre><p>2）在 <code>web.xml</code> 文件中增加该过滤器的配置，譬如下面是拦截所有请求</p><pre><code class="xml">&lt;filter&gt;          &lt;filter-name&gt;MyFilter&lt;/filter-name&gt;          &lt;filter-class&gt;com.whirly.filter.MyFilter&lt;/filter-class&gt;  &lt;/filter&gt;&lt;filter-mapping&gt;          &lt;filter-name&gt;MyFilter&lt;/filter-name&gt;          &lt;url-pattern&gt;/*&lt;/url-pattern&gt;  &lt;/filter-mapping&gt;</code></pre><p>当启动 Tomcat 是我们的过滤器就可以发挥作用了。<strong>那么过滤器是怎样运行的呢？</strong></p><blockquote><p>Tomcat 有 <code>Pipeline Valve机制</code>，也是使用了责任链模式，一个请求会在 Pipeline 中流转，Pipeline 会调用相应的 Valve 完成具体的逻辑处理；<br>其中的一个基础Valve为 <code>StandardWrapperValve</code>，其中的一个作用是调用 <code>ApplicationFilterFactory</code> 生成 <code>Filter链</code>，具体代码在 <code>invoke</code> 方法中</p></blockquote><p>在运行过滤器之前需要<strong>完成过滤器的加载和初始化，以及根据配置信息生成过滤器链</strong>：</p><ol><li><p>过滤器的加载具体是在 <code>ContextConfig</code> 类的 <code>configureContext</code> 方法中，分别加载 <code>filter</code> 和 <code>filterMap</code> 的相关信息，并保存在上下文环境中</p></li><li><p>过滤器的初始化在 <code>StandardContext</code> 类的 <code>startInternal</code> 方法中完成，保存在 <code>filterConfigs</code> 中并存到上下文环境中</p></li><li><p>请求流转到 <code>StandardWrapperValve</code> 时，在 <code>invoke</code> 方法中，会根据过滤器映射配置信息，为每个请求创建对应的 <code>ApplicationFilterChain</code>，其中包含了目标 <code>Servlet</code> 以及对应的过滤器链，并调用过滤器链的 <code>doFilter</code> 方法执行过滤器</p></li></ol><p><code>StandardWrapperValve</code> 调用 <code>ApplicationFilterFactory</code> 为请求创建过滤器链并调用过滤器链的关键代码如下:</p><pre><code class="java">final class StandardWrapperValve extends ValveBase {    public final void invoke(Request request, Response response) throws IOException, ServletException {        // 省略其他的逻辑处理...        // 调用 ApplicationFilterChain.createFilterChain() 创建过滤器链        ApplicationFilterChain filterChain = ApplicationFilterFactory.createFilterChain(request, wrapper, servlet);        if (servlet != null &amp;&amp; filterChain != null) {            // 省略        } else if (request.isAsyncDispatching()) {            request.getAsyncContextInternal().doInternalDispatch();        } else if (comet) {            filterChain.doFilterEvent(request.getEvent());        } else {            // 调用过滤器链的 doFilter 方法开始过滤            filterChain.doFilter(request.getRequest(), response.getResponse());        }</code></pre><p>过滤器链 <code>ApplicationFilterChain</code> 的关键代码如下，过滤器链实际是一个 <code>ApplicationFilterConfig</code> 数组</p><pre><code class="java">final class ApplicationFilterChain implements FilterChain, CometFilterChain {    private ApplicationFilterConfig[] filters = new ApplicationFilterConfig[0]; // 过滤器链    private Servlet servlet = null; // 目标    // ...    @Override    public void doFilter(ServletRequest request, ServletResponse response) throws IOException, ServletException {        if( Globals.IS_SECURITY_ENABLED ) {            // ...        } else {            internalDoFilter(request,response); // 调用 internalDoFilter 方法        }    }    private void internalDoFilter(ServletRequest request, ServletResponse response) throws IOException, ServletException {        // Call the next filter if there is one        if (pos &lt; n) {            // 从过滤器数组中取出当前过滤器配置，然后下标自增1            ApplicationFilterConfig filterConfig = filters[pos++];            Filter filter = null;            try {                filter = filterConfig.getFilter();  // 从过滤器配置中取出该 过滤器对象                if( Globals.IS_SECURITY_ENABLED ) {                    final ServletRequest req = request;                    final ServletResponse res = response;                    Principal principal = ((HttpServletRequest) req).getUserPrincipal();                    Object[] args = new Object[]{req, res, this};                    SecurityUtil.doAsPrivilege(&quot;doFilter&quot;, filter, classType, args, principal);                } else {                    // 调用过滤器的 doFilter，完成一个过滤器的过滤功能                    filter.doFilter(request, response, this);                }            return;  // 这里很重要，不会重复执行后面的  servlet.service(request, response)        }        // 执行完过滤器链的所有过滤器之后，调用 Servlet 的 service 完成请求的处理        if ((request instanceof HttpServletRequest) &amp;&amp; (response instanceof HttpServletResponse)) {            if( Globals.IS_SECURITY_ENABLED ) {            } else {                servlet.service(request, response);            }        } else {            servlet.service(request, response);        }    }    // 省略...}</code></pre><p>过滤器</p><pre><code class="java">    public void doFilter(ServletRequest request, ServletResponse response, FilterChain chain) throws IOException, ServletException {        System.out.println(&quot;执行doFilter()方法之前...&quot;);        chain.doFilter(request, response);              // 传递请求给下一个过滤器        System.out.println(&quot;执行doFilter()方法之后...&quot;);    }</code></pre><p>当下标小于过滤器数组长度 n 时，说明过滤器链未执行完，所以从数组中取出当前过滤器，调用过滤器的 <code>doFilter</code> 方法完成过滤处理，在过滤器的 <code>doFilter</code> 中又调用 <code>FilterChain</code> 的 <code>doFilter</code>，回到 <code>ApplicationFilterChain</code>，又继续根据下标是否小于数组长度来判断过滤器链是否已执行完，未完则<strong>继续</strong>从数组取出过滤器并调用 <code>doFilter</code> 方法，所以这里的过滤链是通过<strong>嵌套递归</strong>的方式来串成一条链。</p><p>当全部过滤器都执行完毕，最后一次进入 <code>ApplicationFilterChain.doFilter</code> 方法的时候 <code>pos &lt; n</code> 为false，不进入 <code>if (pos &lt; n)</code> 中，而是执行后面的代码，判断 <code>(request instanceof HttpServletRequest) &amp;&amp; (response instanceof HttpServletResponse)</code>，若为 http 请求则调用 <code>servlet.service(request, response);</code> 来处理该请求。</p><p>处理完毕之后沿着调用过滤器的顺序反向退栈，分别执行过滤器中 <code>chain.doFilter()</code> 之后的处理逻辑，<strong>需要注意的是</strong>在 <code>if (pos &lt; n)</code> 方法体的最后有一个 <code>return;</code>，这样就保证了只有最后一次进入 <code>ApplicationFilterChain.doFilter</code> 方法的调用能够执行后面的 <code>servlet.service(request, response)</code> 方法</p><p>画一个简要的调用栈如下所示：</p><p><img src="http://image.laijianfeng.org/20181030205555.png" alt="Tomcat 过滤器链调用栈"></p><p><code>ApplicationFilterChain</code> 类扮演了抽象处理者角色，具体处理者角色由各个 <code>Filter</code> 扮演</p><h3 id="其他的责任链模式的典型应用"><a href="#其他的责任链模式的典型应用" class="headerlink" title="其他的责任链模式的典型应用"></a>其他的责任链模式的典型应用</h3><p>其他的责任链模式的应用基本都是大同小异</p><p><img src="http://image.laijianfeng.org/20181030_225050.png" alt="FilterChain 的实现类"></p><p>这里列举几个典型应用：</p><ol><li>Netty 中的 <code>Pipeline</code> 和 <code>ChannelHandler</code> 通过责任链设计模式来组织代码逻辑</li><li>Spring Security 使用责任链模式，可以动态地添加或删除责任（处理 request 请求）</li><li>Spring AOP 通过责任链模式来管理 Advisor</li><li>Dubbo Filter 过滤器链也是用了责任链模式（链表），可以对方法调用做一些过滤处理，譬如超时(TimeoutFilter)，异常(ExceptionFilter)，Token(TokenFilter)等</li><li>Mybatis 中的 Plugin 机制使用了责任链模式，配置各种官方或者自定义的 Plugin，与 Filter 类似，可以在执行 Sql 语句的时候做一些操作</li></ol><hr><blockquote><p>参考：<br>刘伟：设计模式Java版<br>慕课网java设计模式精讲 Debug 方式+内存分析<br><a href="https://blog.csdn.net/qq_36460189/article/details/83183448" target="_blank" rel="noopener">责任链设计模式（过滤器、拦截器）</a></p></blockquote><h2 id="后记"><a href="#后记" class="headerlink" title="后记"></a>后记</h2><p>欢迎评论、转发、分享，您的支持是我最大的动力</p><p>更多内容可访问我的个人博客：<a href="http://laijianfeng.org">http://laijianfeng.org</a></p><p>关注【小旋锋】微信公众号，及时接收博文推送</p><p><img src="http://image.laijianfeng.org/20180913_001328.png" alt="长按关注【小旋锋】微信公众号"></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;本文的主要内容：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;介绍责任链模式&lt;/li&gt;
&lt;li&gt;请假流程示例&lt;/li&gt;
&lt;li&gt;责任链模式总结&lt;/li&gt;
&lt;li&gt;源码分析Tomcat Filter中的责任链模式&lt;/li&gt;
&lt;/ul&gt;
&lt;h2 id=&quot;责任链模式&quot;&gt;&lt;a href=&quot;#责任链模
      
    
    </summary>
    
      <category term="后端" scheme="http://laijianfeng.org/categories/%E5%90%8E%E7%AB%AF/"/>
    
    
      <category term="设计模式" scheme="http://laijianfeng.org/tags/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/"/>
    
  </entry>
  
  <entry>
    <title>设计模式 | 中介者模式及典型应用</title>
    <link href="http://laijianfeng.org/2018/10/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F-%E4%B8%AD%E4%BB%8B%E8%80%85%E6%A8%A1%E5%BC%8F%E5%8F%8A%E5%85%B8%E5%9E%8B%E5%BA%94%E7%94%A8/"/>
    <id>http://laijianfeng.org/2018/10/设计模式-中介者模式及典型应用/</id>
    <published>2018-10-25T16:45:30.000Z</published>
    <updated>2018-10-25T16:49:32.583Z</updated>
    
    <content type="html"><![CDATA[<p>本文的主要内容：</p><ul><li>介绍中介者模式</li><li>数据同步示例</li><li>中介者模式总结</li><li>源码分析中介者模式的典型应用<ul><li>Java Timer 中的中介者模式</li></ul></li></ul><h2 id="中介者模式"><a href="#中介者模式" class="headerlink" title="中介者模式"></a>中介者模式</h2><p>世界上存在着各种各样的数据库，不同数据库有各自的应用场景，对于同一份数据，最开始可能使用关系型数据库（如MySQL）进行存储查询，使用Redis作为缓存数据库，当数据量较大时使用MySQL进行查询可能较慢，所以需要将数据同步到Elasticsearch或者列式数据库如Hbase中进行大数据查询。</p><p><strong>如何设计数据同步方案</strong>是一个重要的问题。数据源众多，目标端也众多，设计得不好可能 “牵一发而动全身”。</p><p>如果我们这样设计：每个数据源直接同步数据到目标端数据库的，如果数据库有 N 个，那么最多可能的同步作业将达到 <code>N * N</code> 个，当修改了其中一个数据库的某些配置，可能需要修改另外的 <code>N - 1</code> 个数据库的同步作业。</p><p>现在介绍另一种方案，DataX 是阿里巴巴集团内被广泛使用的离线数据同步工具/平台，实现包括 MySQL、Oracle、SqlServer、Postgre、HDFS、Hive、ADS、HBase、TableStore(OTS)、MaxCompute(ODPS)、DRDS 等各种异构数据源之间高效的数据同步功能。</p><p><img src="http://image.laijianfeng.org/datax-sync.png" alt="DataX"></p><p>DataX 其实相当于一个中介，从数据源读取数据，写入到目标端，数据源不再需要维护到目标端的同步作业，只需要与 DataX 通信即可。DataX 体现了中介者模式的思想。</p><p><strong>中介者模式(Mediator Pattern)</strong>：用一个中介对象（中介者）来封装一系列的对象交互，中介者使各对象不需要显式地相互引用，从而使其耦合松散，而且可以独立地改变它们之间的交互。中介者模式又称为调停者模式，它是一种对象行为型模式。</p><h3 id="角色"><a href="#角色" class="headerlink" title="角色"></a>角色</h3><p><strong>Mediator（抽象中介者）</strong>：它定义一个接口，该接口用于与各同事对象之间进行通信。</p><p><strong>ConcreteMediator（具体中介者）</strong>：它是抽象中介者的子类，通过协调各个同事对象来实现协作行为，它维持了对各个同事对象的引用。</p><p><strong>Colleague（抽象同事类）</strong>：它定义各个同事类公有的方法，并声明了一些抽象方法来供子类实现，同时它维持了一个对抽象中介者类的引用，其子类可以通过该引用来与中介者通信。</p><p><strong>ConcreteColleague（具体同事类）</strong>：它是抽象同事类的子类；每一个同事对象在需要和其他同事对象通信时，先与中介者通信，通过中介者来间接完成与其他同事类的通信；在具体同事类中实现了在抽象同事类中声明的抽象方法。</p><p>中介者模式的核心在于中介者类的引入，在中介者模式中，<strong>中介者类承担了两方面的职责</strong>：</p><ul><li><strong>中转作用（结构性）</strong>：通过中介者提供的中转作用，各个同事对象就不再需要显式引用其他同事，当需要和其他同事进行通信时，可通过中介者来实现间接调用。该中转作用属于中介者在结构上的支持。</li><li><strong>协调作用（行为性）</strong>：中介者可以更进一步的对同事之间的关系进行封装，同事可以一致的和中介者进行交互，而不需要指明中介者需要具体怎么做，中介者根据封装在自身内部的协调逻辑，对同事的请求进行进一步处理，将同事成员之间的关系行为进行分离和封装。</li></ul><h2 id="示例"><a href="#示例" class="headerlink" title="示例"></a>示例</h2><p>我们来实现一个简化版的数据同步方案，有三种数据库 Mysql、Redis、Elasticsearch，其中的 Mysql 作为主数据库，当增加一条数据时<strong>需要</strong>同步到另外两个数据库中；Redis 作为缓存数据库，当增加一条数据时<strong>不需要</strong>同步到另外另个数据库；而 Elasticsearch 作为大数据查询数据库，有一个统计功能，当增加一条数据时<strong>只需要</strong>同步到 Mysql，所以它们之间的关系图如下所示。</p><p><img src="http://image.laijianfeng.org/20181025_193152.jpg" alt="简化的数据同步需求"></p><p>首先我们来实现第一种<strong>不使用</strong>中介者模式的数据同步方案，各数据源维护各自的同步作业。</p><p>抽象数据库</p><pre><code class="java">public abstract class AbstractDatabase {    public abstract void add(String data);    public abstract void addData(String data);}</code></pre><p>具体数据库 Mysql，维护同步到 Redis和Elasticsearch 的同步作业</p><pre><code class="java">public class MysqlDatabase extends AbstractDatabase {    private List&lt;String&gt; dataset = new ArrayList&lt;String&gt;();    @Setter    private RedisDatabase redisDatabase;    @Setter    private EsDatabase esDatabase;    @Override    public void addData(String data) {        System.out.println(&quot;Mysql 添加数据：&quot; + data);        this.dataset.add(data);    }    @Override    public void add(String data) {        addData(data);        this.redisDatabase.addData(data);   // 维护同步到Redis的同步作业        this.esDatabase.addData(data);  // 维护同步到Elasticsearch的同步作业    }    public void select() {        System.out.println(&quot;- Mysql 查询，数据：&quot; + this.dataset.toString());    }}</code></pre><p>具体数据库 Redis，不需要同步到其它数据库</p><pre><code class="java">public class RedisDatabase extends AbstractDatabase {    private List&lt;String&gt; dataset = new LinkedList&lt;String&gt;();    @Override    public void addData(String data) {        System.out.println(&quot;Redis 添加数据：&quot; + data);        this.dataset.add(data);    }    @Override    public void add(String data) {        addData(data); // 不同步到其它数据库    }    public void cache() {        System.out.println(&quot;- Redis 缓存的数据：&quot; + this.dataset.toString());    }}</code></pre><p>Elasticsearch ，只需要同步到Mysql</p><pre><code class="java">public class EsDatabase extends AbstractDatabase {    private List&lt;String&gt; dataset = new CopyOnWriteArrayList&lt;String&gt;();    @Setter    private MysqlDatabase mysqlDatabase;    @Override    public void addData(String data) {        System.out.println(&quot;ES 添加数据：&quot; + data);        this.dataset.add(data);    }    @Override    public void add(String data) {        addData(data);        this.mysqlDatabase.addData(data);   // 维护同步到MySQL的同步作业    }    public void count() {        int count = this.dataset.size();        System.out.println(&quot;- Elasticsearch 统计，目前有 &quot; + count + &quot; 条数据，数据：&quot; + this.dataset.toString());    }}</code></pre><p>测试客户端，分别往三个数据库中加入一些数据查看同步效果</p><pre><code class="java">public class Client {    public static void main(String[] args) {        MysqlDatabase mysqlDatabase = new MysqlDatabase();        RedisDatabase redisDatabase = new RedisDatabase();        EsDatabase esDatabase = new EsDatabase();        mysqlDatabase.setRedisDatabase(redisDatabase);        mysqlDatabase.setEsDatabase(esDatabase);        esDatabase.setMysqlDatabase(mysqlDatabase);        System.out.println(&quot;\n---------mysql 添加数据 1，将同步到Redis和ES中-----------&quot;);        mysqlDatabase.add(&quot;1&quot;);        mysqlDatabase.select();        redisDatabase.cache();        esDatabase.count();        System.out.println(&quot;\n---------Redis添加数据 2，将不同步到其它数据库-----------&quot;);        redisDatabase.add(&quot;2&quot;);        mysqlDatabase.select();        redisDatabase.cache();        esDatabase.count();        System.out.println(&quot;\n---------ES 添加数据 3，只同步到 Mysql-----------&quot;);        esDatabase.add(&quot;3&quot;);        mysqlDatabase.select();        redisDatabase.cache();        esDatabase.count();    }}</code></pre><p>输出结果</p><pre><code class="java">---------mysql 添加数据 1，将同步到Redis和ES中-----------Mysql 添加数据：1Redis 添加数据：1ES 添加数据：1- Mysql 查询，数据：[1]- Redis 缓存的数据：[1]- Elasticsearch 统计，目前有 1 条数据，数据：[1]---------Redis添加数据 2，将不同步到其它数据库-----------Redis 添加数据：2- Mysql 查询，数据：[1]- Redis 缓存的数据：[1, 2]- Elasticsearch 统计，目前有 1 条数据，数据：[1]---------ES 添加数据 3，只同步到 Mysql-----------ES 添加数据：3Mysql 添加数据：3- Mysql 查询，数据：[1, 3]- Redis 缓存的数据：[1, 2]- Elasticsearch 统计，目前有 2 条数据，数据：[1, 3]</code></pre><p>其实这样已经实现了我们的需求，但是<strong>存在一些问题</strong>：</p><ul><li><strong>系统结构复杂且耦合度高</strong>。数据源需要维护目标端数据库的引用，以便完成数据同步</li><li><strong>组件的可重用性差</strong>。由于每一个数据源和目标端之间具有很强的关联，若没有目标端的支持，这个组件很难被另一个系统或模块重用</li><li><strong>系统的可扩展性差</strong>：如果需要增加、修改或删除其中一个数据库、将导致多个类的源代码需要修改，这违反了 “开闭原则”，可扩展性和灵活性欠佳。</li></ul><p>我们<strong>使用中介者模式来重构</strong>，将数据同步的功能迁移到中介者中，由中介者来管理数据同步作业</p><p>首先还是抽象数据库类（抽象同事类），维护了一个中介者</p><pre><code class="java">public abstract class AbstractDatabase {    public static final String MYSQL = &quot;mysql&quot;;    public static final String REDIS = &quot;redis&quot;;    public static final String ELASTICSEARCH = &quot;elasticsearch&quot;;    protected AbstractMediator mediator;    // 中介者    public AbstractDatabase(AbstractMediator mediator) {        this.mediator = mediator;    }    public abstract void addData(String data);    public abstract void add(String data);}</code></pre><p>Mysql 数据库（具体同事类）</p><pre><code class="java">public class MysqlDatabase extends AbstractDatabase {    private List&lt;String&gt; dataset = new ArrayList&lt;String&gt;();    public MysqlDatabase(AbstractMediator mediator) {        super(mediator);    }    @Override    public void addData(String data) {        System.out.println(&quot;Mysql 添加数据：&quot; + data);        this.dataset.add(data);    }    @Override    public void add(String data) {        addData(data);        this.mediator.sync(AbstractDatabase.MYSQL, data); // 数据同步作业交给中介者管理    }    public void select() {        System.out.println(&quot;Mysql 查询，数据：&quot; + this.dataset.toString());    }}</code></pre><p>Redis 数据库（具体同事类）</p><pre><code class="java">public class RedisDatabase extends AbstractDatabase {    private List&lt;String&gt; dataset = new LinkedList&lt;String&gt;();    public RedisDatabase(AbstractMediator mediator) {        super(mediator);    }    @Override    public void addData(String data) {        System.out.println(&quot;Redis 添加数据：&quot; + data);        this.dataset.add(data);    }    @Override    public void add(String data) {        addData(data);        this.mediator.sync(AbstractDatabase.REDIS, data);    // 数据同步作业交给中介者管理    }    public void cache() {        System.out.println(&quot;Redis 缓存的数据：&quot; + this.dataset.toString());    }}</code></pre><p>Elasticsearch（具体同事类）</p><pre><code class="java">public class EsDatabase extends AbstractDatabase {    private List&lt;String&gt; dataset = new CopyOnWriteArrayList&lt;String&gt;();    public EsDatabase(AbstractMediator mediator) {        super(mediator);    }    @Override    public void addData(String data) {        System.out.println(&quot;ES 添加数据：&quot; + data);        this.dataset.add(data);    }    @Override    public void add(String data) {        addData(data);        this.mediator.sync(AbstractDatabase.ELASTICSEARCH, data);    // 数据同步作业交给中介者管理    }    public void count() {        int count = this.dataset.size();        System.out.println(&quot;Elasticsearch 统计，目前有 &quot; + count + &quot; 条数据，数据：&quot; + this.dataset.toString());    }}</code></pre><p>抽象中介者</p><pre><code class="java">@Datapublic abstract class AbstractMediator {    protected MysqlDatabase mysqlDatabase;    protected RedisDatabase redisDatabase;    protected EsDatabase esDatabase;    public abstract void sync(String databaseName, String data);}</code></pre><p>具体中介者</p><pre><code class="java">public class SyncMediator extends AbstractMediator {    @Override    public void sync(String databaseName, String data) {        if (AbstractDatabase.MYSQL.equals(databaseName)) {            // mysql 同步到 redis 和 Elasticsearch            this.redisDatabase.addData(data);            this.esDatabase.addData(data);        } else if (AbstractDatabase.REDIS.equals(databaseName)) {            // redis 缓存同步，不需要同步到其他数据库        } else if (AbstractDatabase.ELASTICSEARCH.equals(databaseName)) {            // Elasticsearch 同步到 Mysql            this.mysqlDatabase.addData(data);        }    }}</code></pre><p>测试客户端</p><pre><code class="java">public class Client {    public static void main(String[] args) {        AbstractMediator syncMediator = new SyncMediator();        MysqlDatabase mysqlDatabase = new MysqlDatabase(syncMediator);        RedisDatabase redisDatabase = new RedisDatabase(syncMediator);        EsDatabase esDatabase = new EsDatabase(syncMediator);        syncMediator.setMysqlDatabase(mysqlDatabase);        syncMediator.setRedisDatabase(redisDatabase);        syncMediator.setEsDatabase(esDatabase);        System.out.println(&quot;\n---------mysql 添加数据 1，将同步到Redis和ES中-----------&quot;);        mysqlDatabase.add(&quot;1&quot;);        mysqlDatabase.select();        redisDatabase.cache();        esDatabase.count();        System.out.println(&quot;\n---------Redis添加数据 2，将不同步到其它数据库-----------&quot;);        redisDatabase.add(&quot;2&quot;);        mysqlDatabase.select();        redisDatabase.cache();        esDatabase.count();        System.out.println(&quot;\n---------ES 添加数据 3，只同步到 Mysql-----------&quot;);        esDatabase.add(&quot;3&quot;);        mysqlDatabase.select();        redisDatabase.cache();        esDatabase.count();    }}</code></pre><p>输出结果，与预期一致</p><pre><code>---------mysql 添加数据 1，将同步到Redis和ES中-----------Mysql 添加数据：1Redis 添加数据：1ES 添加数据：1- Mysql 查询，数据：[1]- Redis 缓存的数据：[1]- Elasticsearch 统计，目前有 1 条数据，数据：[1]---------Redis添加数据 2，将不同步到其它数据库-----------Redis 添加数据：2- Mysql 查询，数据：[1]- Redis 缓存的数据：[1, 2]- Elasticsearch 统计，目前有 1 条数据，数据：[1]---------ES 添加数据 3，只同步到 Mysql-----------ES 添加数据：3Mysql 添加数据：3- Mysql 查询，数据：[1, 3]- Redis 缓存的数据：[1, 2]- Elasticsearch 统计，目前有 2 条数据，数据：[1, 3]</code></pre><p>画出类图如下</p><p><img src="http://image.laijianfeng.org/20181025_193153.png" alt="示例.中介者模式"></p><h2 id="中介者模式总结"><a href="#中介者模式总结" class="headerlink" title="中介者模式总结"></a>中介者模式总结</h2><h3 id="中介者模式的主要优点"><a href="#中介者模式的主要优点" class="headerlink" title="中介者模式的主要优点"></a>中介者模式的主要优点</h3><ul><li><p>中介者模式<strong>简化了对象之间的交互</strong>，它用中介者和同事的一对多交互代替了原来同事之间的多对多交互，一对多关系更容易理解、维护和扩展，将原本难以理解的网状结构转换成相对简单的星型结构。</p></li><li><p>中介者模式可<strong>将各同事对象解耦</strong>。中介者有利于各同事之间的松耦合，我们可以独立的改变和复用每一个同事和中介者，增加新的中介者和新的同事类都比较方便，更好地符合 “开闭原则”。</p></li><li><p>可以<strong>减少子类生成</strong>，中介者将原本分布于多个对象间的行为集中在一起，改变这些行为只需生成新的中介者子类即可，这使各个同事类可被重用，无须对同事类进行扩展。</p></li></ul><h3 id="中介者模式的主要缺点"><a href="#中介者模式的主要缺点" class="headerlink" title="中介者模式的主要缺点"></a>中介者模式的主要缺点</h3><ul><li>在<strong>具体中介者类中包含了大量同事之间的交互细节</strong>，可能会导致具体中介者类非常复杂，使得系统难以维护。（也就是把具体同事类之间的交互复杂性集中到了中介者类中，结果中介者成了最复杂的类）</li></ul><h3 id="适用场景"><a href="#适用场景" class="headerlink" title="适用场景"></a>适用场景</h3><ul><li><p>系统中对象之间存在复杂的引用关系，系统结构混乱且难以理解。</p></li><li><p>一个对象由于引用了其他很多对象并且直接和这些对象通信，导致难以复用该对象。</p></li><li><p>想通过一个中间类来封装多个类中的行为，而又不想生成太多的子类。可以通过引入中介者类来实现，在中介者中定义对象交互的公共行为，如果需要改变行为则可以增加新的具体中介者类。</p></li></ul><h2 id="中介者模式的典型应用"><a href="#中介者模式的典型应用" class="headerlink" title="中介者模式的典型应用"></a>中介者模式的典型应用</h2><h3 id="Java-Timer-中的中介者模式"><a href="#Java-Timer-中的中介者模式" class="headerlink" title="Java Timer 中的中介者模式"></a>Java Timer 中的中介者模式</h3><p>敲一个 <code>java.util.Timer</code> 的Demo</p><p>两个任务类</p><pre><code class="java">public class MyOneTask extends TimerTask {    private static int num = 0;    @Override    public void run() {        System.out.println(&quot;I&#39;m MyOneTask &quot; + ++num);    }}public class MyTwoTask extends TimerTask {    private static int num = 1000;    @Override    public void run() {        System.out.println(&quot;I&#39;m MyTwoTask &quot; + num--);    }}</code></pre><p>客户端测试，3秒后开始执行，循环周期为 1秒</p><pre><code class="java">public class TimerTest {    public static void main(String[] args) {        // 注意：多线程并行处理定时任务时，Timer运行多个TimeTask时，只要其中之一没有捕获抛出的异常，        // 其它任务便会自动终止运行，使用ScheduledExecutorService则没有这个问题        Timer timer = new Timer();        timer.schedule(new MyOneTask(), 3000, 1000); // 3秒后开始运行，循环周期为 1秒        timer.schedule(new MyTwoTask(), 3000, 1000);    }}</code></pre><p>输出</p><pre><code>I&#39;m MyOneTask 1I&#39;m MyTwoTask 1000I&#39;m MyTwoTask 999I&#39;m MyOneTask 2I&#39;m MyOneTask 3I&#39;m MyTwoTask 998I&#39;m MyTwoTask 997I&#39;m MyOneTask 4I&#39;m MyOneTask 5I&#39;m MyTwoTask 996I&#39;m MyTwoTask 995I&#39;m MyOneTask 6...</code></pre><p><code>Timer</code> 的部分关键源码如下</p><pre><code class="java">public class Timer {    private final TaskQueue queue = new TaskQueue();    private final TimerThread thread = new TimerThread(queue);    public void schedule(TimerTask task, long delay) {        if (delay &lt; 0)            throw new IllegalArgumentException(&quot;Negative delay.&quot;);        sched(task, System.currentTimeMillis()+delay, 0);    }    public void schedule(TimerTask task, Date time) {        sched(task, time.getTime(), 0);    }    private void sched(TimerTask task, long time, long period) {        if (time &lt; 0)            throw new IllegalArgumentException(&quot;Illegal execution time.&quot;);        if (Math.abs(period) &gt; (Long.MAX_VALUE &gt;&gt; 1))            period &gt;&gt;= 1;        // 获取任务队列的锁(同一个线程多次获取这个锁并不会被阻塞,不同线程获取时才可能被阻塞)        synchronized(queue) {            // 如果定时调度线程已经终止了,则抛出异常结束            if (!thread.newTasksMayBeScheduled)                throw new IllegalStateException(&quot;Timer already cancelled.&quot;);            // 再获取定时任务对象的锁(为什么还要再加这个锁呢?想不清)            synchronized(task.lock) {                // 判断线程的状态,防止多线程同时调度到一个任务时多次被加入任务队列                if (task.state != TimerTask.VIRGIN)                    throw new IllegalStateException(                        &quot;Task already scheduled or cancelled&quot;);                // 初始化定时任务的下次执行时间                task.nextExecutionTime = time;                // 重复执行的间隔时间                task.period = period;                // 将定时任务的状态由TimerTask.VIRGIN(一个定时任务的初始化状态)设置为TimerTask.SCHEDULED                task.state = TimerTask.SCHEDULED;            }            // 将任务加入任务队列            queue.add(task);            // 如果当前加入的任务是需要第一个被执行的(也就是他的下一次执行时间离现在最近)            // 则唤醒等待queue的线程(对应到上面提到的queue.wait())            if (queue.getMin() == task)                queue.notify();        }    }    // cancel会等到所有定时任务执行完后立刻终止定时线程    public void cancel() {        synchronized(queue) {            thread.newTasksMayBeScheduled = false;            queue.clear();            queue.notify();  // In case queue was already empty.        }    }    // ...}</code></pre><p><code>Timer</code> 中在 <code>schedulexxx</code> 方法中通过 <code>TaskQueue</code> 协调各种 <code>TimerTask</code> 定时任务，<code>Timer</code> 是中介者，<code>TimerTask</code> 是抽象同事类，而我们自己写的任务则是具体同事类</p><p><code>TimerThread</code> 是 <code>Timer</code> 中定时调度线程类的定义，这个类会做为一个线程一直运行来执行 <code>Timer</code> 中任务队列中的任务。</p><p><code>Timer</code> 这个中介者的功能就是<strong>定时调度我们写的各种任务</strong>，将任务添加到 <code>TaskQueue</code> 任务队列中，给 <code>TimerThread</code> 执行，让任务与执行线程解耦</p><h3 id="其他的中介者模式应用"><a href="#其他的中介者模式应用" class="headerlink" title="其他的中介者模式应用"></a>其他的中介者模式应用</h3><ul><li><p><code>java.util.concurrent.Executor#execute</code> 和 <code>java.util.concurrent.ExecutorService#submit</code> 与 <code>Timer#schedule</code> 类似</p></li><li><p>MVC模式中，Controller 是中介者，根据 View 层的请求来操作 Model 层</p></li></ul><blockquote><p>参考：<br>刘伟：设计模式Java版<br>慕课网java设计模式精讲 Debug 方式+内存分析<br><a href="https://www.jianshu.com/p/58a5b0853451" target="_blank" rel="noopener">java.util系列源码解读之Timer定时器</a></p></blockquote><h2 id="后记"><a href="#后记" class="headerlink" title="后记"></a>后记</h2><p>欢迎评论、转发、分享，您的支持是我最大的动力</p><p>关注【小旋锋】微信公众号，及时接收博文推送</p><p><img src="http://image.laijianfeng.org/20180913_001328.png" alt="关注_小旋锋_微信公众号"></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;本文的主要内容：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;介绍中介者模式&lt;/li&gt;
&lt;li&gt;数据同步示例&lt;/li&gt;
&lt;li&gt;中介者模式总结&lt;/li&gt;
&lt;li&gt;源码分析中介者模式的典型应用&lt;ul&gt;
&lt;li&gt;Java Timer 中的中介者模式&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;

      
    
    </summary>
    
      <category term="后端" scheme="http://laijianfeng.org/categories/%E5%90%8E%E7%AB%AF/"/>
    
    
      <category term="设计模式" scheme="http://laijianfeng.org/tags/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/"/>
    
  </entry>
  
  <entry>
    <title>设计模式 | 备忘录模式及典型应用</title>
    <link href="http://laijianfeng.org/2018/10/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F-%E5%A4%87%E5%BF%98%E5%BD%95%E6%A8%A1%E5%BC%8F%E5%8F%8A%E5%85%B8%E5%9E%8B%E5%BA%94%E7%94%A8/"/>
    <id>http://laijianfeng.org/2018/10/设计模式-备忘录模式及典型应用/</id>
    <published>2018-10-24T16:42:24.000Z</published>
    <updated>2018-10-24T16:44:16.194Z</updated>
    
    <content type="html"><![CDATA[<p>本文的主要内容：</p><ul><li>介绍备忘录模式</li><li>示例</li><li>备忘录模式总结</li></ul><h2 id="备忘录模式"><a href="#备忘录模式" class="headerlink" title="备忘录模式"></a>备忘录模式</h2><p>备忘录模式经常可以遇到，譬如下面这些场景：</p><ul><li><p><strong>浏览器回退</strong>：浏览器一般有浏览记录，当我们在一个网页上点击几次链接之后，可在左上角点击左箭头回退到上一次的页面，然后也可以点击右箭头重新回到当前页面</p></li><li><p><strong>数据库备份与还原</strong>：一般的数据库都支持备份与还原操作，备份即将当前已有的数据或者记录保留，还原即将已经保留的数据恢复到对应的表中</p></li><li><p><strong>编辑器撤销与重做</strong>：在编辑器上编辑文字，写错时可以按快捷键 <code>Ctrl + z</code> 撤销，撤销后可以按 <code>Ctrl + y</code> 重做</p></li><li><p><strong>虚拟机生成快照与恢复</strong>：虚拟机可以生成一个快照，当虚拟机发生错误时可以恢复到快照的样子</p></li><li><p><strong>Git版本管理</strong>：Git是最常见的版本管理软件，每提交一个新版本，实际上Git就会把它们自动串成一条时间线，每个版本都有一个版本号，使用 <code>git reset --hard 版本号</code> 即可回到指定的版本，让代码时空穿梭回到过去某个历史时刻</p></li><li><p><strong>棋牌游戏悔棋</strong>：在棋牌游戏中，有时下快了可以悔棋，回退到上一步重新下</p></li></ul><p><img src="http://image.laijianfeng.org/20181024_233428.png" alt="浏览器回退"></p><p><img src="http://image.laijianfeng.org/20181024_235908.png" alt="编辑器撤销"></p><p><strong>备忘录模式(Memento Pattern)</strong>：在不破坏封装的前提下，捕获一个对象的内部状态，并在该对象之外保存这个状态，这样可以在以后将对象恢复到原先保存的状态。它是一种对象行为型模式，其别名为Token。</p><p><img src="http://image.laijianfeng.org/20181025_001332.png" alt="指针向左为撤销，向右为重做"></p><h3 id="角色"><a href="#角色" class="headerlink" title="角色"></a>角色</h3><p><strong>Originator（原发器）</strong>：它是一个普通类，可以创建一个备忘录，并存储它的当前内部状态，也可以使用备忘录来恢复其内部状态，一般将需要保存内部状态的类设计为原发器。</p><p><strong>Memento（备忘录)</strong>：存储原发器的内部状态，根据原发器来决定保存哪些内部状态。备忘录的设计一般可以参考原发器的设计，根据实际需要确定备忘录类中的属性。需要注意的是，除了原发器本身与负责人类之外，备忘录对象不能直接供其他类使用，原发器的设计在不同的编程语言中实现机制会有所不同。</p><p><strong>Caretaker（负责人）</strong>：负责人又称为管理者，它负责保存备忘录，但是不能对备忘录的内容进行操作或检查。在负责人类中可以存储一个或多个备忘录对象，它只负责存储对象，而不能修改对象，也无须知道对象的实现细节。</p><p>备忘录模式的核心是备忘录类以及用于管理备忘录的负责人类的设计。</p><h3 id="示例"><a href="#示例" class="headerlink" title="示例"></a>示例</h3><p>下棋例子，可以下棋，悔棋，撤销悔棋等</p><p>棋子类 <code>Chessman</code>，原发器角色</p><pre><code class="java">@Data@AllArgsConstructorclass Chessman {    private String label;    private int x;    private int y;    //保存状态    public ChessmanMemento save() {        return new ChessmanMemento(this.label, this.x, this.y);    }    //恢复状态    public void restore(ChessmanMemento memento) {        this.label = memento.getLabel();        this.x = memento.getX();        this.y = memento.getY();    }    public void show() {        System.out.println(String.format(&quot;棋子&lt;%s&gt;：当前位置为：&lt;%d, %d&gt;&quot;, this.getLabel(), this.getX(), this.getY()));    }}</code></pre><p>备忘录角色 <code>ChessmanMemento</code></p><pre><code class="java">@Data@AllArgsConstructorclass ChessmanMemento {    private String label;    private int x;    private int y;}</code></pre><p>负责人角色 <code>MementoCaretaker</code></p><pre><code class="java">class MementoCaretaker {    //定义一个集合来存储备忘录    private ArrayList mementolist = new ArrayList();    public ChessmanMemento getMemento(int i) {        return (ChessmanMemento) mementolist.get(i);    }    public void addMemento(ChessmanMemento memento) {        mementolist.add(memento);    }}</code></pre><p>棋子客户端，维护了一个 <code>MementoCaretaker</code> 对象</p><pre><code class="java">class Client {    private static int index = -1;    private static MementoCaretaker mc = new MementoCaretaker();    public static void main(String args[]) {        Chessman chess = new Chessman(&quot;车&quot;, 1, 1);        play(chess);        chess.setY(4);        play(chess);        chess.setX(5);        play(chess);        undo(chess, index);        undo(chess, index);        redo(chess, index);        redo(chess, index);    }    //下棋，同时保存备忘录    public static void play(Chessman chess) {        mc.addMemento(chess.save());        index++;        chess.show();    }    //悔棋，撤销到上一个备忘录    public static void undo(Chessman chess, int i) {        System.out.println(&quot;******悔棋******&quot;);        index--;        chess.restore(mc.getMemento(i - 1));        chess.show();    }    //撤销悔棋，恢复到下一个备忘录    public static void redo(Chessman chess, int i) {        System.out.println(&quot;******撤销悔棋******&quot;);        index++;        chess.restore(mc.getMemento(i + 1));        chess.show();    }}</code></pre><p>输出如下，悔棋成功，撤销悔棋成功</p><pre><code>棋子&lt;车&gt;：当前位置为：&lt;1, 1&gt;棋子&lt;车&gt;：当前位置为：&lt;1, 4&gt;棋子&lt;车&gt;：当前位置为：&lt;5, 4&gt;******悔棋******棋子&lt;车&gt;：当前位置为：&lt;1, 4&gt;******悔棋******棋子&lt;车&gt;：当前位置为：&lt;1, 1&gt;******撤销悔棋******棋子&lt;车&gt;：当前位置为：&lt;1, 4&gt;******撤销悔棋******棋子&lt;车&gt;：当前位置为：&lt;5, 4&gt;</code></pre><p>类图如下</p><p><img src="http://image.laijianfeng.org/20181024_113151.png" alt="示例.备忘录模式类图"></p><h2 id="备忘录模式总结"><a href="#备忘录模式总结" class="headerlink" title="备忘录模式总结"></a>备忘录模式总结</h2><p>备忘录模式的<strong>主要优点</strong>如下：</p><ul><li><p>它提供了一种状态恢复的实现机制，使得用户可以方便地回到一个特定的历史步骤，当新的状态无效或者存在问题时，可以使用暂时存储起来的备忘录将状态复原。</p></li><li><p>备忘录实现了对信息的封装，一个备忘录对象是一种原发器对象状态的表示，不会被其他代码所改动。备忘录保存了原发器的状态，采用列表、堆栈等集合来存储备忘录对象可以实现多次撤销操作。</p></li></ul><p>备忘录模式的<strong>主要缺点</strong>如下：</p><ul><li>资源消耗过大，如果需要保存的原发器类的成员变量太多，就不可避免需要占用大量的存储空间，每保存一次对象的状态都需要消耗一定的系统资源。</li></ul><p><strong>适用场景</strong>：</p><ul><li><p>保存一个对象在某一个时刻的全部状态或部分状态，这样以后需要时它能够恢复到先前的状态，实现撤销操作。</p></li><li><p>防止外界对象破坏一个对象历史状态的封装性，避免将对象历史状态的实现细节暴露给外界对象。</p></li></ul><blockquote><p>由于软件中JDK、Spring、Mybatis中很少有备忘录模式，也许 Spring webflow 中的 StateManageableMessageContext 接口算一个，但是真的很少见，所以这里不做典型应用源码分析</p></blockquote><p><img src="http://image.laijianfeng.org/20180913_001328.png" alt="关注_小旋锋_微信公众号"></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;本文的主要内容：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;介绍备忘录模式&lt;/li&gt;
&lt;li&gt;示例&lt;/li&gt;
&lt;li&gt;备忘录模式总结&lt;/li&gt;
&lt;/ul&gt;
&lt;h2 id=&quot;备忘录模式&quot;&gt;&lt;a href=&quot;#备忘录模式&quot; class=&quot;headerlink&quot; title=&quot;备忘录模式&quot;&gt;&lt;/
      
    
    </summary>
    
      <category term="后端" scheme="http://laijianfeng.org/categories/%E5%90%8E%E7%AB%AF/"/>
    
    
      <category term="设计模式" scheme="http://laijianfeng.org/tags/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/"/>
    
  </entry>
  
  <entry>
    <title>设计模式 | 观察者模式及典型应用</title>
    <link href="http://laijianfeng.org/2018/10/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F-%E8%A7%82%E5%AF%9F%E8%80%85%E6%A8%A1%E5%BC%8F%E5%8F%8A%E5%85%B8%E5%9E%8B%E5%BA%94%E7%94%A8/"/>
    <id>http://laijianfeng.org/2018/10/设计模式-观察者模式及典型应用/</id>
    <published>2018-10-23T16:30:56.000Z</published>
    <updated>2018-10-23T16:33:55.731Z</updated>
    
    <content type="html"><![CDATA[<p>本文主要内容：</p><ul><li>介绍观察者模式</li><li>微信公众号的发布/订阅示例</li><li>观察者模式总结</li><li>分析观察者模式的典型应用<ul><li>JDK 提供的观察者接口中的观察者模式</li><li>Guava EventBus 中的观察者模式</li><li>JDK 委托事件模型DEM中的观察者模式</li><li>Spring ApplicationContext 事件机制中的观察者模式</li></ul></li></ul><h2 id="观察者模式"><a href="#观察者模式" class="headerlink" title="观察者模式"></a>观察者模式</h2><p>观察者模式是设计模式中的 “超级模式”，其应用随处可见，我们以微信公众号为例。</p><p>微信公众号有服务号、订阅号和企业号之分。以我的公众号为例，我的公众号类型是订阅号，名称是 “小旋锋”，专注于大数据，Java后端类技术分享。目前主要是分享学习笔记为主，尽量做到 “原创”、”高质量”、”成体系”。每当我发布一篇博文推送，订阅的用户都能够在我发布推送之后及时接收到推送，即可方便地在手机端进行阅读。</p><p><img src="http://image.laijianfeng.org/20181023_193152.jpg" alt="微信公众号.发布/订阅"></p><p><strong>观察者模式(Observer Pattern)</strong>：定义对象之间的一种一对多依赖关系，使得每当一个对象状态发生改变时，其相关依赖对象皆得到通知并被自动更新。观察者模式是一种对象行为型模式。</p><p>观察者模式的别名包括发布-订阅（Publish/Subscribe）模式、模型-视图（Model/View）模式、源-监听器（Source/Listener）模式或从属者（Dependents）模式。</p><p>观察者模式包含观察目标和观察者两类对象，一个目标可以有任意数目的与之相依赖的观察者，一旦观察目标的状态发生改变，所有的观察者都将得到通知。</p><h3 id="角色"><a href="#角色" class="headerlink" title="角色"></a>角色</h3><p><strong>Subject（目标）</strong>：目标又称为主题，它是指被观察的对象。在目标中定义了一个观察者集合，一个观察目标可以接受任意数量的观察者来观察，它提供一系列方法来增加和删除观察者对象，同时它定义了通知方法notify()。目标类可以是接口，也可以是抽象类或具体类。</p><p><strong>ConcreteSubject（具体目标）</strong>：具体目标是目标类的子类，通常它包含有经常发生改变的数据，当它的状态发生改变时，向它的各个观察者发出通知；同时它还实现了在目标类中定义的抽象业务逻辑方法（如果有的话）。如果无须扩展目标类，则具体目标类可以省略。</p><p><strong>Observer（观察者）</strong>：观察者将对观察目标的改变做出反应，观察者一般定义为接口，该接口声明了更新数据的方法update()，因此又称为抽象观察者。</p><p><strong>ConcreteObserver（具体观察者）</strong>：在具体观察者中维护一个指向具体目标对象的引用，它存储具体观察者的有关状态，这些状态需要和具体目标的状态保持一致；它实现了在抽象观察者Observer中定义的update()方法。通常在实现时，可以调用具体目标类的attach()方法将自己添加到目标类的集合中或通过detach()方法将自己从目标类的集合中删除。</p><h2 id="示例"><a href="#示例" class="headerlink" title="示例"></a>示例</h2><p>首先需要一个订阅者接口（观察者），该接口有一个 <code>receive</code> 方法，用于接收公众号推送通知</p><pre><code class="java">public interface Subscriber {    int receive(String publisher, String articleName);}</code></pre><p>然后是一个微信客户端（具体观察者），实现了 <code>receive</code> 方法</p><pre><code class="java">public class WeChatClient implements Subscriber {    private String username;    public WeChatClient(String username) {        this.username = username;    }    @Override    public int receive(String publisher, String articleName) {        // 接收到推送时的操作        System.out.println(String.format(&quot;用户&lt;%s&gt; 接收到 &lt;%s&gt;微信公众号 的推送，文章标题为 &lt;%s&gt;&quot;, username, publisher, articleName));        return 0;    }}</code></pre><p>发布者类（目标，被观察对象），该类维护了一个订阅者列表，实现了订阅、取消订阅、通知所有订阅者等功能</p><pre><code class="java">public class Publisher {    private List&lt;Subscriber&gt; subscribers;    private boolean pubStatus = false;    public Publisher() {        subscribers = new ArrayList&lt;Subscriber&gt;();    }    protected void subscribe(Subscriber subscriber) {        this.subscribers.add(subscriber);    }    protected void unsubscribe(Subscriber subscriber) {        if (this.subscribers.contains(subscriber)) {            this.subscribers.remove(subscriber);        }    }    protected void notifySubscribers(String publisher, String articleName) {        if (this.pubStatus == false) {            return;        }        for (Subscriber subscriber : this.subscribers) {            subscriber.receive(publisher, articleName);        }        this.clearPubStatus();    }    protected void setPubStatus() {        this.pubStatus = true;    }    protected void clearPubStatus() {        this.pubStatus = false;    }}</code></pre><p>微信公众号类（具体目标），该类提供了 <code>publishArticles</code> 方法，用于发布推送，当文章发布完毕时调用父类的通知所有订阅者方法</p><pre><code class="java">public class WeChatAccounts extends Publisher {    private String name;    public WeChatAccounts(String name) {        this.name = name;    }    public void publishArticles(String articleName, String content) {        System.out.println(String.format(&quot;\n&lt;%s&gt;微信公众号 发布了一篇推送，文章名称为 &lt;%s&gt;，内容为 &lt;%s&gt; &quot;, this.name, articleName, content));        setPubStatus();        notifySubscribers(this.name, articleName);    }}</code></pre><p>测试</p><pre><code class="java">public class Test {    public static void main(String[] args) {        WeChatAccounts accounts = new WeChatAccounts(&quot;小旋锋&quot;);        WeChatClient user1 = new WeChatClient(&quot;张三&quot;);        WeChatClient user2 = new WeChatClient(&quot;李四&quot;);        WeChatClient user3 = new WeChatClient(&quot;王五&quot;);        accounts.subscribe(user1);        accounts.subscribe(user2);        accounts.subscribe(user3);        accounts.publishArticles(&quot;设计模式 | 观察者模式及典型应用&quot;, &quot;观察者模式的内容...&quot;);        accounts.unsubscribe(user1);        accounts.publishArticles(&quot;设计模式 | 单例模式及典型应用&quot;, &quot;单例模式的内容....&quot;);    }}</code></pre><p>结果如下，符合预期，当公众号发布一篇推送时，订阅该公众号的用户可及时接收到推送的通知</p><pre><code>&lt;小旋锋&gt;微信公众号 发布了一篇推送，文章名称为 &lt;设计模式 | 观察者模式及典型应用&gt;，内容为 &lt;观察者模式的内容...&gt; 用户&lt;张三&gt; 接收到 &lt;小旋锋&gt;微信公众号 的推送，文章标题为 &lt;设计模式 | 观察者模式及典型应用&gt;用户&lt;李四&gt; 接收到 &lt;小旋锋&gt;微信公众号 的推送，文章标题为 &lt;设计模式 | 观察者模式及典型应用&gt;用户&lt;王五&gt; 接收到 &lt;小旋锋&gt;微信公众号 的推送，文章标题为 &lt;设计模式 | 观察者模式及典型应用&gt;&lt;小旋锋&gt;微信公众号 发布了一篇推送，文章名称为 &lt;设计模式 | 单例模式及典型应用&gt;，内容为 &lt;单例模式的内容....&gt; 用户&lt;李四&gt; 接收到 &lt;小旋锋&gt;微信公众号 的推送，文章标题为 &lt;设计模式 | 单例模式及典型应用&gt;用户&lt;王五&gt; 接收到 &lt;小旋锋&gt;微信公众号 的推送，文章标题为 &lt;设计模式 | 单例模式及典型应用&gt;</code></pre><p>可画出类图如下</p><p><img src="http://image.laijianfeng.org/20181023_171948.png" alt="示例.观察者模式类图"></p><p>借此机会做个小推广，欢迎大家关注我的微信公众号哦 \^_\^</p><p><img src="http://image.laijianfeng.org/20180913_001328.png" alt="关注【小旋锋】微信公众号"></p><h2 id="观察者模式总结"><a href="#观察者模式总结" class="headerlink" title="观察者模式总结"></a>观察者模式总结</h2><p>观察者模式的<strong>主要优点</strong>如下：</p><ul><li><p>观察者模式可以实现表示层和数据逻辑层的分离，定义了稳定的消息更新传递机制，并抽象了更新接口，使得可以有各种各样不同的表示层充当具体观察者角色。</p></li><li><p>观察者模式在观察目标和观察者之间建立一个抽象的耦合。观察目标只需要维持一个抽象观察者的集合，无须了解其具体观察者。由于观察目标和观察者没有紧密地耦合在一起，因此它们可以属于不同的抽象化层次。</p></li><li><p>观察者模式支持广播通信，观察目标会向所有已注册的观察者对象发送通知，简化了一对多系统设计的难度。</p></li><li><p>观察者模式满足 “开闭原则” 的要求，增加新的具体观察者无须修改原有系统代码，在具体观察者与观察目标之间不存在关联关系的情况下，增加新的观察目标也很方便。</p></li></ul><p>观察者模式的<strong>主要缺点</strong>如下：</p><ul><li><p>如果一个观察目标对象有很多直接和间接观察者，将所有的观察者都通知到会花费很多时间。</p></li><li><p>如果在观察者和观察目标之间存在循环依赖，观察目标会触发它们之间进行循环调用，可能导致系统崩溃。</p></li><li><p>观察者模式没有相应的机制让观察者知道所观察的目标对象是怎么发生变化的，而仅仅只是知道观察目标发生了变化。</p></li></ul><p><strong>适用场景</strong>：</p><ul><li><p>一个抽象模型有两个方面，其中一个方面依赖于另一个方面，将这两个方面封装在独立的对象中使它们可以各自独立地改变和复用。</p></li><li><p>一个对象的改变将导致一个或多个其他对象也发生改变，而并不知道具体有多少对象将发生改变，也不知道这些对象是谁。</p></li><li><p>需要在系统中创建一个触发链，A对象的行为将影响B对象，B对象的行为将影响C对象……，可以使用观察者模式创建一种链式触发机制。</p></li></ul><h2 id="观察者模式的典型应用"><a href="#观察者模式的典型应用" class="headerlink" title="观察者模式的典型应用"></a>观察者模式的典型应用</h2><h3 id="JDK-提供的观察者接口"><a href="#JDK-提供的观察者接口" class="headerlink" title="JDK 提供的观察者接口"></a>JDK 提供的观察者接口</h3><p>观察者模式在Java语言中的地位非常重要。在JDK的 <code>java.util</code> 包中，提供了 <code>Observable</code> 类以及 <code>Observer</code> 接口，它们构成了JDK对观察者模式的支持。</p><p>其中的 <code>Observer</code> 接口为观察者，只有一个 <code>update</code> 方法，当观察目标发生变化时被调用，其代码如下：</p><pre><code class="java">public interface Observer {    void update(Observable o, Object arg);}</code></pre><p><code>Observable</code> 类则为目标类，相比我们的示例中的 <code>Publisher</code> 类多了并发和NPE方面的考虑</p><pre><code class="java">public class Observable {    private boolean changed = false;    private Vector&lt;Observer&gt; obs = new Vector();    public Observable() {    }    // 用于注册新的观察者对象到向量中    public synchronized void addObserver(Observer var1) {        if (var1 == null) {            throw new NullPointerException();        } else {            if (!this.obs.contains(var1)) {                this.obs.addElement(var1);            }        }    }    // 用于删除向量中的某一个观察者对象    public synchronized void deleteObserver(Observer var1) {        this.obs.removeElement(var1);    }    public void notifyObservers() {        this.notifyObservers((Object)null);    }    // 通知方法，用于在方法内部循环调用向量中每一个观察者的update()方法    public void notifyObservers(Object var1) {        Object[] var2;        synchronized(this) {            if (!this.changed) {                return;            }            var2 = this.obs.toArray();            this.clearChanged();        }        for(int var3 = var2.length - 1; var3 &gt;= 0; --var3) {            ((Observer)var2[var3]).update(this, var1);        }    }    // 用于清空向量，即删除向量中所有观察者对象    public synchronized void deleteObservers() {        this.obs.removeAllElements();    }    // 该方法被调用后会设置一个boolean类型的内部标记变量changed的值为true，表示观察目标对象的状态发生了变化    protected synchronized void setChanged() {        this.changed = true;    }    // 用于将changed变量的值设为false，表示对象状态不再发生改变或者已经通知了所有的观察者对象，调用了它们的update()方法    protected synchronized void clearChanged() {        this.changed = false;    }    // 返回对象状态是否改变    public synchronized boolean hasChanged() {        return this.changed;    }    // 返回向量中观察者的数量    public synchronized int countObservers() {        return this.obs.size();    }}</code></pre><p>我们可以使用 <code>Observable</code> 类以及 <code>Observer</code> 接口来重新实现微信公众号示例。</p><p>增加一个通知类 <code>WechatNotice</code>，用于推送通知的传递</p><pre><code class="java">@Data@AllArgsConstructorpublic class WechatNotice {    private String publisher;    private String articleName;}</code></pre><p>然后改写 <code>WeChatClient</code> 和 <code>WeChatAccounts</code>，分别实现JDK的 <code>Observer</code> 接口和继承 <code>Observable</code> 类</p><pre><code class="java">public class WeChatClient implements Observer {    private String username;    public WeChatClient(String username) {        this.username = username;    }    @Override    public void update(Observable o, Object arg) {        //WeChatAccounts weChatAccounts = (WeChatAccounts) o;        WechatNotice notice = (WechatNotice) arg;        System.out.println(String.format(&quot;用户&lt;%s&gt; 接收到 &lt;%s&gt;微信公众号 的推送，文章标题为 &lt;%s&gt;&quot;, username, notice.getPublisher(), notice.getArticleName()));    }}public class WeChatAccounts extends Observable {    private String name;    public WeChatAccounts(String name) {        this.name = name;    }    public void publishArticles(String articleName, String content) {        System.out.println(String.format(&quot;\n&lt;%s&gt;微信公众号 发布了一篇推送，文章名称为 &lt;%s&gt;，内容为 &lt;%s&gt; &quot;, this.name, articleName, content));        setChanged();        notifyObservers(new WechatNotice(this.name, articleName));    }}</code></pre><p>测试，与示例中的测试代码的区别在于调用的方法不同</p><pre><code class="java">public class Test {    public static void main(String[] args) {        WeChatAccounts accounts = new WeChatAccounts(&quot;小旋锋&quot;);        WeChatClient user1 = new WeChatClient(&quot;张三&quot;);        WeChatClient user2 = new WeChatClient(&quot;李四&quot;);        WeChatClient user3 = new WeChatClient(&quot;王五&quot;);        accounts.addObserver(user1);        accounts.addObserver(user2);        accounts.addObserver(user3);        accounts.publishArticles(&quot;设计模式 | 观察者模式及典型应用&quot;, &quot;观察者模式的内容...&quot;);        accounts.deleteObserver(user1);        accounts.publishArticles(&quot;设计模式 | 单例模式及典型应用&quot;, &quot;单例模式的内容....&quot;);    }}</code></pre><p>测试结果如下，可以发现结果如示例一致</p><pre><code class="java">&lt;小旋锋&gt;微信公众号 发布了一篇推送，文章名称为 &lt;设计模式 | 观察者模式及典型应用&gt;，内容为 &lt;观察者模式的内容...&gt; 用户&lt;王五&gt; 接收到 &lt;小旋锋&gt;微信公众号 的推送，文章标题为 &lt;设计模式 | 观察者模式及典型应用&gt;用户&lt;李四&gt; 接收到 &lt;小旋锋&gt;微信公众号 的推送，文章标题为 &lt;设计模式 | 观察者模式及典型应用&gt;用户&lt;张三&gt; 接收到 &lt;小旋锋&gt;微信公众号 的推送，文章标题为 &lt;设计模式 | 观察者模式及典型应用&gt;&lt;小旋锋&gt;微信公众号 发布了一篇推送，文章名称为 &lt;设计模式 | 单例模式及典型应用&gt;，内容为 &lt;单例模式的内容....&gt; 用户&lt;王五&gt; 接收到 &lt;小旋锋&gt;微信公众号 的推送，文章标题为 &lt;设计模式 | 单例模式及典型应用&gt;用户&lt;李四&gt; 接收到 &lt;小旋锋&gt;微信公众号 的推送，文章标题为 &lt;设计模式 | 单例模式及典型应用&gt;</code></pre><h3 id="Guava-EventBus-中的观察者模式"><a href="#Guava-EventBus-中的观察者模式" class="headerlink" title="Guava EventBus 中的观察者模式"></a>Guava EventBus 中的观察者模式</h3><p>Guava 中的 <code>EventBus</code> 封装了友好的 “生产/消费模型”，通过非常简单的方式，实现了观察者模式中的监听注册，事件分发。</p><p>使用了 Guava <code>EventBus</code> 之后，如果需要订阅消息，不需要实现任何接口，只需在监听方法上加上 <code>@Subscribe</code> 注解即可，<code>EventBus</code> 提供了 <code>register</code> 和 <code>unregister</code> 方法用于注册与取消注册事件，当 <code>EventBus</code> 调用 <code>post</code> 方法时将把事件分发给注册的对象</p><p>使用 Guava 重新实现示例</p><pre><code class="java">@Data@AllArgsConstructorpublic class WechatNotice {    private String publisher;    private String articleName;}public class WeChatClient  {    private String username;    public WeChatClient(String username) {        this.username = username;    }    @Subscribe    public void listen(WechatNotice notice) {        System.out.println(String.format(&quot;用户&lt;%s&gt; 接收到 &lt;%s&gt;微信公众号 的推送，文章标题为 &lt;%s&gt;&quot;, username, notice.getPublisher(), notice.getArticleName()));    }}public class WeChatAccounts {    private String name;    private EventBus eventBus;    public WeChatAccounts(String name) {        this.name = name;        this.eventBus = new EventBus();    }    public void publishArticles(String articleName, String content) {        System.out.println(String.format(&quot;\n&lt;%s&gt;微信公众号 发布了一篇推送，文章名称为 &lt;%s&gt;，内容为 &lt;%s&gt; &quot;, this.name, articleName, content));        this.eventBus.post(new WechatNotice(this.name, articleName));    }    public void register(WeChatClient weChatClient) {        this.eventBus.register(weChatClient);    }    public void unregister(WeChatClient weChatClient) {        this.eventBus.unregister(weChatClient);    }}</code></pre><p>测试 </p><pre><code class="java">public class Test {    public static void main(String[] args) {        WeChatAccounts accounts = new WeChatAccounts(&quot;小旋锋&quot;);        WeChatClient user1 = new WeChatClient(&quot;张三&quot;);        WeChatClient user2 = new WeChatClient(&quot;李四&quot;);        WeChatClient user3 = new WeChatClient(&quot;王五&quot;);        accounts.register(user1);        accounts.register(user2);        accounts.register(user3);        accounts.publishArticles(&quot;设计模式 | 观察者模式及典型应用&quot;, &quot;观察者模式的内容...&quot;);        accounts.unregister(user1);        accounts.publishArticles(&quot;设计模式 | 单例模式及典型应用&quot;, &quot;单例模式的内容....&quot;);    }}</code></pre><p>不出意料，输出的内容与上面两个示例一样</p><pre><code>&lt;小旋锋&gt;微信公众号 发布了一篇推送，文章名称为 &lt;设计模式 | 观察者模式及典型应用&gt;，内容为 &lt;观察者模式的内容...&gt; 用户&lt;张三&gt; 接收到 &lt;小旋锋&gt;微信公众号 的推送，文章标题为 &lt;设计模式 | 观察者模式及典型应用&gt;用户&lt;李四&gt; 接收到 &lt;小旋锋&gt;微信公众号 的推送，文章标题为 &lt;设计模式 | 观察者模式及典型应用&gt;用户&lt;王五&gt; 接收到 &lt;小旋锋&gt;微信公众号 的推送，文章标题为 &lt;设计模式 | 观察者模式及典型应用&gt;&lt;小旋锋&gt;微信公众号 发布了一篇推送，文章名称为 &lt;设计模式 | 单例模式及典型应用&gt;，内容为 &lt;单例模式的内容....&gt; 用户&lt;李四&gt; 接收到 &lt;小旋锋&gt;微信公众号 的推送，文章标题为 &lt;设计模式 | 单例模式及典型应用&gt;用户&lt;王五&gt; 接收到 &lt;小旋锋&gt;微信公众号 的推送，文章标题为 &lt;设计模式 | 单例模式及典型应用&gt;</code></pre><blockquote><p>Guava EventBus 的更多用法可自行查看相关文档<br>Guava EventBus 源码分析可看这篇 <a href="http://t.cn/EZzC35B" target="_blank" rel="noopener">http://t.cn/EZzC35B</a></p></blockquote><h3 id="JDK-委托事件模型DEM中的观察者模式"><a href="#JDK-委托事件模型DEM中的观察者模式" class="headerlink" title="JDK 委托事件模型DEM中的观察者模式"></a>JDK 委托事件模型DEM中的观察者模式</h3><p>首先来敲一个AWT按钮监听事件的Demo</p><pre><code class="java">import java.awt.*;import java.awt.event.MouseAdapter;import java.awt.event.MouseEvent;import java.awt.event.WindowAdapter;import java.awt.event.WindowEvent;public class MouseEvents {    private Frame frame;    private Button button;    MouseEvents() {        frame = new Frame(&quot;点击按钮触发点击事件，控制台将打印日志&quot;);        frame.setBounds(300, 200, 600, 300);        frame.setLayout(new FlowLayout());        button = new Button(&quot;this is a button&quot;);        button.setFont(new Font(&quot;Default&quot;, 0, 30));        frame.add(button);        dealwithEvent();        frame.setVisible(true);    }    //事件监听器以及处理事件    private void dealwithEvent() {        // 监听窗体关闭事件        frame.addWindowListener(new WindowAdapter() {            @Override            public void windowClosing(WindowEvent e) {                System.exit(0);            }        });        button.addActionListener(new ActionListener() {            private int eventCount = 1;            @Override            public void actionPerformed(ActionEvent e) {                System.out.println(String.format(&quot;动作事件发生 %d 次&quot;, eventCount++));            }        });    }    public static void main(String[] args) {        new MouseEvents();    }}</code></pre><p>运行 main 方法桌面将弹出下面的面板和按钮</p><p><img src="http://image.laijianfeng.org/20181023_193151.png" alt="按钮监听鼠标事件"></p><p>按钮的 <code>addActionListener</code> 添加指定的动作侦听器，以接收发自此按钮的动作事件，当用户在按钮上按下或释放鼠标时，JVM将产生一个相应的 <code>ActionEvent</code> 类型的事件对象，并在触发事件时将调用按钮的 <code>fireXXX()</code> 方法（继承自 Component），在该方法内部，将调用注册到按钮中的 <code>ActionListener</code> 对象的 <code>actionPerformed()</code> 方法（也就是我们实现的匿名事件处理类），实现对事件的处理</p><pre><code>动作事件发生 1 次动作事件发生 2 次动作事件发生 3 次动作事件发生 4 次</code></pre><h3 id="Spring-ApplicationContext-事件机制中的观察者模式"><a href="#Spring-ApplicationContext-事件机制中的观察者模式" class="headerlink" title="Spring ApplicationContext 事件机制中的观察者模式"></a>Spring ApplicationContext 事件机制中的观察者模式</h3><p>spring的事件机制是从java的事件机制拓展而来，<code>ApplicationContext</code> 中事件处理是由 <code>ApplicationEvent</code> 类和 <code>ApplicationListener</code> 接口来提供的。如果一个Bean实现了 <code>ApplicationListener</code> 接口，并且已经发布到容器中去，每次 <code>ApplicationContext</code> 发布一个 <code>ApplicationEvent</code> 事件，这个Bean就会接到通知</p><ul><li>ApplicationContext：事件源，其中的 publishEvent()方法用于触发容器事件</li><li>ApplicationEvent：事件本身，自定义事件需要继承该类，可以用来传递数据</li><li>ApplicationListener：事件监听器接口，事件的业务逻辑封装在监听器里面</li></ul><p>使用 spring 事件机制重新实现示例</p><pre><code class="java">@Datapublic class WechatNotice extends ApplicationEvent {    private String publisher;    private String articleName;    public WechatNotice(Object source, String publisher, String articleName) {        super(source);        this.publisher = publisher;        this.articleName = articleName;    }}public class WeChatClient implements ApplicationListener {    private String username;    public WeChatClient(String username) {        this.username = username;    }    @Override    public void onApplicationEvent(ApplicationEvent event) {        if (event instanceof WechatNotice) {            WechatNotice notice = (WechatNotice) event;            System.out.println(String.format(&quot;用户&lt;%s&gt; 接收到 &lt;%s&gt;微信公众号 的推送，文章标题为 &lt;%s&gt;&quot;, username, notice.getPublisher(), notice.getArticleName()));        }    }    public void setUsername(String username) {        this.username = username;    }}public class WeChatAccounts implements ApplicationContextAware {    private ApplicationContext ctx;    private String name;    public WeChatAccounts(String name) {        this.name = name;    }    public void setName(String name) {        this.name = name;    }    @Override    public void setApplicationContext(ApplicationContext applicationContext) throws BeansException {        this.ctx = applicationContext;    }    public void publishArticles(String articleName, String content) {        System.out.println(String.format(&quot;\n&lt;%s&gt;微信公众号 发布了一篇推送，文章名称为 &lt;%s&gt;，内容为 &lt;%s&gt; &quot;, this.name, articleName, content));        ctx.publishEvent(new WechatNotice(this.name, this.name, articleName));    }}</code></pre><p>在 resources 目录下创建 <code>spring.xml</code> 文件，填入下面的内容</p><pre><code class="xml">&lt;beans xmlns=&quot;http://www.springframework.org/schema/beans&quot;       xmlns:xsi=&quot;http://www.w3.org/2001/XMLSchema-instance&quot;       xsi:schemaLocation=&quot;http://www.springframework.org/schema/beans http://www.springframework.org/schema/beans/spring-beans.xsd&quot;&gt;    &lt;bean id=&quot;WeChatAccounts&quot; class=&quot;com.observer.sprintevent.WeChatAccounts&quot; scope=&quot;prototype&quot;&gt;        &lt;constructor-arg name=&quot;name&quot; value=&quot;&quot;&gt;&lt;/constructor-arg&gt;    &lt;/bean&gt;    &lt;bean id=&quot;WeChatClient1&quot; class=&quot;com.observer.sprintevent.WeChatClient&quot;&gt;        &lt;constructor-arg name=&quot;username&quot; value=&quot;张三&quot;&gt;&lt;/constructor-arg&gt;    &lt;/bean&gt;    &lt;bean id=&quot;WeChatClient2&quot; class=&quot;com.observer.sprintevent.WeChatClient&quot;&gt;        &lt;constructor-arg name=&quot;username&quot; value=&quot;李四&quot;&gt;&lt;/constructor-arg&gt;    &lt;/bean&gt;    &lt;bean id=&quot;WeChatClient3&quot; class=&quot;com.observer.sprintevent.WeChatClient&quot;&gt;        &lt;constructor-arg name=&quot;username&quot; value=&quot;王五&quot;&gt;&lt;/constructor-arg&gt;    &lt;/bean&gt;&lt;/beans&gt;</code></pre><p>测试</p><pre><code class="java">public class Test {    public static void main(String[] args) {        ApplicationContext context = new ClassPathXmlApplicationContext(&quot;spring.xml&quot;);        WeChatAccounts accounts = (WeChatAccounts) context.getBean(&quot;WeChatAccounts&quot;);        accounts.setName(&quot;小旋锋&quot;);        accounts.setApplicationContext(context);        accounts.publishArticles(&quot;设计模式 | 观察者模式及典型应用&quot;, &quot;观察者模式的内容...&quot;);    }}</code></pre><p>输出如下</p><pre><code>&lt;小旋锋&gt;微信公众号 发布了一篇推送，文章名称为 &lt;设计模式 | 观察者模式及典型应用&gt;，内容为 &lt;观察者模式的内容...&gt; 用户&lt;张三&gt; 接收到 &lt;小旋锋&gt;微信公众号 的推送，文章标题为 &lt;设计模式 | 观察者模式及典型应用&gt;用户&lt;李四&gt; 接收到 &lt;小旋锋&gt;微信公众号 的推送，文章标题为 &lt;设计模式 | 观察者模式及典型应用&gt;用户&lt;王五&gt; 接收到 &lt;小旋锋&gt;微信公众号 的推送，文章标题为 &lt;设计模式 | 观察者模式及典型应用&gt;</code></pre><p>在此示例中 <code>ApplicationContext</code> 对象的实际类型为 <code>ClassPathXmlApplicationContext</code>，其中的与 <code>publishEvent</code> 方法相关的主要代码如下：</p><pre><code class="java">private ApplicationEventMulticaster applicationEventMulticaster;public void publishEvent(ApplicationEvent event) {    this.getApplicationEventMulticaster().multicastEvent(event);    if (this.parent != null) {        this.parent.publishEvent(event);    }}ApplicationEventMulticaster getApplicationEventMulticaster() throws IllegalStateException {    return this.applicationEventMulticaster;}protected void initApplicationEventMulticaster() {        ConfigurableListableBeanFactory beanFactory = this.getBeanFactory();        if (beanFactory.containsLocalBean(&quot;applicationEventMulticaster&quot;)) {            this.applicationEventMulticaster = (ApplicationEventMulticaster)beanFactory.getBean(&quot;applicationEventMulticaster&quot;, ApplicationEventMulticaster.class);        } else {            this.applicationEventMulticaster = new SimpleApplicationEventMulticaster(beanFactory);            beanFactory.registerSingleton(&quot;applicationEventMulticaster&quot;, this.applicationEventMulticaster);        }    }</code></pre><p>其中的 <code>SimpleApplicationEventMulticaster</code> 如下，<code>multicastEvent</code> 方法主要是通过遍历 <code>ApplicationListener</code>（注册由 AbstractApplicationEventMulticaster 实现），使用线程池框架 <code>Executor</code> 来并发执行 <code>ApplicationListener</code> 的 <code>onApplicationEvent</code> 方法，与示例本质上是一致的</p><pre><code class="java">public class SimpleApplicationEventMulticaster extends AbstractApplicationEventMulticaster {    private Executor taskExecutor;    public void multicastEvent(final ApplicationEvent event) {        Iterator var2 = this.getApplicationListeners(event).iterator();        while(var2.hasNext()) {            final ApplicationListener listener = (ApplicationListener)var2.next();            Executor executor = this.getTaskExecutor();            if (executor != null) {                executor.execute(new Runnable() {                    public void run() {                        listener.onApplicationEvent(event);                    }                });            } else {                listener.onApplicationEvent(event);            }        }    }}</code></pre><blockquote><p>参考：<br>刘伟：设计模式Java版<br>慕课网java设计模式精讲 Debug 方式+内存分析<br><a href="http://uule.iteye.com/blog/2096279" target="_blank" rel="noopener">用guava实现简单的事件驱动</a><br><a href="http://www.cnblogs.com/youzhibing/p/9593788.html" target="_blank" rel="noopener">springboot 事件机制</a></p></blockquote><p><img src="http://image.laijianfeng.org/20180913_001328.png" alt="关注_小旋锋_微信公众号"></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;本文主要内容：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;介绍观察者模式&lt;/li&gt;
&lt;li&gt;微信公众号的发布/订阅示例&lt;/li&gt;
&lt;li&gt;观察者模式总结&lt;/li&gt;
&lt;li&gt;分析观察者模式的典型应用&lt;ul&gt;
&lt;li&gt;JDK 提供的观察者接口中的观察者模式&lt;/li&gt;
&lt;li&gt;Guava Eve
      
    
    </summary>
    
      <category term="后端" scheme="http://laijianfeng.org/categories/%E5%90%8E%E7%AB%AF/"/>
    
    
      <category term="设计模式" scheme="http://laijianfeng.org/tags/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/"/>
    
  </entry>
  
  <entry>
    <title>设计模式 | 策略模式及典型应用</title>
    <link href="http://laijianfeng.org/2018/10/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F-%E7%AD%96%E7%95%A5%E6%A8%A1%E5%BC%8F%E5%8F%8A%E5%85%B8%E5%9E%8B%E5%BA%94%E7%94%A8/"/>
    <id>http://laijianfeng.org/2018/10/设计模式-策略模式及典型应用/</id>
    <published>2018-10-18T12:33:43.000Z</published>
    <updated>2018-10-18T12:35:23.159Z</updated>
    
    <content type="html"><![CDATA[<p>本文的主要内容：</p><ul><li>介绍策略模式</li><li>示例<ul><li>商场购物打折策略的实现</li></ul></li><li>策略模式总结</li><li>源码分析策略模式的典型应用<ul><li>Java Comparator 中的策略模式</li><li>Spring Resource 中的策略模式</li><li>Spring Bean 实例化中的策略模式</li></ul></li></ul><h2 id="策略模式"><a href="#策略模式" class="headerlink" title="策略模式"></a>策略模式</h2><p>在软件开发中，我们也常常会遇到类似的情况，实现某一个功能有多条途径，每一条途径对应一种算法，此时我们可以使用一种设计模式来实现灵活地选择解决途径，也能够方便地增加新的解决途径。</p><p>譬如商场购物场景中，有些商品按原价卖，商场可能为了促销而推出优惠活动，有些商品打九折，有些打八折，有些则是返现10元等。</p><p>而优惠活动并不影响结算之外的其他过程，只是在结算的时候需要根据优惠方案结算</p><p><img src="http://image.laijianfeng.org/20181018_171948.jpg" alt="商场促销场景"></p><h3 id="角色"><a href="#角色" class="headerlink" title="角色"></a>角色</h3><p><strong>Context（环境类）</strong>：环境类是使用算法的角色，它在解决某个问题（即实现某个方法）时可以采用多种策略。在环境类中维持一个对抽象策略类的引用实例，用于定义所采用的策略。</p><p><strong>Strategy（抽象策略类）</strong>：它为所支持的算法声明了抽象方法，是所有策略类的父类，它可以是抽象类或具体类，也可以是接口。环境类通过抽象策略类中声明的方法在运行时调用具体策略类中实现的算法。</p><p><strong>ConcreteStrategy（具体策略类）</strong>：它实现了在抽象策略类中声明的算法，在运行时，具体策略类将覆盖在环境类中定义的抽象策略类对象，使用一种具体的算法实现某个业务处理。</p><h2 id="示例"><a href="#示例" class="headerlink" title="示例"></a>示例</h2><p>如果要写出一个商场优惠场景的Demo可以很快的写出来，譬如</p><pre><code class="java">import java.text.MessageFormat;public class Shopping {    private String goods;    private double price;    private double finalPrice;    private String desc;    public Shopping(String goods, double price) {        this.goods = goods;        this.price = price;    }    public double calculate(String discountType) {        if (&quot;dis9&quot;.equals(discountType)) {            finalPrice = price * 0.9;            desc = &quot;打九折&quot;;        } else if (&quot;dis8&quot;.equals(discountType)) {            finalPrice = price * 0.8;            desc = &quot;打八折&quot;;        } else if (&quot;cash10&quot;.equals(discountType)) {            finalPrice = price &gt;= 10 ? price - 10 : 0;            desc = &quot;返现10元&quot;;        } else {            finalPrice = price;            desc = &quot;不参与优惠活动&quot;;        }        System.out.println(MessageFormat.format(&quot;购买的物品：{0}，原始价格：{1}，{2}，最终价格为：{3}&quot;, goods, price, desc, finalPrice));        return finalPrice;    }}</code></pre><p>测试</p><pre><code class="java">public class Test {    public static void main(String[] args) {        Shopping shopping1 = new Shopping(&quot;书籍-深入理解Java虚拟机&quot;, 54.00);        shopping1.calculate(&quot;dis9&quot;); // 九折        Shopping shopping2 = new Shopping(&quot;Apple 妙控鼠标&quot;, 588.00 );        shopping2.calculate(&quot;dis8&quot;);        Shopping shopping3 = new Shopping(&quot;戴尔U2417H显示器&quot;, 1479.00);        shopping3.calculate(&quot;cash10&quot;);        Shopping shopping4 = new Shopping(&quot;索尼ILCE-6000L相机&quot;, 3599.00);        shopping4.calculate(null);    }}</code></pre><p>以上代码当然完成了我们的需求，但是存在以下问题：</p><ul><li><p>Shopping 类的 calculate() 方法非常庞大，它包含各种优惠算法的实现代码，在代码中出现了较长的 <code>if…else…</code> 语句，不利于测试和维护。</p></li><li><p>增加新的优惠算法或者对原有打折算法进行修改时必须修改 Shopping 类的源代码，违反了 “开闭原则”，系统的灵活性和可扩展性较差。</p></li><li><p>算法的复用性差，如果在另一个系统中需要重用某些优惠算法，只能通过对源代码进行复制粘贴来重用，无法单独重用其中的某个或某些算法。</p></li></ul><p>所以我们需要使用策略模式对 Shopping 类进行重构，将原本庞大的 Shopping 类的职责进行分解，将算法的定义和使用分离。</p><p>抽象策略类  <code>Discount</code>，它是所有具体优惠算法的父类，定义了一个 <code>discount</code> 抽象方法</p><pre><code class="java">import lombok.Data;@Datapublic abstract class Discount {    protected double finalPrice;    protected String desc;    public Discount(String desc) {        this.desc = desc;    }    abstract double discount(double price);}</code></pre><p>四种具体策略类，继承自抽象策略类 <code>Discount</code>，并在 <code>discount</code> 方法中实现具体的优惠算法</p><pre><code class="java">public class Dis9Discount extends Discount {    public Dis9Discount() {        super(&quot;打九折&quot;);    }    @Override    double discount(double price) {        finalPrice = price * 0.9;        return finalPrice;    }}public class Dis8Discount extends Discount{    public Dis8Discount() {        super(&quot;打八折&quot;);    }    @Override    double discount(double price) {        finalPrice = price * 0.8;        return finalPrice;    }}public class Cash10Discount extends Discount {    public Cash10Discount() {        super(&quot;返现10元&quot;);    }    @Override    public double discount(double price) {        this.finalPrice = price &gt;= 10 ? price - 10 : 0;        return finalPrice;    }}public class NoneDiscount extends Discount {    public NoneDiscount() {        super(&quot;不参与优惠活动&quot;);    }    @Override    double discount(double price) {        finalPrice = price;        return finalPrice;    }}</code></pre><p>环境类 <code>Shopping</code>，维护了一个 <code>Discount</code> 引用</p><pre><code class="java">public class Shopping {    private String goods;    private double price;    private Discount discount;    public Shopping(String goods, double price, Discount discount) {        this.goods = goods;        this.price = price;        this.discount = discount;    }    public double calculate() {        double finalPrice = discount.discount(this.price);        String desc = discount.getDesc();        System.out.println(MessageFormat.format(&quot;购买的物品：{0}，原始价格：{1}，{2}，最终价格为：{3}&quot;, goods, price, desc, finalPrice));        return finalPrice;    }}</code></pre><p>测试</p><pre><code class="java">public class Test {    public static void main(String[] args) {        Shopping shopping1 = new Shopping(&quot;书籍-深入理解Java虚拟机&quot;, 54.00, new Dis9Discount());        shopping1.calculate();        Shopping shopping2 = new Shopping(&quot;Apple 妙控鼠标&quot;, 588.00, new Dis8Discount());        shopping2.calculate();        Shopping shopping3 = new Shopping(&quot;戴尔U2417H显示器&quot;, 1479.00, new Cash10Discount());        shopping3.calculate();        Shopping shopping4 = new Shopping(&quot;索尼ILCE-6000L相机&quot;, 3599.00, new NoneDiscount());        shopping4.calculate();    }}</code></pre><p>结果</p><pre><code class="java">购买的物品：书籍-深入理解Java虚拟机，原始价格：54，打九折，最终价格为：48.6购买的物品：Apple 妙控鼠标，原始价格：588，打八折，最终价格为：470.4购买的物品：戴尔U2417H显示器，原始价格：1,479，返现10元，最终价格为：1,469购买的物品：索尼ILCE-6000L相机，原始价格：3,599，不参与优惠活动，最终价格为：3,599</code></pre><p>可以看到，使用策略模式重构后，<code>Shopping</code> 类的 <code>calculate</code> 方法简洁了很多，当需要更改优惠算法的时候不需要再修改 <code>Shopping</code> 类的源代码；要扩展出新的优惠算法很方便，只需要继承抽象策略类 <code>Discount</code> 并实现 <code>calculate</code> 方法即可；优惠算法很容易重用。</p><p>画出类图如下</p><p><img src="http://image.laijianfeng.org/20181017_114704.png" alt="示例.策略模式类图"></p><h2 id="策略模式总结"><a href="#策略模式总结" class="headerlink" title="策略模式总结"></a>策略模式总结</h2><p>策略模式的<strong>主要优点</strong>如下： </p><ul><li><p>策略模式提供了对 “开闭原则” 的完美支持，用户可以在不修改原有系统的基础上选择算法或行为，也可以灵活地增加新的算法或行为。</p></li><li><p>策略模式提供了管理相关的算法族的办法。策略类的等级结构定义了一个算法或行为族，恰当使用继承可以把公共的代码移到抽象策略类中，从而避免重复的代码。</p></li><li><p>策略模式提供了一种可以替换继承关系的办法。如果不使用策略模式而是通过继承，这样算法的使用就<br>和算法本身混在一起，不符合 “单一职责原则”，而且使用继承无法实现算法或行为在程序运行时的动态切<br>换。</p></li><li><p>使用策略模式可以避免多重条件选择语句。多重条件选择语句是硬编码，不易维护。</p></li><li><p>策略模式提供了一种算法的复用机制，由于将算法单独提取出来封装在策略类中，因此不同的环境类可以方便地复用这些策略类。</p></li></ul><p>策略模式的<strong>主要缺点</strong>如下：</p><ul><li><p>客户端必须知道所有的策略类，并自行决定使用哪一个策略类。这就意味着客户端必须理解这些算法的区别，以便适时选择恰当的算法。换言之，策略模式只适用于客户端知道所有的算法或行为的情况。</p></li><li><p>策略模式将造成系统产生很多具体策略类，任何细小的变化都将导致系统要增加一个新的具体策略类。</p></li><li><p>无法同时在客户端使用多个策略类，也就是说，在使用策略模式时，客户端每次只能使用一个策略类，不支持使用一个策略类完成部分功能后再使用另一个策略类来完成剩余功能的情况。</p></li></ul><p><strong>适用场景</strong></p><ul><li><p>一个系统需要动态地在几种算法中选择一种，那么可以将这些算法封装到一个个的具体算法类中，而这些具体算法类都是一个抽象算法类的子类。换言之，这些具体算法类均有统一的接口，根据 “里氏代换原则” 和面向对象的多态性，客户端可以选择使用任何一个具体算法类，并只需要维持一个数据类型是抽象算法类的对象。</p></li><li><p>一个对象有很多的行为，如果不用恰当的模式，这些行为就只好使用多重条件选择语句来实现。此时，使用策略模式，把这些行为转移到相应的具体策略类里面，就可以避免使用难以维护的多重条件选择语句。</p></li><li><p>不希望客户端知道复杂的、与算法相关的数据结构，在具体策略类中封装算法与相关的数据结构，可以提高算法的保密性与安全性。</p></li></ul><h2 id="源码分析策略模式的典型应用"><a href="#源码分析策略模式的典型应用" class="headerlink" title="源码分析策略模式的典型应用"></a>源码分析策略模式的典型应用</h2><h3 id="Java-Comparator-中的策略模式"><a href="#Java-Comparator-中的策略模式" class="headerlink" title="Java Comparator 中的策略模式"></a>Java Comparator 中的策略模式</h3><p><code>java.util.Comparator</code> 接口是比较器接口，可以通过 <code>Collections.sort(List,Comparator)</code> 和 <code>Arrays.sort(Object[],Comparator)</code> 对集合和数据进行排序，下面为示例程序</p><p>一个学生类，有两个属性 <code>id</code> 和 <code>name</code></p><pre><code class="java">@Data@AllArgsConstructorpublic class Student {    private Integer id;    private String name;    @Override    public String toString() {        return &quot;{id=&quot; + id + &quot;, name=&#39;&quot; + name + &quot;&#39;}&quot;;    }}</code></pre><p>实现两个比较器，比较器实现了 <code>Comparator</code> 接口，一个升序，一个降序</p><pre><code class="java">// 降序public class DescSortor implements Comparator&lt;Student&gt; {    @Override    public int compare(Student o1, Student o2) {        return o2.getId() - o1.getId();    }}// 升序public class AscSortor implements Comparator&lt;Student&gt; {    @Override    public int compare(Student o1, Student o2) {        return o1.getId() - o2.getId();    }}</code></pre><p>通过 <code>Arrays.sort()</code> 对数组进行排序</p><pre><code class="java">public class Test1 {    public static void main(String[] args) {        Student[] students = {                new Student(3, &quot;张三&quot;),                new Student(1, &quot;李四&quot;),                new Student(4, &quot;王五&quot;),                new Student(2, &quot;赵六&quot;)        };        toString(students, &quot;排序前&quot;);        Arrays.sort(students, new AscSortor());        toString(students, &quot;升序后&quot;);        Arrays.sort(students, new DescSortor());        toString(students, &quot;降序后&quot;);    }    public static void toString(Student[] students, String desc){        for (int i = 0; i &lt; students.length; i++) {            System.out.print(desc + &quot;: &quot; +students[i].toString() + &quot;, &quot;);        }        System.out.println();    }}</code></pre><p>输出</p><pre><code>排序前: {id=3, name=&#39;张三&#39;}, 排序前: {id=1, name=&#39;李四&#39;}, 排序前: {id=4, name=&#39;王五&#39;}, 排序前: {id=2, name=&#39;赵六&#39;}, 升序后: {id=1, name=&#39;李四&#39;}, 升序后: {id=2, name=&#39;赵六&#39;}, 升序后: {id=3, name=&#39;张三&#39;}, 升序后: {id=4, name=&#39;王五&#39;}, 降序后: {id=4, name=&#39;王五&#39;}, 降序后: {id=3, name=&#39;张三&#39;}, 降序后: {id=2, name=&#39;赵六&#39;}, 降序后: {id=1, name=&#39;李四&#39;}, </code></pre><p>通过 <code>Collections.sort()</code> 对集合List进行排序</p><pre><code class="java">public class Test2 {    public static void main(String[] args) {        List&lt;Student&gt; students = Arrays.asList(                new Student(3, &quot;张三&quot;),                new Student(1, &quot;李四&quot;),                new Student(4, &quot;王五&quot;),                new Student(2, &quot;赵六&quot;)        );        toString(students, &quot;排序前&quot;);        Collections.sort(students, new AscSortor());        toString(students, &quot;升序后&quot;);        Collections.sort(students, new DescSortor());        toString(students, &quot;降序后&quot;);    }    public static void toString(List&lt;Student&gt; students, String desc) {        for (Student student : students) {            System.out.print(desc + &quot;: &quot; + student.toString() + &quot;, &quot;);        }        System.out.println();    }}</code></pre><p>输出</p><pre><code>排序前: {id=3, name=&#39;张三&#39;}, 排序前: {id=1, name=&#39;李四&#39;}, 排序前: {id=4, name=&#39;王五&#39;}, 排序前: {id=2, name=&#39;赵六&#39;}, 升序后: {id=1, name=&#39;李四&#39;}, 升序后: {id=2, name=&#39;赵六&#39;}, 升序后: {id=3, name=&#39;张三&#39;}, 升序后: {id=4, name=&#39;王五&#39;}, 降序后: {id=4, name=&#39;王五&#39;}, 降序后: {id=3, name=&#39;张三&#39;}, 降序后: {id=2, name=&#39;赵六&#39;}, 降序后: {id=1, name=&#39;李四&#39;}, </code></pre><p>我们向 <code>Collections.sort()</code> 和 <code>Arrays.sort()</code> 分别传入不同的比较器即可实现不同的排序效果（升序或降序）</p><p>这里 <code>Comparator</code> 接口充当了抽象策略角色，两个比较器 <code>DescSortor</code> 和 <code>AscSortor</code> 则充当了具体策略角色，<code>Collections</code> 和 <code>Arrays</code> 则是环境角色</p><h3 id="Spring-Resource-中的策略模式"><a href="#Spring-Resource-中的策略模式" class="headerlink" title="Spring Resource 中的策略模式"></a>Spring Resource 中的策略模式</h3><p>Spring 把所有能记录信息的载体，如各种类型的文件、二进制流等都称为资源，譬如最常用的Spring配置文件。</p><p>在 Sun 所提供的标准 API 里，资源访问通常由 <code>java.NET.URL</code> 和文件 IO 来完成，尤其是当我们需要访问来自网络的资源时，通常会选择 URL 类。</p><p>URL 类可以处理一些常规的资源访问问题，但依然不能很好地满足所有底层资源访问的需要，比如，暂时还无法从类加载路径、或相对于 <code>ServletContext</code> 的路径来访问资源，虽然 Java 允许使用特定的 URL 前缀注册新的处理类（例如已有的 http: 前缀的处理类），但是这样做通常比较复杂，而且 URL 接口还缺少一些有用的功能，比如检查所指向的资源是否存在等。</p><p>Spring 改进了 Java 资源访问的策略，Spring 为资源访问提供了一个 Resource 接口，该接口提供了更强的资源访问能力，Spring 框架本身大量使用了 Resource 接口来访问底层资源。</p><pre><code class="java">public interface Resource extends InputStreamSource {    boolean exists();    // 返回 Resource 所指向的资源是否存在    boolean isReadable();   // 资源内容是否可读    boolean isOpen();   // 返回资源文件是否打开    URL getURL() throws IOException;    URI getURI() throws IOException;    File getFile() throws IOException;  // 返回资源对应的 File 对象    long contentLength() throws IOException;    long lastModified() throws IOException;    Resource createRelative(String var1) throws IOException;    String getFilename();    String getDescription();    // 返回资源的描述信息}</code></pre><p><code>Resource</code> 接口是 Spring 资源访问策略的抽象，它本身并不提供任何资源访问实现，具体的资源访问由该接口的实现类完成——<strong>每个实现类代表一种资源访问策略</strong>。</p><p><img src="http://image.laijianfeng.org/20181018_171944.png" alt="Spring资源访问接口Resource的实现类"></p><p>Spring 为 Resource 接口提供的部分实现类如下：</p><ul><li><code>UrlResource</code>：访问网络资源的实现类。</li><li><code>ClassPathResource</code>：访问类加载路径里资源的实现类。</li><li><code>FileSystemResource</code>：访问文件系统里资源的实现类。</li><li><code>ServletContextResource</code>：访问相对于 <code>ServletContext</code> 路径里的资源的实现类：</li><li><code>InputStreamResource</code>：访问输入流资源的实现类。</li><li><code>ByteArrayResource</code>：访问字节数组资源的实现类。</li><li><code>WritableResource</code>：写资源文件</li></ul><p>这些 <code>Resource</code> 实现类，针对不同的的底层资源，提供了相应的资源访问逻辑，并提供便捷的包装，以利于客户端程序的资源访问。</p><p>它们之间的类关系如下所示：</p><p><img src="http://image.laijianfeng.org/20181018_171945.png" alt="Spring Resource 类图"></p><p>可以看到 <code>AbstractResource</code> 资源抽象类实现了 <code>Resource</code> 接口，为子类通用的操作提供了具体实现，非通用的操作留给子类实现，所以这里也应用了模板方法模式。（只不过缺少了模板方法）</p><p><code>Resource</code> 不仅可在 Spring 的项目中使用，也可直接作为资源访问的工具类使用。意思是说：即使不使用 Spring 框架，也可以使用 <code>Resource</code> 作为工具类，用来代替 <code>URL</code>。</p><p>譬如我们可以使用 <code>UrlResource</code> 访问网络资源。</p><blockquote><p>也可以通过其它协议访问资源，file: 用于访问文件系统；http: 用于通过 HTTP 协议访问资源；ftp: 用于通过 FTP 协议访问资源等</p></blockquote><pre><code class="java">public class Test {    public static void main(String[] args) throws IOException {        UrlResource ur = new UrlResource(&quot;http://image.laijianfeng.org/hello.txt&quot;);        System.out.println(&quot;文件名：&quot; + ur.getFilename());        System.out.println(&quot;网络文件URL：&quot; + ur.getURL());        System.out.println(&quot;是否存在：&quot; + ur.exists());        System.out.println(&quot;是否可读：&quot; + ur.isReadable());        System.out.println(&quot;文件长度：&quot; + ur.contentLength());        System.out.println(&quot;\n--------文件内容----------\n&quot;);        byte[] bytes = new byte[47];        ur.getInputStream().read(bytes);        System.out.println(new String(bytes));    }}</code></pre><p>输出的内容如下，符合预期</p><pre><code>文件名：hello.txt网络文件URL：http://image.laijianfeng.org/hello.txt是否存在：true是否可读：true文件长度：47--------文件内容----------hello world!welcome to http://laijianfeng.org</code></pre><blockquote><p>更多的示例可以参考：<a href="https://www.ibm.com/developerworks/cn/java/j-lo-spring-resource/index.html" target="_blank" rel="noopener">Spring 资源访问剖析和策略模式应用</a></p></blockquote><h3 id="Spring-Bean-实例化中的策略模式"><a href="#Spring-Bean-实例化中的策略模式" class="headerlink" title="Spring Bean 实例化中的策略模式"></a>Spring Bean 实例化中的策略模式</h3><p>Spring实例化Bean有三种方式：构造器实例化、静态工厂实例化、实例工厂实例化</p><p>譬如通过构造器实例化bean的XML示例如下：</p><pre><code class="xml">&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt;&lt;beans xmlns=&quot;http://www.springframework.org/schema/beans&quot;    xmlns:xsi=&quot;http://www.w3.org/2001/XMLSchema-instance&quot;    xsi:schemaLocation=&quot;http://www.springframework.org/schema/beans http://www.springframework.org/schema/beans/spring-beans.xsd&quot;&gt;    &lt;bean id=&quot;person&quot; class=&quot;com.demo.Person&quot;&gt;&lt;/bean&gt;    &lt;bean id=&quot;personWithParam&quot; class=&quot;com.demo.Person&quot;&gt;        &lt;constructor-arg name=&quot;name&quot; value=&quot;小旋锋&quot;/&gt;    &lt;/bean&gt;    &lt;bean id=&quot;personWirhParams&quot; class=&quot;com.demo.Person&quot;&gt;            &lt;constructor-arg name=&quot;name&quot; value=&quot;小旋锋&quot;/&gt;            &lt;constructor-arg name=&quot;age&quot; value=&quot;22&quot;/&gt;    &lt;/bean&gt;&lt;/beans&gt;</code></pre><p>具体实例化Bean的过程中，Spring中角色分工很明确，创建对象的时候先通过 <code>ConstructorResolver</code> 找到对应的实例化方法和参数，再通过实例化策略 <code>InstantiationStrategy</code> 进行实例化，根据创建对象的三个分支( 工厂方法、有参构造方法、无参构造方法 ), <code>InstantiationStrategy</code> 提供了三个接口方法：</p><pre><code class="java">public interface InstantiationStrategy {    // 默认构造方法    Object instantiate(RootBeanDefinition beanDefinition, String beanName, BeanFactory owner) throws BeansException;    // 指定构造方法    Object instantiate(RootBeanDefinition beanDefinition, String beanName, BeanFactory owner, Constructor&lt;?&gt; ctor,            Object[] args) throws BeansException;    // 指定工厂方法    Object instantiate(RootBeanDefinition beanDefinition, String beanName, BeanFactory owner, Object factoryBean,            Method factoryMethod, Object[] args) throws BeansException;}</code></pre><p><code>InstantiationStrategy</code> 为实例化策略接口，扮演抽象策略角色，有两种具体策略类，分别为 <code>SimpleInstantiationStrategy</code> 和 <code>CglibSubclassingInstantiationStrategy</code> </p><p><img src="http://image.laijianfeng.org/20181018_171946.png" alt="Spring 实例化策略类图"></p><p>在 <code>SimpleInstantiationStrategy</code> 中对这三个方法做了简单实现，如果工厂方法实例化直接用反射创建对象，如果是构造方法实例化的则判断是否有 <code>MethodOverrides</code>，如果有无 <code>MethodOverrides</code> 也是直接用反射，如果有 <code>MethodOverrides</code> 就需要用 <code>cglib</code> 实例化对象，<code>SimpleInstantiationStrategy</code> 把通过 <code>cglib</code> 实例化的任务交给了它的子类 <code>CglibSubclassingInstantiationStrategy</code>。</p><blockquote><p>参考：<br>刘伟：设计模式Java版<br>慕课网java设计模式精讲 Debug 方式+内存分析<br><a href="https://www.ibm.com/developerworks/cn/java/j-lo-spring-resource/index.html" target="_blank" rel="noopener">Spring 资源访问剖析和策略模式应用</a><br><a href="https://my.oschina.net/chengxiaoyuan/blog/823655" target="_blank" rel="noopener">Spring源码阅读-实例化策略InstantiationStrategy</a><br><a href="https://blog.csdn.net/u011726984/article/details/45290871" target="_blank" rel="noopener">Spring学习之实例化bean的三种方式</a>   </p></blockquote><h3 id="推荐阅读"><a href="#推荐阅读" class="headerlink" title="推荐阅读"></a>推荐阅读</h3><p><a href="https://mp.weixin.qq.com/s?__biz=MzI1NDU0MTE1NA==&amp;mid=2247483700&amp;idx=1&amp;sn=dd4d23f9400c8be248f5d125465ba941&amp;chksm=e9c2ed39deb5642fb809eca1351f00995f06c9a4875f09986cc5005059eff74d6c20fc1118a3&amp;scene=0#rd" target="_blank" rel="noopener">设计模式 | 简单工厂模式及典型应用</a><br><a href="https://mp.weixin.qq.com/s?__biz=MzI1NDU0MTE1NA==&amp;mid=2247483704&amp;idx=1&amp;sn=fa3ae947cebf22da35e6ac0a37f566f8&amp;chksm=e9c2ed35deb564230a69e43d93a3b74618287c6ddd402a6f1dc6a5b14a896e99584985e7cf92&amp;scene=0#rd" target="_blank" rel="noopener">设计模式 | 工厂方法模式及典型应用</a><br><a href="https://mp.weixin.qq.com/s?__biz=MzI1NDU0MTE1NA==&amp;mid=2247483708&amp;idx=1&amp;sn=9b8c155b86511ea6ec323dc6a72c52df&amp;chksm=e9c2ed31deb56427b2a6bbcbad5bdd3a4ef68b52eb88cc47b5bcfc76773d3d983d8aaf57761c&amp;scene=0#rd" target="_blank" rel="noopener">设计模式 | 抽象工厂模式及典型应用</a><br><a href="https://mp.weixin.qq.com/s?__biz=MzI1NDU0MTE1NA==&amp;mid=2247483712&amp;idx=1&amp;sn=1ffd9837eb9413dde74ff509bf69ecc5&amp;chksm=e9c2ed4ddeb5645b8cbf64c83d103a859ae49921c60e17fe8bebe63c26b04966be101d598848&amp;scene=0#rd" target="_blank" rel="noopener">设计模式 | 建造者模式及典型应用</a><br><a href="https://mp.weixin.qq.com/s?__biz=MzI1NDU0MTE1NA==&amp;mid=2247483716&amp;idx=1&amp;sn=df00c297c8f32e10e277db8941839c14&amp;chksm=e9c2ed49deb5645fa2586da358a8f0a00dd926f883637adebc59435f846c67c040ef759ba034&amp;scene=0#rd" target="_blank" rel="noopener">设计模式 | 原型模式及典型应用</a><br><a href="https://mp.weixin.qq.com/s?__biz=MzI1NDU0MTE1NA==&amp;mid=2247483721&amp;idx=1&amp;sn=721d0bce3bd516c10d4b6addbf3eced6&amp;chksm=e9c2ed44deb56452395c94a0b150994b94aa26cae71149e6c030d0ac32f9c3c37e2bfe9685b6&amp;scene=0#rd" target="_blank" rel="noopener">设计模式 | 外观模式及典型应用</a><br><a href="https://mp.weixin.qq.com/s?__biz=MzI1NDU0MTE1NA==&amp;mid=2247483726&amp;idx=1&amp;sn=df583e5b297ddaff5e1ab822df762274&amp;chksm=e9c2ed43deb56455d2a099f3c3e8622031027d6da00202e6a7d731eac691e4d87d673ca103b5&amp;scene=0#rd" target="_blank" rel="noopener">设计模式 | 装饰者模式及典型应用</a><br><a href="https://mp.weixin.qq.com/s?__biz=MzI1NDU0MTE1NA==&amp;mid=2247483730&amp;idx=1&amp;sn=859feab7f4632b7ba3d1b5a614d57bbe&amp;chksm=e9c2ed5fdeb56449575995778573fa05a3730ac72792d70fc91e38e2d2f5238899f620481d16&amp;scene=0#rd" target="_blank" rel="noopener">设计模式 | 适配器模式及典型应用</a><br><a href="https://mp.weixin.qq.com/s?__biz=MzI1NDU0MTE1NA==&amp;mid=2247483737&amp;idx=1&amp;sn=ed27a42a80b87ff74f1e1266d918ad5b&amp;chksm=e9c2ed54deb56442aba5c95fbddd4c774eb39ebe7ab8c03471a62e3cf3979e303cef43417bac&amp;scene=0#rd" target="_blank" rel="noopener">设计模式 | 享元模式及典型应用</a><br><a href="https://mp.weixin.qq.com/s?__biz=MzI1NDU0MTE1NA==&amp;mid=2247483742&amp;idx=1&amp;sn=436670dc4793c6c9e7207ca6222e062c&amp;chksm=e9c2ed53deb56445c7fb1aef89ab80b23bab96e6f9993618c98e1746209eec05f36b231cfaa8&amp;scene=0#rd" target="_blank" rel="noopener">设计模式 | 组合模式及典型应用</a><br><a href="https://mp.weixin.qq.com/s?__biz=MzI1NDU0MTE1NA==&amp;mid=2247483747&amp;idx=1&amp;sn=aa494215a2933e2424a6daa03587e478&amp;chksm=e9c2ed6edeb564783b9acd9f5372a08d53d04b001ca362c9213c4379bc7e1bff363e4ad01e3c&amp;scene=0#rd" target="_blank" rel="noopener">设计模式 | 模板方法模式及典型应用</a><br><a href="https://mp.weixin.qq.com/s?__biz=MzI1NDU0MTE1NA==&amp;mid=2247483752&amp;idx=1&amp;sn=7880679f18b5727ea64cd05c06817c35&amp;chksm=e9c2ed65deb56473da688784c4562995c24daf4b13425d0d4d080208728b86525f6600127925&amp;scene=0#rd" target="_blank" rel="noopener">设计模式 | 迭代器模式及典型应用</a>   </p><p><img src="http://image.laijianfeng.org/20180913_001328.png" alt="关注_小旋锋_微信公众号"></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;本文的主要内容：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;介绍策略模式&lt;/li&gt;
&lt;li&gt;示例&lt;ul&gt;
&lt;li&gt;商场购物打折策略的实现&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;策略模式总结&lt;/li&gt;
&lt;li&gt;源码分析策略模式的典型应用&lt;ul&gt;
&lt;li&gt;Java Comparator 中
      
    
    </summary>
    
      <category term="后端" scheme="http://laijianfeng.org/categories/%E5%90%8E%E7%AB%AF/"/>
    
    
      <category term="设计模式" scheme="http://laijianfeng.org/tags/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/"/>
    
  </entry>
  
  <entry>
    <title>20181013-燃烧吧，破铜烂铁！</title>
    <link href="http://laijianfeng.org/2018/10/20181013-%E7%87%83%E7%83%A7%E5%90%A7%EF%BC%8C%E7%A0%B4%E9%93%9C%E7%83%82%E9%93%81%EF%BC%81/"/>
    <id>http://laijianfeng.org/2018/10/20181013-燃烧吧，破铜烂铁！/</id>
    <published>2018-10-13T14:01:20.000Z</published>
    <updated>2018-10-13T14:18:47.380Z</updated>
    
    <content type="html"><![CDATA[<p>燃烧吧，破铜烂铁！</p><p><img src="http://image.laijianfeng.org/20181013220016.jpg" alt="英国Junnk乐队极限音乐会"></p><p>燃烧吧，青春！</p><video src="http://image.laijianfeng.org/WeChat_20181013215718.mp4" controls="controls"><br>英国Junnk乐队极限音乐会<br></video>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;燃烧吧，破铜烂铁！&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;http://image.laijianfeng.org/20181013220016.jpg&quot; alt=&quot;英国Junnk乐队极限音乐会&quot;&gt;&lt;/p&gt;
&lt;p&gt;燃烧吧，青春！&lt;/p&gt;
&lt;video src=&quot;http://i
      
    
    </summary>
    
      <category term="生活杂记" scheme="http://laijianfeng.org/categories/%E7%94%9F%E6%B4%BB%E6%9D%82%E8%AE%B0/"/>
    
    
  </entry>
  
  <entry>
    <title>设计模式 | 迭代器模式及典型应用</title>
    <link href="http://laijianfeng.org/2018/10/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F-%E8%BF%AD%E4%BB%A3%E5%99%A8%E6%A8%A1%E5%BC%8F%E5%8F%8A%E5%85%B8%E5%9E%8B%E5%BA%94%E7%94%A8/"/>
    <id>http://laijianfeng.org/2018/10/设计模式-迭代器模式及典型应用/</id>
    <published>2018-10-11T15:04:40.000Z</published>
    <updated>2018-10-11T15:06:25.849Z</updated>
    
    <content type="html"><![CDATA[<p>本文的主要内容：</p><ul><li>介绍迭代器模式</li><li>源码分析迭代器模式的典型应用<ul><li>Java集合中的迭代器模式</li><li>Mybatis中的迭代器模式</li></ul></li></ul><h2 id="迭代器模式"><a href="#迭代器模式" class="headerlink" title="迭代器模式"></a>迭代器模式</h2><p><strong>迭代器模式(Iterator Pattern)</strong>：提供一种方法来访问聚合对象，而不用暴露这个对象的内部表示，其别名为游标(Cursor)。迭代器模式是一种对象行为型模式。</p><h3 id="角色"><a href="#角色" class="headerlink" title="角色"></a>角色</h3><p><strong>Iterator（抽象迭代器）</strong>：它定义了访问和遍历元素的接口，声明了用于遍历数据元素的方法，例如：用于获取第一个元素的first()方法，用于访问下一个元素的next()方法，用于判断是否还有下一个元素的hasNext()方法，用于获取当前元素的currentItem()方法等，在具体迭代器中将实现这些方法。</p><p><strong>ConcreteIterator（具体迭代器）</strong>：它实现了抽象迭代器接口，完成对聚合对象的遍历，同时在具体迭代器中通过游标来记录在聚合对象中所处的当前位置，在具体实现时，游标通常是一个表示位置的非负整数。</p><p><strong>Aggregate（抽象聚合类）</strong>：它用于存储和管理元素对象，声明一个createIterator()方法用于创建一个迭代器对象，充当抽象迭代器工厂角色。</p><p><strong>ConcreteAggregate（具体聚合类）</strong>：它实现了在抽象聚合类中声明的createIterator()方法，该方法返回一个与该具体聚合类对应的具体迭代器ConcreteIterator实例。</p><p>在迭代器模式中，提供了一个外部的迭代器来对聚合对象进行访问和遍历，迭代器定义了一个访问该聚合元素的接口，并且可以跟踪当前遍历的元素，了解哪些元素已经遍历过而哪些没有。迭代器的引入，将使得对一个复杂聚合对象的操作变得简单。</p><p>在迭代器模式中应用了工厂方法模式，抽象迭代器对应于抽象产品角色，具体迭代器对应于具体产品角色，抽象聚合类对应于抽象工厂角色，具体聚合类对应于具体工厂角色。</p><h2 id="示例"><a href="#示例" class="headerlink" title="示例"></a>示例</h2><p>我们来实现一个学生报数的示例</p><p>定义一个学生类，有一个报数方法 <code>count()</code></p><pre><code class="java">@Getter@Setter@ToStringpublic class Student {    private String name;    private Integer number;    public Student(String name, Integer number) {        this.name = name;        this.number = number;    }    public void count() {        System.out.println(String.format(&quot;我是 %d 号 %s&quot;, this.number, this.name));    }}</code></pre><p>定义班级接口和班级类</p><pre><code class="java">public interface StudentAggregate {    void addStudent(Student student);    void removeStudent(Student student);    StudentIterator getStudentIterator();}public class StudentAggregateImpl implements StudentAggregate {    private List&lt;Student&gt; list;  // 学生列表    public StudentAggregateImpl() {        this.list = new ArrayList&lt;Student&gt;();    }    @Override    public void addStudent(Student student) {        this.list.add(student);    }    @Override    public void removeStudent(Student student) {        this.list.remove(student);    }    @Override    public StudentIterator getStudentIterator() {        return new StudentIteratorImpl(list);    }}</code></pre><p>定义迭代器接口并实现迭代器</p><pre><code class="java">public interface StudentIterator {    boolean hashNext();    Student next();}public class StudentIteratorImpl implements StudentIterator{    private List&lt;Student&gt; list;    private int position = 0;    private Student currentStudent;    public StudentIteratorImpl(List&lt;Student&gt; list) {        this.list = list;    }    @Override    public boolean hashNext() {        return position &lt; list.size();    }    @Override    public Student next() {        currentStudent = list.get(position);        position ++;        return currentStudent;    }}</code></pre><p>测试，进行报数</p><pre><code class="java">public class Test {    public static void main(String[] args) {        StudentAggregate classOne = new StudentAggregateImpl();        classOne.addStudent(new Student(&quot;张三&quot;, 1));        classOne.addStudent(new Student(&quot;李四&quot;, 2));        classOne.addStudent(new Student(&quot;王五&quot;, 3));        classOne.addStudent(new Student(&quot;赵六&quot;, 4));        // 遍历，报数        StudentIterator iterator = classOne.getStudentIterator();        while (iterator.hashNext()){            Student student = iterator.next();            student.count();        }    }}</code></pre><p>输出</p><pre><code>我是 1 号 张三我是 2 号 李四我是 3 号 王五我是 4 号 赵六</code></pre><p>迭代器模式类图如下</p><p><img src="http://image.laijianfeng.org/20181011_214704.jpg" alt="示例.迭代器类图"></p><h2 id="迭代器模式总结"><a href="#迭代器模式总结" class="headerlink" title="迭代器模式总结"></a>迭代器模式总结</h2><p>迭代器模式的<strong>主要优点</strong>如下：</p><ul><li>它支持以不同的方式遍历一个聚合对象，在同一个聚合对象上可以定义多种遍历方式。在迭代器模式中只需要用一个不同的迭代器来替换原有迭代器即可改变遍历算法，我们也可以自己定义迭代器的子类以支持新的遍历方式。</li><li>迭代器简化了聚合类。由于引入了迭代器，在原有的聚合对象中不需要再自行提供数据遍历等方法，这样可以简化聚合类的设计。</li><li>在迭代器模式中，由于引入了抽象层，增加新的聚合类和迭代器类都很方便，无须修改原有代码，满足 “开闭原则” 的要求。</li></ul><p>迭代器模式的<strong>主要缺点</strong>如下：</p><ul><li>由于迭代器模式将存储数据和遍历数据的职责分离，增加新的聚合类需要对应增加新的迭代器类，类的个数成对增加，这在一定程度上增加了系统的复杂性。</li><li>抽象迭代器的设计难度较大，需要充分考虑到系统将来的扩展，例如JDK内置迭代器Iterator就无法实现逆向遍历，如果需要实现逆向遍历，只能通过其子类ListIterator等来实现，而ListIterator迭代器无法用于操作Set类型的聚合对象。在自定义迭代器时，创建一个考虑全面的抽象迭代器并不是件很容易的事情。</li></ul><p><strong>适用场景</strong>:</p><ul><li>访问一个聚合对象的内容而无须暴露它的内部表示。将聚合对象的访问与内部数据的存储分离，使得访问聚合对象时无须了解其内部实现细节。</li><li>需要为一个聚合对象提供多种遍历方式。</li><li>为遍历不同的聚合结构提供一个统一的接口，在该接口的实现类中为不同的聚合结构提供不同的遍历方式，而客户端可以一致性地操作该接口。</li></ul><h2 id="源码分析迭代器模式的典型应用"><a href="#源码分析迭代器模式的典型应用" class="headerlink" title="源码分析迭代器模式的典型应用"></a>源码分析迭代器模式的典型应用</h2><h3 id="Java集合中的迭代器模式"><a href="#Java集合中的迭代器模式" class="headerlink" title="Java集合中的迭代器模式"></a>Java集合中的迭代器模式</h3><p>看 <code>java.util.ArrayList</code> 类</p><pre><code class="java">public class ArrayList&lt;E&gt; extends AbstractList&lt;E&gt; implements List&lt;E&gt;, RandomAccess, Cloneable, java.io.Serializable {    transient Object[] elementData; // non-private to simplify nested class access    private int size;    public E get(int index) {        rangeCheck(index);        return elementData(index);    }    public boolean add(E e) {        ensureCapacityInternal(size + 1);  // Increments modCount!!        elementData[size++] = e;        return true;    }    public ListIterator&lt;E&gt; listIterator() {        return new ListItr(0);    }    public ListIterator&lt;E&gt; listIterator(int index) {        if (index &lt; 0 || index &gt; size)            throw new IndexOutOfBoundsException(&quot;Index: &quot;+index);        return new ListItr(index);    }    public Iterator&lt;E&gt; iterator() {        return new Itr();    }    private class Itr implements Iterator&lt;E&gt; {        int cursor;       // index of next element to return        int lastRet = -1; // index of last element returned; -1 if no such        int expectedModCount = modCount;        public boolean hasNext() {            return cursor != size;        }        public E next() {            //...        }        public E next() {            //...        }        public void remove() {            //...        }        //...    }      private class ListItr extends Itr implements ListIterator&lt;E&gt; {        public boolean hasPrevious() {            return cursor != 0;        }        public int nextIndex() {            return cursor;        }        public int previousIndex() {            return cursor - 1;        }        public E previous() {            //...        }        public void set(E e) {            //...        }        public void add(E e) {            //...        }    //...}</code></pre><p>从 <code>ArrayList</code> 源码中看到了有两个迭代器 <code>Itr</code> 和 <code>ListItr</code>，分别实现 <code>Iterator</code> 和 <code>ListIterator</code> 接口；</p><p>第一个当然很容易看明白，它跟我们示例的迭代器的区别是这里是一个内部类，可以直接使用 <code>ArrayList</code> 的数据列表；第二个迭代器是第一次见到， <code>ListIterator</code> 跟 <code>Iterator</code> 有什么区别呢？</p><p>先看 <code>ListIterator</code> 源码</p><pre><code class="java">public interface ListIterator&lt;E&gt; extends Iterator&lt;E&gt; {    boolean hasNext();    E next();    boolean hasPrevious();  // 返回该迭代器关联的集合是否还有上一个元素    E previous();           // 返回该迭代器的上一个元素    int nextIndex();        // 返回列表中ListIterator所需位置后面元素的索引    int previousIndex();    // 返回列表中ListIterator所需位置前面元素的索引    void remove();    void set(E var1);       // 从列表中将next()或previous()返回的最后一个元素更改为指定元素e    void add(E var1);   }</code></pre><p>接着是 <code>Iterator</code> 的源码</p><pre><code class="java">public interface Iterator&lt;E&gt; {    boolean hasNext();    E next();    default void remove() {        throw new UnsupportedOperationException(&quot;remove&quot;);    }    // 备注：JAVA8允许接口方法定义默认实现    default void forEachRemaining(Consumer&lt;? super E&gt; action) {        Objects.requireNonNull(action);        while (hasNext())            action.accept(next());    }}</code></pre><p>通过源码我们看出：<code>ListIterator</code> 是一个功能更加强大的迭代器，它继承于 <code>Iterator</code> 接口，只能用于各种List类型的访问。可以通过调用 <code>listIterator()</code> 方法产生一个指向List开始处的 <code>ListIterator</code>, 还可以调用 <code>listIterator(n)</code> 方法创建一个一开始就指向列表索引为n的元素处的 <code>ListIterator</code>。</p><p><code>Iterator</code> 和 <code>ListIterator</code> 主要区别概括如下:</p><ul><li><code>ListIterator</code> 有 <code>add()</code> 方法，可以向List中添加对象，而 <code>Iterator</code> 不能</li><li><code>ListIterator</code> 和 <code>Iterator</code> 都有 <code>hasNext()</code> 和 <code>next()</code> 方法，可以实现顺序向后遍历，但是 <code>ListIterator</code> 有 <code>hasPrevious()</code> 和 <code>previous()</code> 方法，可以实现逆向（顺序向前）遍历。<code>Iterator</code> 就不可以。</li><li><code>ListIterator</code> 可以定位当前的索引位置，<code>nextIndex()</code> 和 <code>previousIndex()</code> 可以实现。<code>Iterator</code> 没有此功能。</li><li>都可实现删除对象，但是 <code>ListIterator</code> 可以实现对象的修改，<code>set()</code> 方法可以实现。<code>Iierator</code> 仅能遍历，不能修改。</li></ul><p>敲一个 Iterator 的 Demo 探究一下</p><pre><code class="java">public class Test3 {    public static void main(String[] args) {        List&lt;String&gt; list = new ArrayList&lt;String&gt;();        list.add(&quot;张三&quot;);        list.add(&quot;李四&quot;);        list.add(&quot;王五&quot;);        list.add(&quot;赵六&quot;);        Iterator&lt;String&gt; iterator = list.iterator();        String first = iterator.next();        System.out.println(&quot;first: &quot; + first);        System.out.println(&quot;-----------next-------------&quot;);        while (iterator.hasNext()){            System.out.println(iterator.next());        }        iterator.remove();        System.out.println(&quot;-----------list-------------&quot;);        for (String name: list){            System.out.println(name);        }    }}</code></pre><p>输出结果</p><pre><code>first: 张三-----------next-------------李四王五赵六-----------list-------------张三李四王五</code></pre><p>可以看到 <code>Iterator.remove()</code> 会删除原来的 List 对象的数据</p><p>再敲一个 ListIterator 的 Demo 探究一下</p><pre><code class="java">public class Test2 {    public static void main(String[] args) {        List&lt;String&gt; list = new ArrayList&lt;String&gt;();        list.add(&quot;张三&quot;);        list.add(&quot;李四&quot;);        list.add(&quot;王五&quot;);        list.add(&quot;赵六&quot;);        ListIterator&lt;String&gt; listIterator = list.listIterator();        String first = listIterator.next();        listIterator.set(&quot;小明&quot;);        System.out.println(&quot;first: &quot; + first);        System.out.println(&quot;-----------next-------------&quot;);        listIterator.add(&quot;大明&quot;);        while (listIterator.hasNext()){            System.out.println(listIterator.nextIndex() + &quot;: &quot; + listIterator.next());        }        listIterator.remove();        System.out.println(&quot;------------previous------------&quot;);        while (listIterator.hasPrevious()){            System.out.println(listIterator.previousIndex() + &quot;: &quot; + listIterator.previous());        }        System.out.println(&quot;-----------list-------------&quot;);        for (String name: list){            System.out.println(name);        }    }}</code></pre><p>结果如下</p><pre><code class="java">first: 张三-----------next-------------2: 李四3: 王五4: 赵六------------previous------------3: 王五2: 李四1: 大明0: 小明-----------list-------------小明大明李四王五</code></pre><p>可以看出 <code>ListIterator</code> 的 <code>add</code>、<code>set</code>、<code>remove</code> 方法会直接改变原来的 List 对象，而且可以通过 <code>previous</code> 反向遍历</p><h3 id="Mybatis中的迭代器模式"><a href="#Mybatis中的迭代器模式" class="headerlink" title="Mybatis中的迭代器模式"></a>Mybatis中的迭代器模式</h3><p>当查询数据库返回大量的数据项时可以使用游标 <code>Cursor</code>，利用其中的迭代器可以懒加载数据，避免因为一次性加载所有数据导致内存奔溃，Mybatis 为 <code>Cursor</code> 接口提供了一个默认实现类 <code>DefaultCursor</code>，代码如下</p><pre><code class="java">public interface Cursor&lt;T&gt; extends Closeable, Iterable&lt;T&gt; {    boolean isOpen();    boolean isConsumed();    int getCurrentIndex();}public class DefaultCursor&lt;T&gt; implements Cursor&lt;T&gt; {    private final DefaultResultSetHandler resultSetHandler;    private final ResultMap resultMap;    private final ResultSetWrapper rsw;    private final RowBounds rowBounds;    private final ObjectWrapperResultHandler&lt;T&gt; objectWrapperResultHandler = new ObjectWrapperResultHandler&lt;T&gt;();    // 游标迭代器    private final CursorIterator cursorIterator = new CursorIterator();     protected T fetchNextUsingRowBound() {        T result = fetchNextObjectFromDatabase();        while (result != null &amp;&amp; indexWithRowBound &lt; rowBounds.getOffset()) {            result = fetchNextObjectFromDatabase();        }        return result;    }    @Override    public Iterator&lt;T&gt; iterator() {        if (iteratorRetrieved) {            throw new IllegalStateException(&quot;Cannot open more than one iterator on a Cursor&quot;);        }        iteratorRetrieved = true;        return cursorIterator;    }    private class CursorIterator implements Iterator&lt;T&gt; {        T object;        int iteratorIndex = -1;        @Override        public boolean hasNext() {            if (object == null) {                object = fetchNextUsingRowBound();            }            return object != null;        }        @Override        public T next() {            T next = object;            if (next == null) {                next = fetchNextUsingRowBound();            }            if (next != null) {                object = null;                iteratorIndex++;                return next;            }            throw new NoSuchElementException();        }        @Override        public void remove() {            throw new UnsupportedOperationException(&quot;Cannot remove element from Cursor&quot;);        }    }    // ...}</code></pre><p>游标迭代器 <code>CursorIterator</code> 实现了 <code>java.util.Iterator</code> 迭代器接口，这里的迭代器模式跟 <code>ArrayList</code> 中的迭代器几乎一样</p><blockquote><p>参考：<br>刘伟：设计模式Java版<br>慕课网java设计模式精讲 Debug 方式+内存分析<br><a href="https://blog.csdn.net/weixin_39241397/article/details/79687789" target="_blank" rel="noopener">Java 集合中关于Iterator 和ListIterator的详解</a>   </p></blockquote><h3 id="推荐阅读"><a href="#推荐阅读" class="headerlink" title="推荐阅读"></a>推荐阅读</h3><p><a href="https://mp.weixin.qq.com/s?__biz=MzI1NDU0MTE1NA==&amp;mid=2247483700&amp;idx=1&amp;sn=dd4d23f9400c8be248f5d125465ba941&amp;chksm=e9c2ed39deb5642fb809eca1351f00995f06c9a4875f09986cc5005059eff74d6c20fc1118a3&amp;scene=0#rd" target="_blank" rel="noopener">设计模式 | 简单工厂模式及典型应用</a><br><a href="https://mp.weixin.qq.com/s?__biz=MzI1NDU0MTE1NA==&amp;mid=2247483704&amp;idx=1&amp;sn=fa3ae947cebf22da35e6ac0a37f566f8&amp;chksm=e9c2ed35deb564230a69e43d93a3b74618287c6ddd402a6f1dc6a5b14a896e99584985e7cf92&amp;scene=0#rd" target="_blank" rel="noopener">设计模式 | 工厂方法模式及典型应用</a><br><a href="https://mp.weixin.qq.com/s?__biz=MzI1NDU0MTE1NA==&amp;mid=2247483708&amp;idx=1&amp;sn=9b8c155b86511ea6ec323dc6a72c52df&amp;chksm=e9c2ed31deb56427b2a6bbcbad5bdd3a4ef68b52eb88cc47b5bcfc76773d3d983d8aaf57761c&amp;scene=0#rd" target="_blank" rel="noopener">设计模式 | 抽象工厂模式及典型应用</a><br><a href="https://mp.weixin.qq.com/s?__biz=MzI1NDU0MTE1NA==&amp;mid=2247483712&amp;idx=1&amp;sn=1ffd9837eb9413dde74ff509bf69ecc5&amp;chksm=e9c2ed4ddeb5645b8cbf64c83d103a859ae49921c60e17fe8bebe63c26b04966be101d598848&amp;scene=0#rd" target="_blank" rel="noopener">设计模式 | 建造者模式及典型应用</a><br><a href="https://mp.weixin.qq.com/s?__biz=MzI1NDU0MTE1NA==&amp;mid=2247483716&amp;idx=1&amp;sn=df00c297c8f32e10e277db8941839c14&amp;chksm=e9c2ed49deb5645fa2586da358a8f0a00dd926f883637adebc59435f846c67c040ef759ba034&amp;scene=0#rd" target="_blank" rel="noopener">设计模式 | 原型模式及典型应用</a><br><a href="https://mp.weixin.qq.com/s?__biz=MzI1NDU0MTE1NA==&amp;mid=2247483721&amp;idx=1&amp;sn=721d0bce3bd516c10d4b6addbf3eced6&amp;chksm=e9c2ed44deb56452395c94a0b150994b94aa26cae71149e6c030d0ac32f9c3c37e2bfe9685b6&amp;scene=0#rd" target="_blank" rel="noopener">设计模式 | 外观模式及典型应用</a><br><a href="https://mp.weixin.qq.com/s?__biz=MzI1NDU0MTE1NA==&amp;mid=2247483726&amp;idx=1&amp;sn=df583e5b297ddaff5e1ab822df762274&amp;chksm=e9c2ed43deb56455d2a099f3c3e8622031027d6da00202e6a7d731eac691e4d87d673ca103b5&amp;scene=0#rd" target="_blank" rel="noopener">设计模式 | 装饰者模式及典型应用</a><br><a href="https://mp.weixin.qq.com/s?__biz=MzI1NDU0MTE1NA==&amp;mid=2247483730&amp;idx=1&amp;sn=859feab7f4632b7ba3d1b5a614d57bbe&amp;chksm=e9c2ed5fdeb56449575995778573fa05a3730ac72792d70fc91e38e2d2f5238899f620481d16&amp;scene=0#rd" target="_blank" rel="noopener">设计模式 | 适配器模式及典型应用</a><br><a href="https://mp.weixin.qq.com/s?__biz=MzI1NDU0MTE1NA==&amp;mid=2247483737&amp;idx=1&amp;sn=ed27a42a80b87ff74f1e1266d918ad5b&amp;chksm=e9c2ed54deb56442aba5c95fbddd4c774eb39ebe7ab8c03471a62e3cf3979e303cef43417bac&amp;scene=0#rd" target="_blank" rel="noopener">设计模式 | 享元模式及典型应用</a><br><a href="https://mp.weixin.qq.com/s?__biz=MzI1NDU0MTE1NA==&amp;mid=2247483742&amp;idx=1&amp;sn=436670dc4793c6c9e7207ca6222e062c&amp;chksm=e9c2ed53deb56445c7fb1aef89ab80b23bab96e6f9993618c98e1746209eec05f36b231cfaa8&amp;scene=0#rd" target="_blank" rel="noopener">设计模式 | 组合模式及典型应用</a><br><a href="https://mp.weixin.qq.com/s?__biz=MzI1NDU0MTE1NA==&amp;mid=2247483747&amp;idx=1&amp;sn=aa494215a2933e2424a6daa03587e478&amp;chksm=e9c2ed6edeb564783b9acd9f5372a08d53d04b001ca362c9213c4379bc7e1bff363e4ad01e3c&amp;scene=0#rd" target="_blank" rel="noopener">设计模式 | 模板方法模式及典型应用</a>   </p><p><img src="http://image.laijianfeng.org/20180913_001328.png" alt="关注_小旋锋_微信公众号"></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;本文的主要内容：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;介绍迭代器模式&lt;/li&gt;
&lt;li&gt;源码分析迭代器模式的典型应用&lt;ul&gt;
&lt;li&gt;Java集合中的迭代器模式&lt;/li&gt;
&lt;li&gt;Mybatis中的迭代器模式&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;h2 id=&quot;迭代器模式&quot;
      
    
    </summary>
    
      <category term="后端" scheme="http://laijianfeng.org/categories/%E5%90%8E%E7%AB%AF/"/>
    
    
      <category term="设计模式" scheme="http://laijianfeng.org/tags/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/"/>
    
  </entry>
  
  <entry>
    <title>设计模式 | 模板方法模式及典型应用</title>
    <link href="http://laijianfeng.org/2018/10/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F-%E6%A8%A1%E6%9D%BF%E6%96%B9%E6%B3%95%E6%A8%A1%E5%BC%8F%E5%8F%8A%E5%85%B8%E5%9E%8B%E5%BA%94%E7%94%A8/"/>
    <id>http://laijianfeng.org/2018/10/设计模式-模板方法模式及典型应用/</id>
    <published>2018-10-10T16:22:11.000Z</published>
    <updated>2018-10-10T16:28:29.836Z</updated>
    
    <content type="html"><![CDATA[<p>本文的主要内容：</p><ul><li>介绍模板方法模式</li><li>源码分析模板方法模式的典型应用<ul><li>Servlet 中的模板方法模式</li><li>Mybatis BaseExecutor接口中的模板方法模式</li></ul></li></ul><h2 id="模板方法模式"><a href="#模板方法模式" class="headerlink" title="模板方法模式"></a>模板方法模式</h2><p>在程序开发中，经常会遇到这种情况：某个方法要实现的算法需要多个步骤，但其中有一些步骤是固定不变的，而另一些步骤则是不固定的。为了提高代码的可扩展性和可维护性，模板方法模式在这种场景下就派上了用场。</p><p>譬如制作一节网课的步骤可以简化为4个步骤：</p><ol><li>制作PPT</li><li>录制视频</li><li>编写笔记</li><li>提供课程资料</li></ol><p>其中1、2、3的动作在所有课程中的固定不变的，步骤3可有可无，步骤4在每个课程都不同（有些课程需要提供源代码，有些需要提供图片文件等）</p><p>我们可以在父类中确定整个流程的循序，并实现固定不变的步骤，而把不固定的步骤留给子类实现。甚至可以通过一个钩子方法，让子类来决定流程中某个方法的执行与否</p><p><img src="http://image.laijianfeng.org/20181010_214705.jpg" alt="示例.模板方法模式"></p><p><strong>模板方法模式</strong>：定义一个操作中算法的框架，而将一些步骤延迟到子类中。模板方法模式使得子类可以不改变一个算法的结构即可重定义该算法的某些特定步骤。模板方法模式是一种基于继承的代码复用技术，它是一种类行为型模式。</p><h3 id="角色"><a href="#角色" class="headerlink" title="角色"></a>角色</h3><p><strong>AbstractClass（抽象类）</strong>：在抽象类中定义了一系列基本操作(PrimitiveOperations)，这些基本操作可以是具体的，也可以是抽象的，每一个基本操作对应算法的一个步骤，在其子类中可以重定义或实现这些步骤。同时，在抽象类中实现了一个模板方法(Template Method)，用于定义一个算法的框架，模板方法不仅可以调用在抽象类中实现的基本方法，也可以调用在抽象类的子类中实现的基本方法，还可以调用其他对象中的方法。</p><p><strong>ConcreteClass（具体子类）</strong>：它是抽象类的子类，用于实现在父类中声明的抽象基本操作以完成子类特定算法的步骤，也可以覆盖在父类中已经实现的具体基本操作。</p><p>一个模板方法是定义在抽象类中的、把基本操作方法组合在一起形成一个总算法或一个总行为的方法。这个模板方法定义在抽象类中，并由子类不加以修改地完全继承下来。模板方法是一个具体方法，它给出了一个顶层逻辑框架，而逻辑的组成步骤在抽象类中可以是具体方法，也可以是抽象方法。</p><p>基本方法是实现算法各个步骤的方法，是模板方法的组成部分。基本方法又可以分为三种：抽象方法(Abstract Method)、具体方法(Concrete Method)和钩子方法(Hook Method)。</p><ul><li>抽象方法：一个抽象方法由抽象类声明、由其具体子类实现。</li><li>具体方法：一个具体方法由一个抽象类或具体类声明并实现，其子类可以进行覆盖也可以直接继承。</li><li>钩子方法：可以与一些具体步骤 “挂钩” ，以实现在不同条件下执行模板方法中的不同步骤</li></ul><h2 id="示例"><a href="#示例" class="headerlink" title="示例"></a>示例</h2><p>所以我们通过模板方法模式，在抽象类中把整个流程固定下来，其中1、2、3的实现在抽象类中完成，3的执行与否则由子类通过钩子方法来控制，4则由子类来实现</p><p>抽象类定义如下：</p><pre><code class="java">public abstract class ACourse {    protected final void makeCourse() {        this.makePPT();        this.makeVideo();        if (needWriteArticle()) {            this.writeArticle();        }        this.packageCourse();    }    final void makePPT() {        System.out.println(&quot;1. 制作PPT&quot;);    }    final void makeVideo() {        System.out.println(&quot;2. 制作视频&quot;);    }    final void writeArticle() {        System.out.println(&quot;3. 编写课程笔记&quot;);    }    //钩子方法    protected boolean needWriteArticle() {        return false;    }    abstract void packageCourse();}</code></pre><p>其中的 <code>makeCourse</code> 方法是模板方法，它定义了制作网课的基本流程，<code>makePPT</code>、<code>makeVideo</code>、<code>writeArticle</code> 这三个步骤在所有课程中都是固定的，所以用 <code>final</code> 关键字修饰；<code>packageCourse</code> 方法在所有课程中都可能不一样，所以声明为抽象方法，由子类自行实现；钩子方法 <code>needWriteArticle</code> 返回一个 <code>boolean</code> 类型的值，控制是否编写课程笔记</p><p>子类 JavaCourse，实现了抽象方法 <code>packageCourse</code>，重写了钩子方法 <code>needWriteArticle</code></p><pre><code class="java">public class JavaCourse extends ACourse {    @Override    void packageCourse() {        System.out.println(&quot;4. 提供Java课程源代码&quot;);    }    @Override    protected boolean needWriteArticle() {        return true;    }}</code></pre><p>子类 FECourse，实现了抽象方法 <code>packageCourse</code>，重写了钩子方法 <code>needWriteArticle</code>，其中把钩子方法的结果交给客户端确定</p><pre><code class="java">public class FECourse extends ACourse {    private boolean needWriteArticleFlag = false;    @Override    void packageCourse() {        System.out.println(&quot;4.1 提供课程的前端代码&quot;);        System.out.println(&quot;4.2 提供课程的图片等多媒体素材&quot;);    }    public FECourse(boolean needWriteArticleFlag) {        this.needWriteArticleFlag = needWriteArticleFlag;    }    @Override    protected boolean needWriteArticle() {        return this.needWriteArticleFlag;    }}</code></pre><p>客户端测试</p><pre><code class="java">public class Test {    public static void main(String[] args) {        System.out.println(&quot;Java课程start---&quot;);        ACourse javaCourse = new JavaCourse();        javaCourse.makeCourse();        System.out.println(&quot;Java课程end---\n&quot;);        System.out.println(&quot;前端课程start---&quot;);        ACourse feCourse = new FECourse(false);        feCourse.makeCourse();        System.out.println(&quot;前端课程end---&quot;);    }}</code></pre><p>输出结果</p><pre><code>Java课程start---1. 制作PPT2. 制作视频3. 编写笔记4. 提供Java课程源代码Java课程end---前端课程start---1. 制作PPT2. 制作视频4.1 提供课程的前端代码4.2 提供课程的图片等多媒体素材前端课程end---</code></pre><p>它们的类图如下</p><p><img src="http://image.laijianfeng.org/20181010_213837.png" alt="示例.模板方法模式"></p><h2 id="模板方法模式总结"><a href="#模板方法模式总结" class="headerlink" title="模板方法模式总结"></a>模板方法模式总结</h2><p>模板方法模式的<strong>主要优点</strong>如下：</p><ul><li>在父类中形式化地定义一个算法，而由它的子类来实现细节的处理，在子类实现详细的处理算法时并不会改变算法中步骤的执行次序。</li><li>模板方法模式是一种代码复用技术，它在类库设计中尤为重要，它提取了类库中的公共行为，将公共行为放在父类中，而通过其子类来实现不同的行为，它鼓励我们恰当使用继承来实现代码复用。</li><li>可实现一种反向控制结构，通过子类覆盖父类的钩子方法来决定某一特定步骤是否需要执行。</li><li>在模板方法模式中可以通过子类来覆盖父类的基本方法，不同的子类可以提供基本方法的不同实现，更换和增加新的子类很方便，符合单一职责原则和开闭原则。</li></ul><p>模板方法模式的<strong>主要缺点</strong>如下：</p><ul><li>需要为每一个基本方法的不同实现提供一个子类，如果父类中可变的基本方法太多，将会导致类的个数增加，系统更加庞大，设计也更加抽象，此时，可结合桥接模式来进行设计。</li></ul><p><strong>适用场景</strong>：</p><ul><li>对一些复杂的算法进行分割，将其算法中固定不变的部分设计为模板方法和父类具体方法，而一些可以改变的细节由其子类来实现。即：一次性实现一个算法的不变部分，并将可变的行为留给子类来实现。</li><li>各子类中公共的行为应被提取出来并集中到一个公共父类中以避免代码重复。</li><li>需要通过子类来决定父类算法中某个步骤是否执行，实现子类对父类的反向控制。</li></ul><h2 id="源码分析模板方法模式的典型应用"><a href="#源码分析模板方法模式的典型应用" class="headerlink" title="源码分析模板方法模式的典型应用"></a>源码分析模板方法模式的典型应用</h2><h3 id="Servlet-中的模板方法模式"><a href="#Servlet-中的模板方法模式" class="headerlink" title="Servlet 中的模板方法模式"></a>Servlet 中的模板方法模式</h3><p><code>Servlet</code>（Server Applet）是Java Servlet的简称，用Java编写的服务器端程序，主要功能在于交互式地浏览和修改数据，生成动态Web内容。在每一个 <code>Servlet</code> 都必须要实现 <code>Servlet</code> 接口，<code>GenericServlet</code> 是个通用的、不特定于任何协议的Servlet，它实现了 <code>Servlet</code> 接口，而 <code>HttpServlet</code> 继承于 <code>GenericServlet</code>，实现了 <code>Servlet</code> 接口，为 <code>Servlet</code> 接口提供了处理HTTP协议的通用实现，所以我们定义的 <code>Servlet</code> 只需要继承 <code>HttpServlet</code> 即可。</p><p><img src="http://image.laijianfeng.org/20181010_214703.png" alt="HttpServlet的继承关系"></p><p><code>HttpServlet</code> 的简要代码如下所示</p><pre><code class="java">public abstract class HttpServlet extends GenericServlet {    protected void doGet(HttpServletRequest req, HttpServletResponse resp) throws ServletException, IOException {        // ...    }    protected void doPost(HttpServletRequest req, HttpServletResponse resp) throws ServletException, IOException {        // ...    }    protected void doHead(HttpServletRequest req, HttpServletResponse resp) throws ServletException, IOException {        // ...    }    protected void doPut(HttpServletRequest req, HttpServletResponse resp) throws ServletException, IOException {        // ...    }    protected void doDelete(HttpServletRequest req,  HttpServletResponse resp) throws ServletException, IOException {        // ...    }    protected void doOptions(HttpServletRequest req, HttpServletResponse resp) throws ServletException, IOException {        // ...    }    protected void doTrace(HttpServletRequest req, HttpServletResponse resp) throws ServletException, IOException {        // ...    }    protected void service(HttpServletRequest req, HttpServletResponse resp) throws ServletException, IOException {        String method = req.getMethod();        if (method.equals(METHOD_GET)) {            long lastModified = getLastModified(req);            if (lastModified == -1) {                // servlet doesn&#39;t support if-modified-since, no reason                // to go through further expensive logic                doGet(req, resp);            } else {                long ifModifiedSince = req.getDateHeader(HEADER_IFMODSINCE);                if (ifModifiedSince &lt; lastModified) {                    // If the servlet mod time is later, call doGet()                    // Round down to the nearest second for a proper compare                    // A ifModifiedSince of -1 will always be less                    maybeSetLastModified(resp, lastModified);                    doGet(req, resp);                } else {                    resp.setStatus(HttpServletResponse.SC_NOT_MODIFIED);                }            }        } else if (method.equals(METHOD_HEAD)) {            long lastModified = getLastModified(req);            maybeSetLastModified(resp, lastModified);            doHead(req, resp);        } else if (method.equals(METHOD_POST)) {            doPost(req, resp);        } else if (method.equals(METHOD_PUT)) {            doPut(req, resp);        } else if (method.equals(METHOD_DELETE)) {            doDelete(req, resp);        } else if (method.equals(METHOD_OPTIONS)) {            doOptions(req,resp);        } else if (method.equals(METHOD_TRACE)) {            doTrace(req,resp);        } else {            //            // Note that this means NO servlet supports whatever            // method was requested, anywhere on this server.            //            String errMsg = lStrings.getString(&quot;http.method_not_implemented&quot;);            Object[] errArgs = new Object[1];            errArgs[0] = method;            errMsg = MessageFormat.format(errMsg, errArgs);            resp.sendError(HttpServletResponse.SC_NOT_IMPLEMENTED, errMsg);        }    }    // ...省略...}</code></pre><p>在 <code>HttpServlet</code> 的 <code>service</code> 方法中，首先获得到请求的方法名，然后根据方法名调用对应的 <code>doXXX</code> 方法，比如说请求方法为GET，那么就去调用 <code>doGet</code> 方法；请求方法为POST，那么就去调用 <code>doPost</code> 方法</p><p><code>HttpServlet</code> 相当于定义了一套处理 HTTP 请求的模板；<code>service</code> 方法为模板方法，定义了处理HTTP请求的基本流程；<code>doXXX</code> 等方法为基本方法，根据请求方法做相应的处理，子类可重写这些方法；<code>HttpServletRequest</code> 中的Method则起到钩子方法的作用.</p><p>在开发javaWeb应用时，自定义的Servlet类一般都扩展 <code>HttpServlet</code> 类，譬如我们实现一个输出 <code>Hello World!</code> 的 <code>Servlet</code> 如下</p><pre><code class="java">import java.io.*;import javax.servlet.*;import javax.servlet.http.*;// 扩展 HttpServlet 类public class HelloWorld extends HttpServlet {  public void init() throws ServletException {    // ...  }  public void doGet(HttpServletRequest request, HttpServletResponse response) throws ServletException, IOException {      response.setContentType(&quot;text/html&quot;);      PrintWriter out = response.getWriter();      out.println(&quot;&lt;h1&gt;Hello World!&lt;/h1&gt;&quot;);  }  public void destroy() {      // ...  }}</code></pre><p>该自定义的 <code>Servlet</code> 重写了 <code>doGet</code> 方法，当客户端发起 GET 请求时将得到 <code>&lt;h1&gt;Hello World!&lt;/h1&gt;</code>。</p><h3 id="Mybatis-BaseExecutor接口中的模板方法模式"><a href="#Mybatis-BaseExecutor接口中的模板方法模式" class="headerlink" title="Mybatis BaseExecutor接口中的模板方法模式"></a>Mybatis BaseExecutor接口中的模板方法模式</h3><p><code>Executor</code> 是 Mybatis 的核心接口之一，其中定义了数据库操作的基本方法，该接口的代码如下：</p><pre><code>public interface Executor {  ResultHandler NO_RESULT_HANDLER = null;  // 执行 update、insert、delete 三种类型的SQL语句  int update(MappedStatement ms, Object parameter) throws SQLException;  // 执行selete类型的SQL语句，返回值分为结果对象列表或游标对象  &lt;E&gt; List&lt;E&gt; query(MappedStatement ms, Object parameter, RowBounds rowBounds, ResultHandler resultHandler, CacheKey cacheKey, BoundSql boundSql) throws SQLException;  /  &lt;E&gt; List&lt;E&gt; query(MappedStatement ms, Object parameter, RowBounds rowBounds, ResultHandler resultHandler) throws SQLException;  &lt;E&gt; Cursor&lt;E&gt; queryCursor(MappedStatement ms, Object parameter, RowBounds rowBounds) throws SQLException;   // 批量执行SQL语句  List&lt;BatchResult&gt; flushStatements() throws SQLException;  // 提交事务  void commit(boolean required) throws SQLException;  // 回滚事务  void rollback(boolean required) throws SQLException;  // 创建缓存中用到的CacheKey对象  CacheKey createCacheKey(MappedStatement ms, Object parameterObject, RowBounds rowBounds, BoundSql boundSql);  // 根据CacheKey对象查找缓存  boolean isCached(MappedStatement ms, CacheKey key);  // 清空一级缓存  void clearLocalCache();  // 延迟加载一级缓存中的数据  void deferLoad(MappedStatement ms, MetaObject resultObject, String property, CacheKey key, Class&lt;?&gt; targetType);  // 获取事务对象  Transaction getTransaction();  // 关闭Executor对象  void close(boolean forceRollback);  // 检测Executor是否已关闭  boolean isClosed();  void setExecutorWrapper(Executor executor);}</code></pre><p><code>Executor</code> 类的类图如下</p><p><img src="http://image.laijianfeng.org/20181010_214704.png" alt="Executor与其子类的类图"></p><p><code>BaseExecutor</code> 中主要提供了缓存管理和事务管理的基本功能，继承 <code>BaseExecutor</code> 的子类只需要实现四个基本方法来完成数据库的相关操作即可，这四个方法分别是：<code>doUpdate()</code> 方法、<code>doQuery()</code> 方法、<code>doQueryCursor()</code> 方法、<code>doFlushStatement()</code> 方法，其余功能都在 <code>BaseExecutor</code> 中实现。</p><p><code>BaseExecutor</code>的部分代码如下，其中的 <code>query()</code> 方法首先会创建 <code>CacheKey</code> 对象，并根据 <code>CacheKey</code> 对象查找一级缓存，如果缓存命中则返回缓存中记录的结果对象，如果未命中则查询数据库得到结果集，之后将结果集映射成结果对象并保存到一级缓存中，同时返回结果对象。</p><pre><code class="java">public abstract class BaseExecutor implements Executor {  protected Transaction transaction;  protected Executor wrapper;  protected ConcurrentLinkedQueue&lt;DeferredLoad&gt; deferredLoads;  protected PerpetualCache localCache;  protected PerpetualCache localOutputParameterCache;  protected Configuration configuration;  protected int queryStack = 0;  private boolean closed;  @Override  public &lt;E&gt; List&lt;E&gt; query(MappedStatement ms, Object parameter, RowBounds rowBounds, ResultHandler resultHandler, CacheKey key, BoundSql boundSql) throws SQLException {    ErrorContext.instance().resource(ms.getResource()).activity(&quot;executing a query&quot;).object(ms.getId());    if (closed) {      throw new ExecutorException(&quot;Executor was closed.&quot;);    }    if (queryStack == 0 &amp;&amp; ms.isFlushCacheRequired()) {      clearLocalCache();    }    List&lt;E&gt; list;    try {      queryStack++;      list = resultHandler == null ? (List&lt;E&gt;) localCache.getObject(key) : null;      if (list != null) {        handleLocallyCachedOutputParameters(ms, key, parameter, boundSql);      } else {        list = queryFromDatabase(ms, parameter, rowBounds, resultHandler, key, boundSql);      }    } finally {      queryStack--;    }    if (queryStack == 0) {      for (DeferredLoad deferredLoad : deferredLoads) {        deferredLoad.load();      }      // issue #601      deferredLoads.clear();      if (configuration.getLocalCacheScope() == LocalCacheScope.STATEMENT) {        // issue #482        clearLocalCache();      }    }    return list;  }  protected abstract int doUpdate(MappedStatement ms, Object parameter)      throws SQLException;  protected abstract List&lt;BatchResult&gt; doFlushStatements(boolean isRollback)      throws SQLException;  protected abstract &lt;E&gt; List&lt;E&gt; doQuery(MappedStatement ms, Object parameter, RowBounds rowBounds, ResultHandler resultHandler, BoundSql boundSql)      throws SQLException;  protected abstract &lt;E&gt; Cursor&lt;E&gt; doQueryCursor(MappedStatement ms, Object parameter, RowBounds rowBounds, BoundSql boundSql)      throws SQLException;  // 省略....}</code></pre><p><code>BaseExecutor</code> 的子类有四个分别是 <code>SimpleExecotor</code>、<code>ReuseExecutor</code>、<code>BatchExecutor</code>、<code>ClosedExecutor</code>，由于这里使用了模板方法模式，一级缓存等固定不变的操作都封装到了 <code>BaseExecutor</code> 中，因此子类就不必再关心一级缓存等操作，只需要专注实现4个基本方法的实现即可。</p><p>这里对这四个子类的功能做一个简要的介绍：</p><ul><li><code>SimpleExecutor</code> 是Mybatis执行Mapper语句时默认使用的 <code>Executor</code>，提供最基本的Mapper语句执行功能，没有过多的封装的</li><li><code>ReuseExecutor</code> 提供了 <code>Statement</code> 重用的功能，通过 <code>statementMap</code> 字段缓存使用过的 <code>Statement</code> 对象进行重用，可以减少SQL预编译以及创建和销毁 <code>Statement</code> 对象的开销，从而提高性能</li><li><code>BatchExecutor</code> 实现了批处理多条SQL语句的功能，在客户端缓存多条SQL并在合适的时机将多条SQL打包发送给数据库执行，从而减少网络方面的开销，提升系统的性能</li><li><code>ClosedExecutor</code> 只是某个类的一个内部类</li></ul><blockquote><p>参考：<br>刘伟：设计模式Java版<br>慕课网java设计模式精讲 Debug 方式+内存分析<br>徐郡明：Mybatis技术内幕 3.6 Executor</p></blockquote><h3 id="推荐阅读"><a href="#推荐阅读" class="headerlink" title="推荐阅读"></a>推荐阅读</h3><p><a href="https://mp.weixin.qq.com/s?__biz=MzI1NDU0MTE1NA==&amp;mid=2247483700&amp;idx=1&amp;sn=dd4d23f9400c8be248f5d125465ba941&amp;chksm=e9c2ed39deb5642fb809eca1351f00995f06c9a4875f09986cc5005059eff74d6c20fc1118a3&amp;scene=0#rd" target="_blank" rel="noopener">设计模式 | 简单工厂模式及典型应用</a><br><a href="https://mp.weixin.qq.com/s?__biz=MzI1NDU0MTE1NA==&amp;mid=2247483704&amp;idx=1&amp;sn=fa3ae947cebf22da35e6ac0a37f566f8&amp;chksm=e9c2ed35deb564230a69e43d93a3b74618287c6ddd402a6f1dc6a5b14a896e99584985e7cf92&amp;scene=0#rd" target="_blank" rel="noopener">设计模式 | 工厂方法模式及典型应用</a><br><a href="https://mp.weixin.qq.com/s?__biz=MzI1NDU0MTE1NA==&amp;mid=2247483708&amp;idx=1&amp;sn=9b8c155b86511ea6ec323dc6a72c52df&amp;chksm=e9c2ed31deb56427b2a6bbcbad5bdd3a4ef68b52eb88cc47b5bcfc76773d3d983d8aaf57761c&amp;scene=0#rd" target="_blank" rel="noopener">设计模式 | 抽象工厂模式及典型应用</a><br><a href="https://mp.weixin.qq.com/s?__biz=MzI1NDU0MTE1NA==&amp;mid=2247483712&amp;idx=1&amp;sn=1ffd9837eb9413dde74ff509bf69ecc5&amp;chksm=e9c2ed4ddeb5645b8cbf64c83d103a859ae49921c60e17fe8bebe63c26b04966be101d598848&amp;scene=0#rd" target="_blank" rel="noopener">设计模式 | 建造者模式及典型应用</a><br><a href="https://mp.weixin.qq.com/s?__biz=MzI1NDU0MTE1NA==&amp;mid=2247483716&amp;idx=1&amp;sn=df00c297c8f32e10e277db8941839c14&amp;chksm=e9c2ed49deb5645fa2586da358a8f0a00dd926f883637adebc59435f846c67c040ef759ba034&amp;scene=0#rd" target="_blank" rel="noopener">设计模式 | 原型模式及典型应用</a><br><a href="https://mp.weixin.qq.com/s?__biz=MzI1NDU0MTE1NA==&amp;mid=2247483721&amp;idx=1&amp;sn=721d0bce3bd516c10d4b6addbf3eced6&amp;chksm=e9c2ed44deb56452395c94a0b150994b94aa26cae71149e6c030d0ac32f9c3c37e2bfe9685b6&amp;scene=0#rd" target="_blank" rel="noopener">设计模式 | 外观模式及典型应用</a><br><a href="https://mp.weixin.qq.com/s?__biz=MzI1NDU0MTE1NA==&amp;mid=2247483726&amp;idx=1&amp;sn=df583e5b297ddaff5e1ab822df762274&amp;chksm=e9c2ed43deb56455d2a099f3c3e8622031027d6da00202e6a7d731eac691e4d87d673ca103b5&amp;scene=0#rd" target="_blank" rel="noopener">设计模式 | 装饰者模式及典型应用</a><br><a href="https://mp.weixin.qq.com/s?__biz=MzI1NDU0MTE1NA==&amp;mid=2247483730&amp;idx=1&amp;sn=859feab7f4632b7ba3d1b5a614d57bbe&amp;chksm=e9c2ed5fdeb56449575995778573fa05a3730ac72792d70fc91e38e2d2f5238899f620481d16&amp;scene=0#rd" target="_blank" rel="noopener">设计模式 | 适配器模式及典型应用</a><br><a href="https://mp.weixin.qq.com/s?__biz=MzI1NDU0MTE1NA==&amp;mid=2247483737&amp;idx=1&amp;sn=ed27a42a80b87ff74f1e1266d918ad5b&amp;chksm=e9c2ed54deb56442aba5c95fbddd4c774eb39ebe7ab8c03471a62e3cf3979e303cef43417bac&amp;scene=0#rd" target="_blank" rel="noopener">设计模式 | 享元模式及典型应用</a><br><a href="https://mp.weixin.qq.com/s?__biz=MzI1NDU0MTE1NA==&amp;mid=2247483742&amp;idx=1&amp;sn=436670dc4793c6c9e7207ca6222e062c&amp;chksm=e9c2ed53deb56445c7fb1aef89ab80b23bab96e6f9993618c98e1746209eec05f36b231cfaa8&amp;scene=0#rd" target="_blank" rel="noopener">设计模式 | 组合模式及典型应用</a></p><p><img src="http://image.laijianfeng.org/20180913_001328.png" alt="关注_小旋锋_微信公众号"></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;本文的主要内容：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;介绍模板方法模式&lt;/li&gt;
&lt;li&gt;源码分析模板方法模式的典型应用&lt;ul&gt;
&lt;li&gt;Servlet 中的模板方法模式&lt;/li&gt;
&lt;li&gt;Mybatis BaseExecutor接口中的模板方法模式&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
      
    
    </summary>
    
      <category term="后端" scheme="http://laijianfeng.org/categories/%E5%90%8E%E7%AB%AF/"/>
    
    
      <category term="设计模式" scheme="http://laijianfeng.org/tags/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/"/>
    
  </entry>
  
</feed>
