<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>小旋锋</title>
  
  <subtitle>更努力，只为了我们想要的明天</subtitle>
  <link href="/atom.xml" rel="self"/>
  
  <link href="http://laijianfeng.org/"/>
  <updated>2018-10-25T16:49:32.583Z</updated>
  <id>http://laijianfeng.org/</id>
  
  <author>
    <name>小旋锋</name>
    
  </author>
  
  <generator uri="http://hexo.io/">Hexo</generator>
  
  <entry>
    <title>设计模式 | 中介者模式及典型应用</title>
    <link href="http://laijianfeng.org/2018/10/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F-%E4%B8%AD%E4%BB%8B%E8%80%85%E6%A8%A1%E5%BC%8F%E5%8F%8A%E5%85%B8%E5%9E%8B%E5%BA%94%E7%94%A8/"/>
    <id>http://laijianfeng.org/2018/10/设计模式-中介者模式及典型应用/</id>
    <published>2018-10-25T16:45:30.000Z</published>
    <updated>2018-10-25T16:49:32.583Z</updated>
    
    <content type="html"><![CDATA[<p>本文的主要内容：</p><ul><li>介绍中介者模式</li><li>数据同步示例</li><li>中介者模式总结</li><li>源码分析中介者模式的典型应用<ul><li>Java Timer 中的中介者模式</li></ul></li></ul><h2 id="中介者模式"><a href="#中介者模式" class="headerlink" title="中介者模式"></a>中介者模式</h2><p>世界上存在着各种各样的数据库，不同数据库有各自的应用场景，对于同一份数据，最开始可能使用关系型数据库（如MySQL）进行存储查询，使用Redis作为缓存数据库，当数据量较大时使用MySQL进行查询可能较慢，所以需要将数据同步到Elasticsearch或者列式数据库如Hbase中进行大数据查询。</p><p><strong>如何设计数据同步方案</strong>是一个重要的问题。数据源众多，目标端也众多，设计得不好可能 “牵一发而动全身”。</p><p>如果我们这样设计：每个数据源直接同步数据到目标端数据库的，如果数据库有 N 个，那么最多可能的同步作业将达到 <code>N * N</code> 个，当修改了其中一个数据库的某些配置，可能需要修改另外的 <code>N - 1</code> 个数据库的同步作业。</p><p>现在介绍另一种方案，DataX 是阿里巴巴集团内被广泛使用的离线数据同步工具/平台，实现包括 MySQL、Oracle、SqlServer、Postgre、HDFS、Hive、ADS、HBase、TableStore(OTS)、MaxCompute(ODPS)、DRDS 等各种异构数据源之间高效的数据同步功能。</p><p><img src="http://image.laijianfeng.org/datax-sync.png" alt="DataX"></p><p>DataX 其实相当于一个中介，从数据源读取数据，写入到目标端，数据源不再需要维护到目标端的同步作业，只需要与 DataX 通信即可。DataX 体现了中介者模式的思想。</p><p><strong>中介者模式(Mediator Pattern)</strong>：用一个中介对象（中介者）来封装一系列的对象交互，中介者使各对象不需要显式地相互引用，从而使其耦合松散，而且可以独立地改变它们之间的交互。中介者模式又称为调停者模式，它是一种对象行为型模式。</p><h3 id="角色"><a href="#角色" class="headerlink" title="角色"></a>角色</h3><p><strong>Mediator（抽象中介者）</strong>：它定义一个接口，该接口用于与各同事对象之间进行通信。</p><p><strong>ConcreteMediator（具体中介者）</strong>：它是抽象中介者的子类，通过协调各个同事对象来实现协作行为，它维持了对各个同事对象的引用。</p><p><strong>Colleague（抽象同事类）</strong>：它定义各个同事类公有的方法，并声明了一些抽象方法来供子类实现，同时它维持了一个对抽象中介者类的引用，其子类可以通过该引用来与中介者通信。</p><p><strong>ConcreteColleague（具体同事类）</strong>：它是抽象同事类的子类；每一个同事对象在需要和其他同事对象通信时，先与中介者通信，通过中介者来间接完成与其他同事类的通信；在具体同事类中实现了在抽象同事类中声明的抽象方法。</p><p>中介者模式的核心在于中介者类的引入，在中介者模式中，<strong>中介者类承担了两方面的职责</strong>：</p><ul><li><strong>中转作用（结构性）</strong>：通过中介者提供的中转作用，各个同事对象就不再需要显式引用其他同事，当需要和其他同事进行通信时，可通过中介者来实现间接调用。该中转作用属于中介者在结构上的支持。</li><li><strong>协调作用（行为性）</strong>：中介者可以更进一步的对同事之间的关系进行封装，同事可以一致的和中介者进行交互，而不需要指明中介者需要具体怎么做，中介者根据封装在自身内部的协调逻辑，对同事的请求进行进一步处理，将同事成员之间的关系行为进行分离和封装。</li></ul><h2 id="示例"><a href="#示例" class="headerlink" title="示例"></a>示例</h2><p>我们来实现一个简化版的数据同步方案，有三种数据库 Mysql、Redis、Elasticsearch，其中的 Mysql 作为主数据库，当增加一条数据时<strong>需要</strong>同步到另外两个数据库中；Redis 作为缓存数据库，当增加一条数据时<strong>不需要</strong>同步到另外另个数据库；而 Elasticsearch 作为大数据查询数据库，有一个统计功能，当增加一条数据时<strong>只需要</strong>同步到 Mysql，所以它们之间的关系图如下所示。</p><p><img src="http://image.laijianfeng.org/20181025_193152.jpg" alt="简化的数据同步需求"></p><p>首先我们来实现第一种<strong>不使用</strong>中介者模式的数据同步方案，各数据源维护各自的同步作业。</p><p>抽象数据库</p><pre><code class="java">public abstract class AbstractDatabase {    public abstract void add(String data);    public abstract void addData(String data);}</code></pre><p>具体数据库 Mysql，维护同步到 Redis和Elasticsearch 的同步作业</p><pre><code class="java">public class MysqlDatabase extends AbstractDatabase {    private List&lt;String&gt; dataset = new ArrayList&lt;String&gt;();    @Setter    private RedisDatabase redisDatabase;    @Setter    private EsDatabase esDatabase;    @Override    public void addData(String data) {        System.out.println(&quot;Mysql 添加数据：&quot; + data);        this.dataset.add(data);    }    @Override    public void add(String data) {        addData(data);        this.redisDatabase.addData(data);   // 维护同步到Redis的同步作业        this.esDatabase.addData(data);  // 维护同步到Elasticsearch的同步作业    }    public void select() {        System.out.println(&quot;- Mysql 查询，数据：&quot; + this.dataset.toString());    }}</code></pre><p>具体数据库 Redis，不需要同步到其它数据库</p><pre><code class="java">public class RedisDatabase extends AbstractDatabase {    private List&lt;String&gt; dataset = new LinkedList&lt;String&gt;();    @Override    public void addData(String data) {        System.out.println(&quot;Redis 添加数据：&quot; + data);        this.dataset.add(data);    }    @Override    public void add(String data) {        addData(data); // 不同步到其它数据库    }    public void cache() {        System.out.println(&quot;- Redis 缓存的数据：&quot; + this.dataset.toString());    }}</code></pre><p>Elasticsearch ，只需要同步到Mysql</p><pre><code class="java">public class EsDatabase extends AbstractDatabase {    private List&lt;String&gt; dataset = new CopyOnWriteArrayList&lt;String&gt;();    @Setter    private MysqlDatabase mysqlDatabase;    @Override    public void addData(String data) {        System.out.println(&quot;ES 添加数据：&quot; + data);        this.dataset.add(data);    }    @Override    public void add(String data) {        addData(data);        this.mysqlDatabase.addData(data);   // 维护同步到MySQL的同步作业    }    public void count() {        int count = this.dataset.size();        System.out.println(&quot;- Elasticsearch 统计，目前有 &quot; + count + &quot; 条数据，数据：&quot; + this.dataset.toString());    }}</code></pre><p>测试客户端，分别往三个数据库中加入一些数据查看同步效果</p><pre><code class="java">public class Client {    public static void main(String[] args) {        MysqlDatabase mysqlDatabase = new MysqlDatabase();        RedisDatabase redisDatabase = new RedisDatabase();        EsDatabase esDatabase = new EsDatabase();        mysqlDatabase.setRedisDatabase(redisDatabase);        mysqlDatabase.setEsDatabase(esDatabase);        esDatabase.setMysqlDatabase(mysqlDatabase);        System.out.println(&quot;\n---------mysql 添加数据 1，将同步到Redis和ES中-----------&quot;);        mysqlDatabase.add(&quot;1&quot;);        mysqlDatabase.select();        redisDatabase.cache();        esDatabase.count();        System.out.println(&quot;\n---------Redis添加数据 2，将不同步到其它数据库-----------&quot;);        redisDatabase.add(&quot;2&quot;);        mysqlDatabase.select();        redisDatabase.cache();        esDatabase.count();        System.out.println(&quot;\n---------ES 添加数据 3，只同步到 Mysql-----------&quot;);        esDatabase.add(&quot;3&quot;);        mysqlDatabase.select();        redisDatabase.cache();        esDatabase.count();    }}</code></pre><p>输出结果</p><pre><code class="java">---------mysql 添加数据 1，将同步到Redis和ES中-----------Mysql 添加数据：1Redis 添加数据：1ES 添加数据：1- Mysql 查询，数据：[1]- Redis 缓存的数据：[1]- Elasticsearch 统计，目前有 1 条数据，数据：[1]---------Redis添加数据 2，将不同步到其它数据库-----------Redis 添加数据：2- Mysql 查询，数据：[1]- Redis 缓存的数据：[1, 2]- Elasticsearch 统计，目前有 1 条数据，数据：[1]---------ES 添加数据 3，只同步到 Mysql-----------ES 添加数据：3Mysql 添加数据：3- Mysql 查询，数据：[1, 3]- Redis 缓存的数据：[1, 2]- Elasticsearch 统计，目前有 2 条数据，数据：[1, 3]</code></pre><p>其实这样已经实现了我们的需求，但是<strong>存在一些问题</strong>：</p><ul><li><strong>系统结构复杂且耦合度高</strong>。数据源需要维护目标端数据库的引用，以便完成数据同步</li><li><strong>组件的可重用性差</strong>。由于每一个数据源和目标端之间具有很强的关联，若没有目标端的支持，这个组件很难被另一个系统或模块重用</li><li><strong>系统的可扩展性差</strong>：如果需要增加、修改或删除其中一个数据库、将导致多个类的源代码需要修改，这违反了 “开闭原则”，可扩展性和灵活性欠佳。</li></ul><p>我们<strong>使用中介者模式来重构</strong>，将数据同步的功能迁移到中介者中，由中介者来管理数据同步作业</p><p>首先还是抽象数据库类（抽象同事类），维护了一个中介者</p><pre><code class="java">public abstract class AbstractDatabase {    public static final String MYSQL = &quot;mysql&quot;;    public static final String REDIS = &quot;redis&quot;;    public static final String ELASTICSEARCH = &quot;elasticsearch&quot;;    protected AbstractMediator mediator;    // 中介者    public AbstractDatabase(AbstractMediator mediator) {        this.mediator = mediator;    }    public abstract void addData(String data);    public abstract void add(String data);}</code></pre><p>Mysql 数据库（具体同事类）</p><pre><code class="java">public class MysqlDatabase extends AbstractDatabase {    private List&lt;String&gt; dataset = new ArrayList&lt;String&gt;();    public MysqlDatabase(AbstractMediator mediator) {        super(mediator);    }    @Override    public void addData(String data) {        System.out.println(&quot;Mysql 添加数据：&quot; + data);        this.dataset.add(data);    }    @Override    public void add(String data) {        addData(data);        this.mediator.sync(AbstractDatabase.MYSQL, data); // 数据同步作业交给中介者管理    }    public void select() {        System.out.println(&quot;Mysql 查询，数据：&quot; + this.dataset.toString());    }}</code></pre><p>Redis 数据库（具体同事类）</p><pre><code class="java">public class RedisDatabase extends AbstractDatabase {    private List&lt;String&gt; dataset = new LinkedList&lt;String&gt;();    public RedisDatabase(AbstractMediator mediator) {        super(mediator);    }    @Override    public void addData(String data) {        System.out.println(&quot;Redis 添加数据：&quot; + data);        this.dataset.add(data);    }    @Override    public void add(String data) {        addData(data);        this.mediator.sync(AbstractDatabase.REDIS, data);    // 数据同步作业交给中介者管理    }    public void cache() {        System.out.println(&quot;Redis 缓存的数据：&quot; + this.dataset.toString());    }}</code></pre><p>Elasticsearch（具体同事类）</p><pre><code class="java">public class EsDatabase extends AbstractDatabase {    private List&lt;String&gt; dataset = new CopyOnWriteArrayList&lt;String&gt;();    public EsDatabase(AbstractMediator mediator) {        super(mediator);    }    @Override    public void addData(String data) {        System.out.println(&quot;ES 添加数据：&quot; + data);        this.dataset.add(data);    }    @Override    public void add(String data) {        addData(data);        this.mediator.sync(AbstractDatabase.ELASTICSEARCH, data);    // 数据同步作业交给中介者管理    }    public void count() {        int count = this.dataset.size();        System.out.println(&quot;Elasticsearch 统计，目前有 &quot; + count + &quot; 条数据，数据：&quot; + this.dataset.toString());    }}</code></pre><p>抽象中介者</p><pre><code class="java">@Datapublic abstract class AbstractMediator {    protected MysqlDatabase mysqlDatabase;    protected RedisDatabase redisDatabase;    protected EsDatabase esDatabase;    public abstract void sync(String databaseName, String data);}</code></pre><p>具体中介者</p><pre><code class="java">public class SyncMediator extends AbstractMediator {    @Override    public void sync(String databaseName, String data) {        if (AbstractDatabase.MYSQL.equals(databaseName)) {            // mysql 同步到 redis 和 Elasticsearch            this.redisDatabase.addData(data);            this.esDatabase.addData(data);        } else if (AbstractDatabase.REDIS.equals(databaseName)) {            // redis 缓存同步，不需要同步到其他数据库        } else if (AbstractDatabase.ELASTICSEARCH.equals(databaseName)) {            // Elasticsearch 同步到 Mysql            this.mysqlDatabase.addData(data);        }    }}</code></pre><p>测试客户端</p><pre><code class="java">public class Client {    public static void main(String[] args) {        AbstractMediator syncMediator = new SyncMediator();        MysqlDatabase mysqlDatabase = new MysqlDatabase(syncMediator);        RedisDatabase redisDatabase = new RedisDatabase(syncMediator);        EsDatabase esDatabase = new EsDatabase(syncMediator);        syncMediator.setMysqlDatabase(mysqlDatabase);        syncMediator.setRedisDatabase(redisDatabase);        syncMediator.setEsDatabase(esDatabase);        System.out.println(&quot;\n---------mysql 添加数据 1，将同步到Redis和ES中-----------&quot;);        mysqlDatabase.add(&quot;1&quot;);        mysqlDatabase.select();        redisDatabase.cache();        esDatabase.count();        System.out.println(&quot;\n---------Redis添加数据 2，将不同步到其它数据库-----------&quot;);        redisDatabase.add(&quot;2&quot;);        mysqlDatabase.select();        redisDatabase.cache();        esDatabase.count();        System.out.println(&quot;\n---------ES 添加数据 3，只同步到 Mysql-----------&quot;);        esDatabase.add(&quot;3&quot;);        mysqlDatabase.select();        redisDatabase.cache();        esDatabase.count();    }}</code></pre><p>输出结果，与预期一致</p><pre><code>---------mysql 添加数据 1，将同步到Redis和ES中-----------Mysql 添加数据：1Redis 添加数据：1ES 添加数据：1- Mysql 查询，数据：[1]- Redis 缓存的数据：[1]- Elasticsearch 统计，目前有 1 条数据，数据：[1]---------Redis添加数据 2，将不同步到其它数据库-----------Redis 添加数据：2- Mysql 查询，数据：[1]- Redis 缓存的数据：[1, 2]- Elasticsearch 统计，目前有 1 条数据，数据：[1]---------ES 添加数据 3，只同步到 Mysql-----------ES 添加数据：3Mysql 添加数据：3- Mysql 查询，数据：[1, 3]- Redis 缓存的数据：[1, 2]- Elasticsearch 统计，目前有 2 条数据，数据：[1, 3]</code></pre><p>画出类图如下</p><p><img src="http://image.laijianfeng.org/20181025_193153.png" alt="示例.中介者模式"></p><h2 id="中介者模式总结"><a href="#中介者模式总结" class="headerlink" title="中介者模式总结"></a>中介者模式总结</h2><h3 id="中介者模式的主要优点"><a href="#中介者模式的主要优点" class="headerlink" title="中介者模式的主要优点"></a>中介者模式的主要优点</h3><ul><li><p>中介者模式<strong>简化了对象之间的交互</strong>，它用中介者和同事的一对多交互代替了原来同事之间的多对多交互，一对多关系更容易理解、维护和扩展，将原本难以理解的网状结构转换成相对简单的星型结构。</p></li><li><p>中介者模式可<strong>将各同事对象解耦</strong>。中介者有利于各同事之间的松耦合，我们可以独立的改变和复用每一个同事和中介者，增加新的中介者和新的同事类都比较方便，更好地符合 “开闭原则”。</p></li><li><p>可以<strong>减少子类生成</strong>，中介者将原本分布于多个对象间的行为集中在一起，改变这些行为只需生成新的中介者子类即可，这使各个同事类可被重用，无须对同事类进行扩展。</p></li></ul><h3 id="中介者模式的主要缺点"><a href="#中介者模式的主要缺点" class="headerlink" title="中介者模式的主要缺点"></a>中介者模式的主要缺点</h3><ul><li>在<strong>具体中介者类中包含了大量同事之间的交互细节</strong>，可能会导致具体中介者类非常复杂，使得系统难以维护。（也就是把具体同事类之间的交互复杂性集中到了中介者类中，结果中介者成了最复杂的类）</li></ul><h3 id="适用场景"><a href="#适用场景" class="headerlink" title="适用场景"></a>适用场景</h3><ul><li><p>系统中对象之间存在复杂的引用关系，系统结构混乱且难以理解。</p></li><li><p>一个对象由于引用了其他很多对象并且直接和这些对象通信，导致难以复用该对象。</p></li><li><p>想通过一个中间类来封装多个类中的行为，而又不想生成太多的子类。可以通过引入中介者类来实现，在中介者中定义对象交互的公共行为，如果需要改变行为则可以增加新的具体中介者类。</p></li></ul><h2 id="中介者模式的典型应用"><a href="#中介者模式的典型应用" class="headerlink" title="中介者模式的典型应用"></a>中介者模式的典型应用</h2><h3 id="Java-Timer-中的中介者模式"><a href="#Java-Timer-中的中介者模式" class="headerlink" title="Java Timer 中的中介者模式"></a>Java Timer 中的中介者模式</h3><p>敲一个 <code>java.util.Timer</code> 的Demo</p><p>两个任务类</p><pre><code class="java">public class MyOneTask extends TimerTask {    private static int num = 0;    @Override    public void run() {        System.out.println(&quot;I&#39;m MyOneTask &quot; + ++num);    }}public class MyTwoTask extends TimerTask {    private static int num = 1000;    @Override    public void run() {        System.out.println(&quot;I&#39;m MyTwoTask &quot; + num--);    }}</code></pre><p>客户端测试，3秒后开始执行，循环周期为 1秒</p><pre><code class="java">public class TimerTest {    public static void main(String[] args) {        // 注意：多线程并行处理定时任务时，Timer运行多个TimeTask时，只要其中之一没有捕获抛出的异常，        // 其它任务便会自动终止运行，使用ScheduledExecutorService则没有这个问题        Timer timer = new Timer();        timer.schedule(new MyOneTask(), 3000, 1000); // 3秒后开始运行，循环周期为 1秒        timer.schedule(new MyTwoTask(), 3000, 1000);    }}</code></pre><p>输出</p><pre><code>I&#39;m MyOneTask 1I&#39;m MyTwoTask 1000I&#39;m MyTwoTask 999I&#39;m MyOneTask 2I&#39;m MyOneTask 3I&#39;m MyTwoTask 998I&#39;m MyTwoTask 997I&#39;m MyOneTask 4I&#39;m MyOneTask 5I&#39;m MyTwoTask 996I&#39;m MyTwoTask 995I&#39;m MyOneTask 6...</code></pre><p><code>Timer</code> 的部分关键源码如下</p><pre><code class="java">public class Timer {    private final TaskQueue queue = new TaskQueue();    private final TimerThread thread = new TimerThread(queue);    public void schedule(TimerTask task, long delay) {        if (delay &lt; 0)            throw new IllegalArgumentException(&quot;Negative delay.&quot;);        sched(task, System.currentTimeMillis()+delay, 0);    }    public void schedule(TimerTask task, Date time) {        sched(task, time.getTime(), 0);    }    private void sched(TimerTask task, long time, long period) {        if (time &lt; 0)            throw new IllegalArgumentException(&quot;Illegal execution time.&quot;);        if (Math.abs(period) &gt; (Long.MAX_VALUE &gt;&gt; 1))            period &gt;&gt;= 1;        // 获取任务队列的锁(同一个线程多次获取这个锁并不会被阻塞,不同线程获取时才可能被阻塞)        synchronized(queue) {            // 如果定时调度线程已经终止了,则抛出异常结束            if (!thread.newTasksMayBeScheduled)                throw new IllegalStateException(&quot;Timer already cancelled.&quot;);            // 再获取定时任务对象的锁(为什么还要再加这个锁呢?想不清)            synchronized(task.lock) {                // 判断线程的状态,防止多线程同时调度到一个任务时多次被加入任务队列                if (task.state != TimerTask.VIRGIN)                    throw new IllegalStateException(                        &quot;Task already scheduled or cancelled&quot;);                // 初始化定时任务的下次执行时间                task.nextExecutionTime = time;                // 重复执行的间隔时间                task.period = period;                // 将定时任务的状态由TimerTask.VIRGIN(一个定时任务的初始化状态)设置为TimerTask.SCHEDULED                task.state = TimerTask.SCHEDULED;            }            // 将任务加入任务队列            queue.add(task);            // 如果当前加入的任务是需要第一个被执行的(也就是他的下一次执行时间离现在最近)            // 则唤醒等待queue的线程(对应到上面提到的queue.wait())            if (queue.getMin() == task)                queue.notify();        }    }    // cancel会等到所有定时任务执行完后立刻终止定时线程    public void cancel() {        synchronized(queue) {            thread.newTasksMayBeScheduled = false;            queue.clear();            queue.notify();  // In case queue was already empty.        }    }    // ...}</code></pre><p><code>Timer</code> 中在 <code>schedulexxx</code> 方法中通过 <code>TaskQueue</code> 协调各种 <code>TimerTask</code> 定时任务，<code>Timer</code> 是中介者，<code>TimerTask</code> 是抽象同事类，而我们自己写的任务则是具体同事类</p><p><code>TimerThread</code> 是 <code>Timer</code> 中定时调度线程类的定义，这个类会做为一个线程一直运行来执行 <code>Timer</code> 中任务队列中的任务。</p><p><code>Timer</code> 这个中介者的功能就是<strong>定时调度我们写的各种任务</strong>，将任务添加到 <code>TaskQueue</code> 任务队列中，给 <code>TimerThread</code> 执行，让任务与执行线程解耦</p><h3 id="其他的中介者模式应用"><a href="#其他的中介者模式应用" class="headerlink" title="其他的中介者模式应用"></a>其他的中介者模式应用</h3><ul><li><p><code>java.util.concurrent.Executor#execute</code> 和 <code>java.util.concurrent.ExecutorService#submit</code> 与 <code>Timer#schedule</code> 类似</p></li><li><p>MVC模式中，Controller 是中介者，根据 View 层的请求来操作 Model 层</p></li></ul><blockquote><p>参考：<br>刘伟：设计模式Java版<br>慕课网java设计模式精讲 Debug 方式+内存分析<br><a href="https://www.jianshu.com/p/58a5b0853451" target="_blank" rel="noopener">java.util系列源码解读之Timer定时器</a></p></blockquote><h2 id="后记"><a href="#后记" class="headerlink" title="后记"></a>后记</h2><p>欢迎评论、转发、分享，您的支持是我最大的动力</p><p>关注【小旋锋】微信公众号，及时接收博文推送</p><p><img src="http://image.laijianfeng.org/20180913_001328.png" alt="关注_小旋锋_微信公众号"></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;本文的主要内容：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;介绍中介者模式&lt;/li&gt;
&lt;li&gt;数据同步示例&lt;/li&gt;
&lt;li&gt;中介者模式总结&lt;/li&gt;
&lt;li&gt;源码分析中介者模式的典型应用&lt;ul&gt;
&lt;li&gt;Java Timer 中的中介者模式&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;

      
    
    </summary>
    
      <category term="后端" scheme="http://laijianfeng.org/categories/%E5%90%8E%E7%AB%AF/"/>
    
    
      <category term="设计模式" scheme="http://laijianfeng.org/tags/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/"/>
    
  </entry>
  
  <entry>
    <title>设计模式 | 备忘录模式及典型应用</title>
    <link href="http://laijianfeng.org/2018/10/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F-%E5%A4%87%E5%BF%98%E5%BD%95%E6%A8%A1%E5%BC%8F%E5%8F%8A%E5%85%B8%E5%9E%8B%E5%BA%94%E7%94%A8/"/>
    <id>http://laijianfeng.org/2018/10/设计模式-备忘录模式及典型应用/</id>
    <published>2018-10-24T16:42:24.000Z</published>
    <updated>2018-10-24T16:44:16.194Z</updated>
    
    <content type="html"><![CDATA[<p>本文的主要内容：</p><ul><li>介绍备忘录模式</li><li>示例</li><li>备忘录模式总结</li></ul><h2 id="备忘录模式"><a href="#备忘录模式" class="headerlink" title="备忘录模式"></a>备忘录模式</h2><p>备忘录模式经常可以遇到，譬如下面这些场景：</p><ul><li><p><strong>浏览器回退</strong>：浏览器一般有浏览记录，当我们在一个网页上点击几次链接之后，可在左上角点击左箭头回退到上一次的页面，然后也可以点击右箭头重新回到当前页面</p></li><li><p><strong>数据库备份与还原</strong>：一般的数据库都支持备份与还原操作，备份即将当前已有的数据或者记录保留，还原即将已经保留的数据恢复到对应的表中</p></li><li><p><strong>编辑器撤销与重做</strong>：在编辑器上编辑文字，写错时可以按快捷键 <code>Ctrl + z</code> 撤销，撤销后可以按 <code>Ctrl + y</code> 重做</p></li><li><p><strong>虚拟机生成快照与恢复</strong>：虚拟机可以生成一个快照，当虚拟机发生错误时可以恢复到快照的样子</p></li><li><p><strong>Git版本管理</strong>：Git是最常见的版本管理软件，每提交一个新版本，实际上Git就会把它们自动串成一条时间线，每个版本都有一个版本号，使用 <code>git reset --hard 版本号</code> 即可回到指定的版本，让代码时空穿梭回到过去某个历史时刻</p></li><li><p><strong>棋牌游戏悔棋</strong>：在棋牌游戏中，有时下快了可以悔棋，回退到上一步重新下</p></li></ul><p><img src="http://image.laijianfeng.org/20181024_233428.png" alt="浏览器回退"></p><p><img src="http://image.laijianfeng.org/20181024_235908.png" alt="编辑器撤销"></p><p><strong>备忘录模式(Memento Pattern)</strong>：在不破坏封装的前提下，捕获一个对象的内部状态，并在该对象之外保存这个状态，这样可以在以后将对象恢复到原先保存的状态。它是一种对象行为型模式，其别名为Token。</p><p><img src="http://image.laijianfeng.org/20181025_001332.png" alt="指针向左为撤销，向右为重做"></p><h3 id="角色"><a href="#角色" class="headerlink" title="角色"></a>角色</h3><p><strong>Originator（原发器）</strong>：它是一个普通类，可以创建一个备忘录，并存储它的当前内部状态，也可以使用备忘录来恢复其内部状态，一般将需要保存内部状态的类设计为原发器。</p><p><strong>Memento（备忘录)</strong>：存储原发器的内部状态，根据原发器来决定保存哪些内部状态。备忘录的设计一般可以参考原发器的设计，根据实际需要确定备忘录类中的属性。需要注意的是，除了原发器本身与负责人类之外，备忘录对象不能直接供其他类使用，原发器的设计在不同的编程语言中实现机制会有所不同。</p><p><strong>Caretaker（负责人）</strong>：负责人又称为管理者，它负责保存备忘录，但是不能对备忘录的内容进行操作或检查。在负责人类中可以存储一个或多个备忘录对象，它只负责存储对象，而不能修改对象，也无须知道对象的实现细节。</p><p>备忘录模式的核心是备忘录类以及用于管理备忘录的负责人类的设计。</p><h3 id="示例"><a href="#示例" class="headerlink" title="示例"></a>示例</h3><p>下棋例子，可以下棋，悔棋，撤销悔棋等</p><p>棋子类 <code>Chessman</code>，原发器角色</p><pre><code class="java">@Data@AllArgsConstructorclass Chessman {    private String label;    private int x;    private int y;    //保存状态    public ChessmanMemento save() {        return new ChessmanMemento(this.label, this.x, this.y);    }    //恢复状态    public void restore(ChessmanMemento memento) {        this.label = memento.getLabel();        this.x = memento.getX();        this.y = memento.getY();    }    public void show() {        System.out.println(String.format(&quot;棋子&lt;%s&gt;：当前位置为：&lt;%d, %d&gt;&quot;, this.getLabel(), this.getX(), this.getY()));    }}</code></pre><p>备忘录角色 <code>ChessmanMemento</code></p><pre><code class="java">@Data@AllArgsConstructorclass ChessmanMemento {    private String label;    private int x;    private int y;}</code></pre><p>负责人角色 <code>MementoCaretaker</code></p><pre><code class="java">class MementoCaretaker {    //定义一个集合来存储备忘录    private ArrayList mementolist = new ArrayList();    public ChessmanMemento getMemento(int i) {        return (ChessmanMemento) mementolist.get(i);    }    public void addMemento(ChessmanMemento memento) {        mementolist.add(memento);    }}</code></pre><p>棋子客户端，维护了一个 <code>MementoCaretaker</code> 对象</p><pre><code class="java">class Client {    private static int index = -1;    private static MementoCaretaker mc = new MementoCaretaker();    public static void main(String args[]) {        Chessman chess = new Chessman(&quot;车&quot;, 1, 1);        play(chess);        chess.setY(4);        play(chess);        chess.setX(5);        play(chess);        undo(chess, index);        undo(chess, index);        redo(chess, index);        redo(chess, index);    }    //下棋，同时保存备忘录    public static void play(Chessman chess) {        mc.addMemento(chess.save());        index++;        chess.show();    }    //悔棋，撤销到上一个备忘录    public static void undo(Chessman chess, int i) {        System.out.println(&quot;******悔棋******&quot;);        index--;        chess.restore(mc.getMemento(i - 1));        chess.show();    }    //撤销悔棋，恢复到下一个备忘录    public static void redo(Chessman chess, int i) {        System.out.println(&quot;******撤销悔棋******&quot;);        index++;        chess.restore(mc.getMemento(i + 1));        chess.show();    }}</code></pre><p>输出如下，悔棋成功，撤销悔棋成功</p><pre><code>棋子&lt;车&gt;：当前位置为：&lt;1, 1&gt;棋子&lt;车&gt;：当前位置为：&lt;1, 4&gt;棋子&lt;车&gt;：当前位置为：&lt;5, 4&gt;******悔棋******棋子&lt;车&gt;：当前位置为：&lt;1, 4&gt;******悔棋******棋子&lt;车&gt;：当前位置为：&lt;1, 1&gt;******撤销悔棋******棋子&lt;车&gt;：当前位置为：&lt;1, 4&gt;******撤销悔棋******棋子&lt;车&gt;：当前位置为：&lt;5, 4&gt;</code></pre><p>类图如下</p><p><img src="http://image.laijianfeng.org/20181024_113151.png" alt="示例.备忘录模式类图"></p><h2 id="备忘录模式总结"><a href="#备忘录模式总结" class="headerlink" title="备忘录模式总结"></a>备忘录模式总结</h2><p>备忘录模式的<strong>主要优点</strong>如下：</p><ul><li><p>它提供了一种状态恢复的实现机制，使得用户可以方便地回到一个特定的历史步骤，当新的状态无效或者存在问题时，可以使用暂时存储起来的备忘录将状态复原。</p></li><li><p>备忘录实现了对信息的封装，一个备忘录对象是一种原发器对象状态的表示，不会被其他代码所改动。备忘录保存了原发器的状态，采用列表、堆栈等集合来存储备忘录对象可以实现多次撤销操作。</p></li></ul><p>备忘录模式的<strong>主要缺点</strong>如下：</p><ul><li>资源消耗过大，如果需要保存的原发器类的成员变量太多，就不可避免需要占用大量的存储空间，每保存一次对象的状态都需要消耗一定的系统资源。</li></ul><p><strong>适用场景</strong>：</p><ul><li><p>保存一个对象在某一个时刻的全部状态或部分状态，这样以后需要时它能够恢复到先前的状态，实现撤销操作。</p></li><li><p>防止外界对象破坏一个对象历史状态的封装性，避免将对象历史状态的实现细节暴露给外界对象。</p></li></ul><blockquote><p>由于软件中JDK、Spring、Mybatis中很少有备忘录模式，也许 Spring webflow 中的 StateManageableMessageContext 接口算一个，但是真的很少见，所以这里不做典型应用源码分析</p></blockquote><p><img src="http://image.laijianfeng.org/20180913_001328.png" alt="关注_小旋锋_微信公众号"></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;本文的主要内容：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;介绍备忘录模式&lt;/li&gt;
&lt;li&gt;示例&lt;/li&gt;
&lt;li&gt;备忘录模式总结&lt;/li&gt;
&lt;/ul&gt;
&lt;h2 id=&quot;备忘录模式&quot;&gt;&lt;a href=&quot;#备忘录模式&quot; class=&quot;headerlink&quot; title=&quot;备忘录模式&quot;&gt;&lt;/
      
    
    </summary>
    
      <category term="后端" scheme="http://laijianfeng.org/categories/%E5%90%8E%E7%AB%AF/"/>
    
    
      <category term="设计模式" scheme="http://laijianfeng.org/tags/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/"/>
    
  </entry>
  
  <entry>
    <title>设计模式 | 观察者模式及典型应用</title>
    <link href="http://laijianfeng.org/2018/10/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F-%E8%A7%82%E5%AF%9F%E8%80%85%E6%A8%A1%E5%BC%8F%E5%8F%8A%E5%85%B8%E5%9E%8B%E5%BA%94%E7%94%A8/"/>
    <id>http://laijianfeng.org/2018/10/设计模式-观察者模式及典型应用/</id>
    <published>2018-10-23T16:30:56.000Z</published>
    <updated>2018-10-23T16:33:55.731Z</updated>
    
    <content type="html"><![CDATA[<p>本文主要内容：</p><ul><li>介绍观察者模式</li><li>微信公众号的发布/订阅示例</li><li>观察者模式总结</li><li>分析观察者模式的典型应用<ul><li>JDK 提供的观察者接口中的观察者模式</li><li>Guava EventBus 中的观察者模式</li><li>JDK 委托事件模型DEM中的观察者模式</li><li>Spring ApplicationContext 事件机制中的观察者模式</li></ul></li></ul><h2 id="观察者模式"><a href="#观察者模式" class="headerlink" title="观察者模式"></a>观察者模式</h2><p>观察者模式是设计模式中的 “超级模式”，其应用随处可见，我们以微信公众号为例。</p><p>微信公众号有服务号、订阅号和企业号之分。以我的公众号为例，我的公众号类型是订阅号，名称是 “小旋锋”，专注于大数据，Java后端类技术分享。目前主要是分享学习笔记为主，尽量做到 “原创”、”高质量”、”成体系”。每当我发布一篇博文推送，订阅的用户都能够在我发布推送之后及时接收到推送，即可方便地在手机端进行阅读。</p><p><img src="http://image.laijianfeng.org/20181023_193152.jpg" alt="微信公众号.发布/订阅"></p><p><strong>观察者模式(Observer Pattern)</strong>：定义对象之间的一种一对多依赖关系，使得每当一个对象状态发生改变时，其相关依赖对象皆得到通知并被自动更新。观察者模式是一种对象行为型模式。</p><p>观察者模式的别名包括发布-订阅（Publish/Subscribe）模式、模型-视图（Model/View）模式、源-监听器（Source/Listener）模式或从属者（Dependents）模式。</p><p>观察者模式包含观察目标和观察者两类对象，一个目标可以有任意数目的与之相依赖的观察者，一旦观察目标的状态发生改变，所有的观察者都将得到通知。</p><h3 id="角色"><a href="#角色" class="headerlink" title="角色"></a>角色</h3><p><strong>Subject（目标）</strong>：目标又称为主题，它是指被观察的对象。在目标中定义了一个观察者集合，一个观察目标可以接受任意数量的观察者来观察，它提供一系列方法来增加和删除观察者对象，同时它定义了通知方法notify()。目标类可以是接口，也可以是抽象类或具体类。</p><p><strong>ConcreteSubject（具体目标）</strong>：具体目标是目标类的子类，通常它包含有经常发生改变的数据，当它的状态发生改变时，向它的各个观察者发出通知；同时它还实现了在目标类中定义的抽象业务逻辑方法（如果有的话）。如果无须扩展目标类，则具体目标类可以省略。</p><p><strong>Observer（观察者）</strong>：观察者将对观察目标的改变做出反应，观察者一般定义为接口，该接口声明了更新数据的方法update()，因此又称为抽象观察者。</p><p><strong>ConcreteObserver（具体观察者）</strong>：在具体观察者中维护一个指向具体目标对象的引用，它存储具体观察者的有关状态，这些状态需要和具体目标的状态保持一致；它实现了在抽象观察者Observer中定义的update()方法。通常在实现时，可以调用具体目标类的attach()方法将自己添加到目标类的集合中或通过detach()方法将自己从目标类的集合中删除。</p><h2 id="示例"><a href="#示例" class="headerlink" title="示例"></a>示例</h2><p>首先需要一个订阅者接口（观察者），该接口有一个 <code>receive</code> 方法，用于接收公众号推送通知</p><pre><code class="java">public interface Subscriber {    int receive(String publisher, String articleName);}</code></pre><p>然后是一个微信客户端（具体观察者），实现了 <code>receive</code> 方法</p><pre><code class="java">public class WeChatClient implements Subscriber {    private String username;    public WeChatClient(String username) {        this.username = username;    }    @Override    public int receive(String publisher, String articleName) {        // 接收到推送时的操作        System.out.println(String.format(&quot;用户&lt;%s&gt; 接收到 &lt;%s&gt;微信公众号 的推送，文章标题为 &lt;%s&gt;&quot;, username, publisher, articleName));        return 0;    }}</code></pre><p>发布者类（目标，被观察对象），该类维护了一个订阅者列表，实现了订阅、取消订阅、通知所有订阅者等功能</p><pre><code class="java">public class Publisher {    private List&lt;Subscriber&gt; subscribers;    private boolean pubStatus = false;    public Publisher() {        subscribers = new ArrayList&lt;Subscriber&gt;();    }    protected void subscribe(Subscriber subscriber) {        this.subscribers.add(subscriber);    }    protected void unsubscribe(Subscriber subscriber) {        if (this.subscribers.contains(subscriber)) {            this.subscribers.remove(subscriber);        }    }    protected void notifySubscribers(String publisher, String articleName) {        if (this.pubStatus == false) {            return;        }        for (Subscriber subscriber : this.subscribers) {            subscriber.receive(publisher, articleName);        }        this.clearPubStatus();    }    protected void setPubStatus() {        this.pubStatus = true;    }    protected void clearPubStatus() {        this.pubStatus = false;    }}</code></pre><p>微信公众号类（具体目标），该类提供了 <code>publishArticles</code> 方法，用于发布推送，当文章发布完毕时调用父类的通知所有订阅者方法</p><pre><code class="java">public class WeChatAccounts extends Publisher {    private String name;    public WeChatAccounts(String name) {        this.name = name;    }    public void publishArticles(String articleName, String content) {        System.out.println(String.format(&quot;\n&lt;%s&gt;微信公众号 发布了一篇推送，文章名称为 &lt;%s&gt;，内容为 &lt;%s&gt; &quot;, this.name, articleName, content));        setPubStatus();        notifySubscribers(this.name, articleName);    }}</code></pre><p>测试</p><pre><code class="java">public class Test {    public static void main(String[] args) {        WeChatAccounts accounts = new WeChatAccounts(&quot;小旋锋&quot;);        WeChatClient user1 = new WeChatClient(&quot;张三&quot;);        WeChatClient user2 = new WeChatClient(&quot;李四&quot;);        WeChatClient user3 = new WeChatClient(&quot;王五&quot;);        accounts.subscribe(user1);        accounts.subscribe(user2);        accounts.subscribe(user3);        accounts.publishArticles(&quot;设计模式 | 观察者模式及典型应用&quot;, &quot;观察者模式的内容...&quot;);        accounts.unsubscribe(user1);        accounts.publishArticles(&quot;设计模式 | 单例模式及典型应用&quot;, &quot;单例模式的内容....&quot;);    }}</code></pre><p>结果如下，符合预期，当公众号发布一篇推送时，订阅该公众号的用户可及时接收到推送的通知</p><pre><code>&lt;小旋锋&gt;微信公众号 发布了一篇推送，文章名称为 &lt;设计模式 | 观察者模式及典型应用&gt;，内容为 &lt;观察者模式的内容...&gt; 用户&lt;张三&gt; 接收到 &lt;小旋锋&gt;微信公众号 的推送，文章标题为 &lt;设计模式 | 观察者模式及典型应用&gt;用户&lt;李四&gt; 接收到 &lt;小旋锋&gt;微信公众号 的推送，文章标题为 &lt;设计模式 | 观察者模式及典型应用&gt;用户&lt;王五&gt; 接收到 &lt;小旋锋&gt;微信公众号 的推送，文章标题为 &lt;设计模式 | 观察者模式及典型应用&gt;&lt;小旋锋&gt;微信公众号 发布了一篇推送，文章名称为 &lt;设计模式 | 单例模式及典型应用&gt;，内容为 &lt;单例模式的内容....&gt; 用户&lt;李四&gt; 接收到 &lt;小旋锋&gt;微信公众号 的推送，文章标题为 &lt;设计模式 | 单例模式及典型应用&gt;用户&lt;王五&gt; 接收到 &lt;小旋锋&gt;微信公众号 的推送，文章标题为 &lt;设计模式 | 单例模式及典型应用&gt;</code></pre><p>可画出类图如下</p><p><img src="http://image.laijianfeng.org/20181023_171948.png" alt="示例.观察者模式类图"></p><p>借此机会做个小推广，欢迎大家关注我的微信公众号哦 \^_\^</p><p><img src="http://image.laijianfeng.org/20180913_001328.png" alt="关注【小旋锋】微信公众号"></p><h2 id="观察者模式总结"><a href="#观察者模式总结" class="headerlink" title="观察者模式总结"></a>观察者模式总结</h2><p>观察者模式的<strong>主要优点</strong>如下：</p><ul><li><p>观察者模式可以实现表示层和数据逻辑层的分离，定义了稳定的消息更新传递机制，并抽象了更新接口，使得可以有各种各样不同的表示层充当具体观察者角色。</p></li><li><p>观察者模式在观察目标和观察者之间建立一个抽象的耦合。观察目标只需要维持一个抽象观察者的集合，无须了解其具体观察者。由于观察目标和观察者没有紧密地耦合在一起，因此它们可以属于不同的抽象化层次。</p></li><li><p>观察者模式支持广播通信，观察目标会向所有已注册的观察者对象发送通知，简化了一对多系统设计的难度。</p></li><li><p>观察者模式满足 “开闭原则” 的要求，增加新的具体观察者无须修改原有系统代码，在具体观察者与观察目标之间不存在关联关系的情况下，增加新的观察目标也很方便。</p></li></ul><p>观察者模式的<strong>主要缺点</strong>如下：</p><ul><li><p>如果一个观察目标对象有很多直接和间接观察者，将所有的观察者都通知到会花费很多时间。</p></li><li><p>如果在观察者和观察目标之间存在循环依赖，观察目标会触发它们之间进行循环调用，可能导致系统崩溃。</p></li><li><p>观察者模式没有相应的机制让观察者知道所观察的目标对象是怎么发生变化的，而仅仅只是知道观察目标发生了变化。</p></li></ul><p><strong>适用场景</strong>：</p><ul><li><p>一个抽象模型有两个方面，其中一个方面依赖于另一个方面，将这两个方面封装在独立的对象中使它们可以各自独立地改变和复用。</p></li><li><p>一个对象的改变将导致一个或多个其他对象也发生改变，而并不知道具体有多少对象将发生改变，也不知道这些对象是谁。</p></li><li><p>需要在系统中创建一个触发链，A对象的行为将影响B对象，B对象的行为将影响C对象……，可以使用观察者模式创建一种链式触发机制。</p></li></ul><h2 id="观察者模式的典型应用"><a href="#观察者模式的典型应用" class="headerlink" title="观察者模式的典型应用"></a>观察者模式的典型应用</h2><h3 id="JDK-提供的观察者接口"><a href="#JDK-提供的观察者接口" class="headerlink" title="JDK 提供的观察者接口"></a>JDK 提供的观察者接口</h3><p>观察者模式在Java语言中的地位非常重要。在JDK的 <code>java.util</code> 包中，提供了 <code>Observable</code> 类以及 <code>Observer</code> 接口，它们构成了JDK对观察者模式的支持。</p><p>其中的 <code>Observer</code> 接口为观察者，只有一个 <code>update</code> 方法，当观察目标发生变化时被调用，其代码如下：</p><pre><code class="java">public interface Observer {    void update(Observable o, Object arg);}</code></pre><p><code>Observable</code> 类则为目标类，相比我们的示例中的 <code>Publisher</code> 类多了并发和NPE方面的考虑</p><pre><code class="java">public class Observable {    private boolean changed = false;    private Vector&lt;Observer&gt; obs = new Vector();    public Observable() {    }    // 用于注册新的观察者对象到向量中    public synchronized void addObserver(Observer var1) {        if (var1 == null) {            throw new NullPointerException();        } else {            if (!this.obs.contains(var1)) {                this.obs.addElement(var1);            }        }    }    // 用于删除向量中的某一个观察者对象    public synchronized void deleteObserver(Observer var1) {        this.obs.removeElement(var1);    }    public void notifyObservers() {        this.notifyObservers((Object)null);    }    // 通知方法，用于在方法内部循环调用向量中每一个观察者的update()方法    public void notifyObservers(Object var1) {        Object[] var2;        synchronized(this) {            if (!this.changed) {                return;            }            var2 = this.obs.toArray();            this.clearChanged();        }        for(int var3 = var2.length - 1; var3 &gt;= 0; --var3) {            ((Observer)var2[var3]).update(this, var1);        }    }    // 用于清空向量，即删除向量中所有观察者对象    public synchronized void deleteObservers() {        this.obs.removeAllElements();    }    // 该方法被调用后会设置一个boolean类型的内部标记变量changed的值为true，表示观察目标对象的状态发生了变化    protected synchronized void setChanged() {        this.changed = true;    }    // 用于将changed变量的值设为false，表示对象状态不再发生改变或者已经通知了所有的观察者对象，调用了它们的update()方法    protected synchronized void clearChanged() {        this.changed = false;    }    // 返回对象状态是否改变    public synchronized boolean hasChanged() {        return this.changed;    }    // 返回向量中观察者的数量    public synchronized int countObservers() {        return this.obs.size();    }}</code></pre><p>我们可以使用 <code>Observable</code> 类以及 <code>Observer</code> 接口来重新实现微信公众号示例。</p><p>增加一个通知类 <code>WechatNotice</code>，用于推送通知的传递</p><pre><code class="java">@Data@AllArgsConstructorpublic class WechatNotice {    private String publisher;    private String articleName;}</code></pre><p>然后改写 <code>WeChatClient</code> 和 <code>WeChatAccounts</code>，分别实现JDK的 <code>Observer</code> 接口和继承 <code>Observable</code> 类</p><pre><code class="java">public class WeChatClient implements Observer {    private String username;    public WeChatClient(String username) {        this.username = username;    }    @Override    public void update(Observable o, Object arg) {        //WeChatAccounts weChatAccounts = (WeChatAccounts) o;        WechatNotice notice = (WechatNotice) arg;        System.out.println(String.format(&quot;用户&lt;%s&gt; 接收到 &lt;%s&gt;微信公众号 的推送，文章标题为 &lt;%s&gt;&quot;, username, notice.getPublisher(), notice.getArticleName()));    }}public class WeChatAccounts extends Observable {    private String name;    public WeChatAccounts(String name) {        this.name = name;    }    public void publishArticles(String articleName, String content) {        System.out.println(String.format(&quot;\n&lt;%s&gt;微信公众号 发布了一篇推送，文章名称为 &lt;%s&gt;，内容为 &lt;%s&gt; &quot;, this.name, articleName, content));        setChanged();        notifyObservers(new WechatNotice(this.name, articleName));    }}</code></pre><p>测试，与示例中的测试代码的区别在于调用的方法不同</p><pre><code class="java">public class Test {    public static void main(String[] args) {        WeChatAccounts accounts = new WeChatAccounts(&quot;小旋锋&quot;);        WeChatClient user1 = new WeChatClient(&quot;张三&quot;);        WeChatClient user2 = new WeChatClient(&quot;李四&quot;);        WeChatClient user3 = new WeChatClient(&quot;王五&quot;);        accounts.addObserver(user1);        accounts.addObserver(user2);        accounts.addObserver(user3);        accounts.publishArticles(&quot;设计模式 | 观察者模式及典型应用&quot;, &quot;观察者模式的内容...&quot;);        accounts.deleteObserver(user1);        accounts.publishArticles(&quot;设计模式 | 单例模式及典型应用&quot;, &quot;单例模式的内容....&quot;);    }}</code></pre><p>测试结果如下，可以发现结果如示例一致</p><pre><code class="java">&lt;小旋锋&gt;微信公众号 发布了一篇推送，文章名称为 &lt;设计模式 | 观察者模式及典型应用&gt;，内容为 &lt;观察者模式的内容...&gt; 用户&lt;王五&gt; 接收到 &lt;小旋锋&gt;微信公众号 的推送，文章标题为 &lt;设计模式 | 观察者模式及典型应用&gt;用户&lt;李四&gt; 接收到 &lt;小旋锋&gt;微信公众号 的推送，文章标题为 &lt;设计模式 | 观察者模式及典型应用&gt;用户&lt;张三&gt; 接收到 &lt;小旋锋&gt;微信公众号 的推送，文章标题为 &lt;设计模式 | 观察者模式及典型应用&gt;&lt;小旋锋&gt;微信公众号 发布了一篇推送，文章名称为 &lt;设计模式 | 单例模式及典型应用&gt;，内容为 &lt;单例模式的内容....&gt; 用户&lt;王五&gt; 接收到 &lt;小旋锋&gt;微信公众号 的推送，文章标题为 &lt;设计模式 | 单例模式及典型应用&gt;用户&lt;李四&gt; 接收到 &lt;小旋锋&gt;微信公众号 的推送，文章标题为 &lt;设计模式 | 单例模式及典型应用&gt;</code></pre><h3 id="Guava-EventBus-中的观察者模式"><a href="#Guava-EventBus-中的观察者模式" class="headerlink" title="Guava EventBus 中的观察者模式"></a>Guava EventBus 中的观察者模式</h3><p>Guava 中的 <code>EventBus</code> 封装了友好的 “生产/消费模型”，通过非常简单的方式，实现了观察者模式中的监听注册，事件分发。</p><p>使用了 Guava <code>EventBus</code> 之后，如果需要订阅消息，不需要实现任何接口，只需在监听方法上加上 <code>@Subscribe</code> 注解即可，<code>EventBus</code> 提供了 <code>register</code> 和 <code>unregister</code> 方法用于注册与取消注册事件，当 <code>EventBus</code> 调用 <code>post</code> 方法时将把事件分发给注册的对象</p><p>使用 Guava 重新实现示例</p><pre><code class="java">@Data@AllArgsConstructorpublic class WechatNotice {    private String publisher;    private String articleName;}public class WeChatClient  {    private String username;    public WeChatClient(String username) {        this.username = username;    }    @Subscribe    public void listen(WechatNotice notice) {        System.out.println(String.format(&quot;用户&lt;%s&gt; 接收到 &lt;%s&gt;微信公众号 的推送，文章标题为 &lt;%s&gt;&quot;, username, notice.getPublisher(), notice.getArticleName()));    }}public class WeChatAccounts {    private String name;    private EventBus eventBus;    public WeChatAccounts(String name) {        this.name = name;        this.eventBus = new EventBus();    }    public void publishArticles(String articleName, String content) {        System.out.println(String.format(&quot;\n&lt;%s&gt;微信公众号 发布了一篇推送，文章名称为 &lt;%s&gt;，内容为 &lt;%s&gt; &quot;, this.name, articleName, content));        this.eventBus.post(new WechatNotice(this.name, articleName));    }    public void register(WeChatClient weChatClient) {        this.eventBus.register(weChatClient);    }    public void unregister(WeChatClient weChatClient) {        this.eventBus.unregister(weChatClient);    }}</code></pre><p>测试 </p><pre><code class="java">public class Test {    public static void main(String[] args) {        WeChatAccounts accounts = new WeChatAccounts(&quot;小旋锋&quot;);        WeChatClient user1 = new WeChatClient(&quot;张三&quot;);        WeChatClient user2 = new WeChatClient(&quot;李四&quot;);        WeChatClient user3 = new WeChatClient(&quot;王五&quot;);        accounts.register(user1);        accounts.register(user2);        accounts.register(user3);        accounts.publishArticles(&quot;设计模式 | 观察者模式及典型应用&quot;, &quot;观察者模式的内容...&quot;);        accounts.unregister(user1);        accounts.publishArticles(&quot;设计模式 | 单例模式及典型应用&quot;, &quot;单例模式的内容....&quot;);    }}</code></pre><p>不出意料，输出的内容与上面两个示例一样</p><pre><code>&lt;小旋锋&gt;微信公众号 发布了一篇推送，文章名称为 &lt;设计模式 | 观察者模式及典型应用&gt;，内容为 &lt;观察者模式的内容...&gt; 用户&lt;张三&gt; 接收到 &lt;小旋锋&gt;微信公众号 的推送，文章标题为 &lt;设计模式 | 观察者模式及典型应用&gt;用户&lt;李四&gt; 接收到 &lt;小旋锋&gt;微信公众号 的推送，文章标题为 &lt;设计模式 | 观察者模式及典型应用&gt;用户&lt;王五&gt; 接收到 &lt;小旋锋&gt;微信公众号 的推送，文章标题为 &lt;设计模式 | 观察者模式及典型应用&gt;&lt;小旋锋&gt;微信公众号 发布了一篇推送，文章名称为 &lt;设计模式 | 单例模式及典型应用&gt;，内容为 &lt;单例模式的内容....&gt; 用户&lt;李四&gt; 接收到 &lt;小旋锋&gt;微信公众号 的推送，文章标题为 &lt;设计模式 | 单例模式及典型应用&gt;用户&lt;王五&gt; 接收到 &lt;小旋锋&gt;微信公众号 的推送，文章标题为 &lt;设计模式 | 单例模式及典型应用&gt;</code></pre><blockquote><p>Guava EventBus 的更多用法可自行查看相关文档<br>Guava EventBus 源码分析可看这篇 <a href="http://t.cn/EZzC35B" target="_blank" rel="noopener">http://t.cn/EZzC35B</a></p></blockquote><h3 id="JDK-委托事件模型DEM中的观察者模式"><a href="#JDK-委托事件模型DEM中的观察者模式" class="headerlink" title="JDK 委托事件模型DEM中的观察者模式"></a>JDK 委托事件模型DEM中的观察者模式</h3><p>首先来敲一个AWT按钮监听事件的Demo</p><pre><code class="java">import java.awt.*;import java.awt.event.MouseAdapter;import java.awt.event.MouseEvent;import java.awt.event.WindowAdapter;import java.awt.event.WindowEvent;public class MouseEvents {    private Frame frame;    private Button button;    MouseEvents() {        frame = new Frame(&quot;点击按钮触发点击事件，控制台将打印日志&quot;);        frame.setBounds(300, 200, 600, 300);        frame.setLayout(new FlowLayout());        button = new Button(&quot;this is a button&quot;);        button.setFont(new Font(&quot;Default&quot;, 0, 30));        frame.add(button);        dealwithEvent();        frame.setVisible(true);    }    //事件监听器以及处理事件    private void dealwithEvent() {        // 监听窗体关闭事件        frame.addWindowListener(new WindowAdapter() {            @Override            public void windowClosing(WindowEvent e) {                System.exit(0);            }        });        button.addActionListener(new ActionListener() {            private int eventCount = 1;            @Override            public void actionPerformed(ActionEvent e) {                System.out.println(String.format(&quot;动作事件发生 %d 次&quot;, eventCount++));            }        });    }    public static void main(String[] args) {        new MouseEvents();    }}</code></pre><p>运行 main 方法桌面将弹出下面的面板和按钮</p><p><img src="http://image.laijianfeng.org/20181023_193151.png" alt="按钮监听鼠标事件"></p><p>按钮的 <code>addActionListener</code> 添加指定的动作侦听器，以接收发自此按钮的动作事件，当用户在按钮上按下或释放鼠标时，JVM将产生一个相应的 <code>ActionEvent</code> 类型的事件对象，并在触发事件时将调用按钮的 <code>fireXXX()</code> 方法（继承自 Component），在该方法内部，将调用注册到按钮中的 <code>ActionListener</code> 对象的 <code>actionPerformed()</code> 方法（也就是我们实现的匿名事件处理类），实现对事件的处理</p><pre><code>动作事件发生 1 次动作事件发生 2 次动作事件发生 3 次动作事件发生 4 次</code></pre><h3 id="Spring-ApplicationContext-事件机制中的观察者模式"><a href="#Spring-ApplicationContext-事件机制中的观察者模式" class="headerlink" title="Spring ApplicationContext 事件机制中的观察者模式"></a>Spring ApplicationContext 事件机制中的观察者模式</h3><p>spring的事件机制是从java的事件机制拓展而来，<code>ApplicationContext</code> 中事件处理是由 <code>ApplicationEvent</code> 类和 <code>ApplicationListener</code> 接口来提供的。如果一个Bean实现了 <code>ApplicationListener</code> 接口，并且已经发布到容器中去，每次 <code>ApplicationContext</code> 发布一个 <code>ApplicationEvent</code> 事件，这个Bean就会接到通知</p><ul><li>ApplicationContext：事件源，其中的 publishEvent()方法用于触发容器事件</li><li>ApplicationEvent：事件本身，自定义事件需要继承该类，可以用来传递数据</li><li>ApplicationListener：事件监听器接口，事件的业务逻辑封装在监听器里面</li></ul><p>使用 spring 事件机制重新实现示例</p><pre><code class="java">@Datapublic class WechatNotice extends ApplicationEvent {    private String publisher;    private String articleName;    public WechatNotice(Object source, String publisher, String articleName) {        super(source);        this.publisher = publisher;        this.articleName = articleName;    }}public class WeChatClient implements ApplicationListener {    private String username;    public WeChatClient(String username) {        this.username = username;    }    @Override    public void onApplicationEvent(ApplicationEvent event) {        if (event instanceof WechatNotice) {            WechatNotice notice = (WechatNotice) event;            System.out.println(String.format(&quot;用户&lt;%s&gt; 接收到 &lt;%s&gt;微信公众号 的推送，文章标题为 &lt;%s&gt;&quot;, username, notice.getPublisher(), notice.getArticleName()));        }    }    public void setUsername(String username) {        this.username = username;    }}public class WeChatAccounts implements ApplicationContextAware {    private ApplicationContext ctx;    private String name;    public WeChatAccounts(String name) {        this.name = name;    }    public void setName(String name) {        this.name = name;    }    @Override    public void setApplicationContext(ApplicationContext applicationContext) throws BeansException {        this.ctx = applicationContext;    }    public void publishArticles(String articleName, String content) {        System.out.println(String.format(&quot;\n&lt;%s&gt;微信公众号 发布了一篇推送，文章名称为 &lt;%s&gt;，内容为 &lt;%s&gt; &quot;, this.name, articleName, content));        ctx.publishEvent(new WechatNotice(this.name, this.name, articleName));    }}</code></pre><p>在 resources 目录下创建 <code>spring.xml</code> 文件，填入下面的内容</p><pre><code class="xml">&lt;beans xmlns=&quot;http://www.springframework.org/schema/beans&quot;       xmlns:xsi=&quot;http://www.w3.org/2001/XMLSchema-instance&quot;       xsi:schemaLocation=&quot;http://www.springframework.org/schema/beans http://www.springframework.org/schema/beans/spring-beans.xsd&quot;&gt;    &lt;bean id=&quot;WeChatAccounts&quot; class=&quot;com.observer.sprintevent.WeChatAccounts&quot; scope=&quot;prototype&quot;&gt;        &lt;constructor-arg name=&quot;name&quot; value=&quot;&quot;&gt;&lt;/constructor-arg&gt;    &lt;/bean&gt;    &lt;bean id=&quot;WeChatClient1&quot; class=&quot;com.observer.sprintevent.WeChatClient&quot;&gt;        &lt;constructor-arg name=&quot;username&quot; value=&quot;张三&quot;&gt;&lt;/constructor-arg&gt;    &lt;/bean&gt;    &lt;bean id=&quot;WeChatClient2&quot; class=&quot;com.observer.sprintevent.WeChatClient&quot;&gt;        &lt;constructor-arg name=&quot;username&quot; value=&quot;李四&quot;&gt;&lt;/constructor-arg&gt;    &lt;/bean&gt;    &lt;bean id=&quot;WeChatClient3&quot; class=&quot;com.observer.sprintevent.WeChatClient&quot;&gt;        &lt;constructor-arg name=&quot;username&quot; value=&quot;王五&quot;&gt;&lt;/constructor-arg&gt;    &lt;/bean&gt;&lt;/beans&gt;</code></pre><p>测试</p><pre><code class="java">public class Test {    public static void main(String[] args) {        ApplicationContext context = new ClassPathXmlApplicationContext(&quot;spring.xml&quot;);        WeChatAccounts accounts = (WeChatAccounts) context.getBean(&quot;WeChatAccounts&quot;);        accounts.setName(&quot;小旋锋&quot;);        accounts.setApplicationContext(context);        accounts.publishArticles(&quot;设计模式 | 观察者模式及典型应用&quot;, &quot;观察者模式的内容...&quot;);    }}</code></pre><p>输出如下</p><pre><code>&lt;小旋锋&gt;微信公众号 发布了一篇推送，文章名称为 &lt;设计模式 | 观察者模式及典型应用&gt;，内容为 &lt;观察者模式的内容...&gt; 用户&lt;张三&gt; 接收到 &lt;小旋锋&gt;微信公众号 的推送，文章标题为 &lt;设计模式 | 观察者模式及典型应用&gt;用户&lt;李四&gt; 接收到 &lt;小旋锋&gt;微信公众号 的推送，文章标题为 &lt;设计模式 | 观察者模式及典型应用&gt;用户&lt;王五&gt; 接收到 &lt;小旋锋&gt;微信公众号 的推送，文章标题为 &lt;设计模式 | 观察者模式及典型应用&gt;</code></pre><p>在此示例中 <code>ApplicationContext</code> 对象的实际类型为 <code>ClassPathXmlApplicationContext</code>，其中的与 <code>publishEvent</code> 方法相关的主要代码如下：</p><pre><code class="java">private ApplicationEventMulticaster applicationEventMulticaster;public void publishEvent(ApplicationEvent event) {    this.getApplicationEventMulticaster().multicastEvent(event);    if (this.parent != null) {        this.parent.publishEvent(event);    }}ApplicationEventMulticaster getApplicationEventMulticaster() throws IllegalStateException {    return this.applicationEventMulticaster;}protected void initApplicationEventMulticaster() {        ConfigurableListableBeanFactory beanFactory = this.getBeanFactory();        if (beanFactory.containsLocalBean(&quot;applicationEventMulticaster&quot;)) {            this.applicationEventMulticaster = (ApplicationEventMulticaster)beanFactory.getBean(&quot;applicationEventMulticaster&quot;, ApplicationEventMulticaster.class);        } else {            this.applicationEventMulticaster = new SimpleApplicationEventMulticaster(beanFactory);            beanFactory.registerSingleton(&quot;applicationEventMulticaster&quot;, this.applicationEventMulticaster);        }    }</code></pre><p>其中的 <code>SimpleApplicationEventMulticaster</code> 如下，<code>multicastEvent</code> 方法主要是通过遍历 <code>ApplicationListener</code>（注册由 AbstractApplicationEventMulticaster 实现），使用线程池框架 <code>Executor</code> 来并发执行 <code>ApplicationListener</code> 的 <code>onApplicationEvent</code> 方法，与示例本质上是一致的</p><pre><code class="java">public class SimpleApplicationEventMulticaster extends AbstractApplicationEventMulticaster {    private Executor taskExecutor;    public void multicastEvent(final ApplicationEvent event) {        Iterator var2 = this.getApplicationListeners(event).iterator();        while(var2.hasNext()) {            final ApplicationListener listener = (ApplicationListener)var2.next();            Executor executor = this.getTaskExecutor();            if (executor != null) {                executor.execute(new Runnable() {                    public void run() {                        listener.onApplicationEvent(event);                    }                });            } else {                listener.onApplicationEvent(event);            }        }    }}</code></pre><blockquote><p>参考：<br>刘伟：设计模式Java版<br>慕课网java设计模式精讲 Debug 方式+内存分析<br><a href="http://uule.iteye.com/blog/2096279" target="_blank" rel="noopener">用guava实现简单的事件驱动</a><br><a href="http://www.cnblogs.com/youzhibing/p/9593788.html" target="_blank" rel="noopener">springboot 事件机制</a></p></blockquote><p><img src="http://image.laijianfeng.org/20180913_001328.png" alt="关注_小旋锋_微信公众号"></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;本文主要内容：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;介绍观察者模式&lt;/li&gt;
&lt;li&gt;微信公众号的发布/订阅示例&lt;/li&gt;
&lt;li&gt;观察者模式总结&lt;/li&gt;
&lt;li&gt;分析观察者模式的典型应用&lt;ul&gt;
&lt;li&gt;JDK 提供的观察者接口中的观察者模式&lt;/li&gt;
&lt;li&gt;Guava Eve
      
    
    </summary>
    
      <category term="后端" scheme="http://laijianfeng.org/categories/%E5%90%8E%E7%AB%AF/"/>
    
    
      <category term="设计模式" scheme="http://laijianfeng.org/tags/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/"/>
    
  </entry>
  
  <entry>
    <title>设计模式 | 策略模式及典型应用</title>
    <link href="http://laijianfeng.org/2018/10/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F-%E7%AD%96%E7%95%A5%E6%A8%A1%E5%BC%8F%E5%8F%8A%E5%85%B8%E5%9E%8B%E5%BA%94%E7%94%A8/"/>
    <id>http://laijianfeng.org/2018/10/设计模式-策略模式及典型应用/</id>
    <published>2018-10-18T12:33:43.000Z</published>
    <updated>2018-10-18T12:35:23.159Z</updated>
    
    <content type="html"><![CDATA[<p>本文的主要内容：</p><ul><li>介绍策略模式</li><li>示例<ul><li>商场购物打折策略的实现</li></ul></li><li>策略模式总结</li><li>源码分析策略模式的典型应用<ul><li>Java Comparator 中的策略模式</li><li>Spring Resource 中的策略模式</li><li>Spring Bean 实例化中的策略模式</li></ul></li></ul><h2 id="策略模式"><a href="#策略模式" class="headerlink" title="策略模式"></a>策略模式</h2><p>在软件开发中，我们也常常会遇到类似的情况，实现某一个功能有多条途径，每一条途径对应一种算法，此时我们可以使用一种设计模式来实现灵活地选择解决途径，也能够方便地增加新的解决途径。</p><p>譬如商场购物场景中，有些商品按原价卖，商场可能为了促销而推出优惠活动，有些商品打九折，有些打八折，有些则是返现10元等。</p><p>而优惠活动并不影响结算之外的其他过程，只是在结算的时候需要根据优惠方案结算</p><p><img src="http://image.laijianfeng.org/20181018_171948.jpg" alt="商场促销场景"></p><h3 id="角色"><a href="#角色" class="headerlink" title="角色"></a>角色</h3><p><strong>Context（环境类）</strong>：环境类是使用算法的角色，它在解决某个问题（即实现某个方法）时可以采用多种策略。在环境类中维持一个对抽象策略类的引用实例，用于定义所采用的策略。</p><p><strong>Strategy（抽象策略类）</strong>：它为所支持的算法声明了抽象方法，是所有策略类的父类，它可以是抽象类或具体类，也可以是接口。环境类通过抽象策略类中声明的方法在运行时调用具体策略类中实现的算法。</p><p><strong>ConcreteStrategy（具体策略类）</strong>：它实现了在抽象策略类中声明的算法，在运行时，具体策略类将覆盖在环境类中定义的抽象策略类对象，使用一种具体的算法实现某个业务处理。</p><h2 id="示例"><a href="#示例" class="headerlink" title="示例"></a>示例</h2><p>如果要写出一个商场优惠场景的Demo可以很快的写出来，譬如</p><pre><code class="java">import java.text.MessageFormat;public class Shopping {    private String goods;    private double price;    private double finalPrice;    private String desc;    public Shopping(String goods, double price) {        this.goods = goods;        this.price = price;    }    public double calculate(String discountType) {        if (&quot;dis9&quot;.equals(discountType)) {            finalPrice = price * 0.9;            desc = &quot;打九折&quot;;        } else if (&quot;dis8&quot;.equals(discountType)) {            finalPrice = price * 0.8;            desc = &quot;打八折&quot;;        } else if (&quot;cash10&quot;.equals(discountType)) {            finalPrice = price &gt;= 10 ? price - 10 : 0;            desc = &quot;返现10元&quot;;        } else {            finalPrice = price;            desc = &quot;不参与优惠活动&quot;;        }        System.out.println(MessageFormat.format(&quot;购买的物品：{0}，原始价格：{1}，{2}，最终价格为：{3}&quot;, goods, price, desc, finalPrice));        return finalPrice;    }}</code></pre><p>测试</p><pre><code class="java">public class Test {    public static void main(String[] args) {        Shopping shopping1 = new Shopping(&quot;书籍-深入理解Java虚拟机&quot;, 54.00);        shopping1.calculate(&quot;dis9&quot;); // 九折        Shopping shopping2 = new Shopping(&quot;Apple 妙控鼠标&quot;, 588.00 );        shopping2.calculate(&quot;dis8&quot;);        Shopping shopping3 = new Shopping(&quot;戴尔U2417H显示器&quot;, 1479.00);        shopping3.calculate(&quot;cash10&quot;);        Shopping shopping4 = new Shopping(&quot;索尼ILCE-6000L相机&quot;, 3599.00);        shopping4.calculate(null);    }}</code></pre><p>以上代码当然完成了我们的需求，但是存在以下问题：</p><ul><li><p>Shopping 类的 calculate() 方法非常庞大，它包含各种优惠算法的实现代码，在代码中出现了较长的 <code>if…else…</code> 语句，不利于测试和维护。</p></li><li><p>增加新的优惠算法或者对原有打折算法进行修改时必须修改 Shopping 类的源代码，违反了 “开闭原则”，系统的灵活性和可扩展性较差。</p></li><li><p>算法的复用性差，如果在另一个系统中需要重用某些优惠算法，只能通过对源代码进行复制粘贴来重用，无法单独重用其中的某个或某些算法。</p></li></ul><p>所以我们需要使用策略模式对 Shopping 类进行重构，将原本庞大的 Shopping 类的职责进行分解，将算法的定义和使用分离。</p><p>抽象策略类  <code>Discount</code>，它是所有具体优惠算法的父类，定义了一个 <code>discount</code> 抽象方法</p><pre><code class="java">import lombok.Data;@Datapublic abstract class Discount {    protected double finalPrice;    protected String desc;    public Discount(String desc) {        this.desc = desc;    }    abstract double discount(double price);}</code></pre><p>四种具体策略类，继承自抽象策略类 <code>Discount</code>，并在 <code>discount</code> 方法中实现具体的优惠算法</p><pre><code class="java">public class Dis9Discount extends Discount {    public Dis9Discount() {        super(&quot;打九折&quot;);    }    @Override    double discount(double price) {        finalPrice = price * 0.9;        return finalPrice;    }}public class Dis8Discount extends Discount{    public Dis8Discount() {        super(&quot;打八折&quot;);    }    @Override    double discount(double price) {        finalPrice = price * 0.8;        return finalPrice;    }}public class Cash10Discount extends Discount {    public Cash10Discount() {        super(&quot;返现10元&quot;);    }    @Override    public double discount(double price) {        this.finalPrice = price &gt;= 10 ? price - 10 : 0;        return finalPrice;    }}public class NoneDiscount extends Discount {    public NoneDiscount() {        super(&quot;不参与优惠活动&quot;);    }    @Override    double discount(double price) {        finalPrice = price;        return finalPrice;    }}</code></pre><p>环境类 <code>Shopping</code>，维护了一个 <code>Discount</code> 引用</p><pre><code class="java">public class Shopping {    private String goods;    private double price;    private Discount discount;    public Shopping(String goods, double price, Discount discount) {        this.goods = goods;        this.price = price;        this.discount = discount;    }    public double calculate() {        double finalPrice = discount.discount(this.price);        String desc = discount.getDesc();        System.out.println(MessageFormat.format(&quot;购买的物品：{0}，原始价格：{1}，{2}，最终价格为：{3}&quot;, goods, price, desc, finalPrice));        return finalPrice;    }}</code></pre><p>测试</p><pre><code class="java">public class Test {    public static void main(String[] args) {        Shopping shopping1 = new Shopping(&quot;书籍-深入理解Java虚拟机&quot;, 54.00, new Dis9Discount());        shopping1.calculate();        Shopping shopping2 = new Shopping(&quot;Apple 妙控鼠标&quot;, 588.00, new Dis8Discount());        shopping2.calculate();        Shopping shopping3 = new Shopping(&quot;戴尔U2417H显示器&quot;, 1479.00, new Cash10Discount());        shopping3.calculate();        Shopping shopping4 = new Shopping(&quot;索尼ILCE-6000L相机&quot;, 3599.00, new NoneDiscount());        shopping4.calculate();    }}</code></pre><p>结果</p><pre><code class="java">购买的物品：书籍-深入理解Java虚拟机，原始价格：54，打九折，最终价格为：48.6购买的物品：Apple 妙控鼠标，原始价格：588，打八折，最终价格为：470.4购买的物品：戴尔U2417H显示器，原始价格：1,479，返现10元，最终价格为：1,469购买的物品：索尼ILCE-6000L相机，原始价格：3,599，不参与优惠活动，最终价格为：3,599</code></pre><p>可以看到，使用策略模式重构后，<code>Shopping</code> 类的 <code>calculate</code> 方法简洁了很多，当需要更改优惠算法的时候不需要再修改 <code>Shopping</code> 类的源代码；要扩展出新的优惠算法很方便，只需要继承抽象策略类 <code>Discount</code> 并实现 <code>calculate</code> 方法即可；优惠算法很容易重用。</p><p>画出类图如下</p><p><img src="http://image.laijianfeng.org/20181017_114704.png" alt="示例.策略模式类图"></p><h2 id="策略模式总结"><a href="#策略模式总结" class="headerlink" title="策略模式总结"></a>策略模式总结</h2><p>策略模式的<strong>主要优点</strong>如下： </p><ul><li><p>策略模式提供了对 “开闭原则” 的完美支持，用户可以在不修改原有系统的基础上选择算法或行为，也可以灵活地增加新的算法或行为。</p></li><li><p>策略模式提供了管理相关的算法族的办法。策略类的等级结构定义了一个算法或行为族，恰当使用继承可以把公共的代码移到抽象策略类中，从而避免重复的代码。</p></li><li><p>策略模式提供了一种可以替换继承关系的办法。如果不使用策略模式而是通过继承，这样算法的使用就<br>和算法本身混在一起，不符合 “单一职责原则”，而且使用继承无法实现算法或行为在程序运行时的动态切<br>换。</p></li><li><p>使用策略模式可以避免多重条件选择语句。多重条件选择语句是硬编码，不易维护。</p></li><li><p>策略模式提供了一种算法的复用机制，由于将算法单独提取出来封装在策略类中，因此不同的环境类可以方便地复用这些策略类。</p></li></ul><p>策略模式的<strong>主要缺点</strong>如下：</p><ul><li><p>客户端必须知道所有的策略类，并自行决定使用哪一个策略类。这就意味着客户端必须理解这些算法的区别，以便适时选择恰当的算法。换言之，策略模式只适用于客户端知道所有的算法或行为的情况。</p></li><li><p>策略模式将造成系统产生很多具体策略类，任何细小的变化都将导致系统要增加一个新的具体策略类。</p></li><li><p>无法同时在客户端使用多个策略类，也就是说，在使用策略模式时，客户端每次只能使用一个策略类，不支持使用一个策略类完成部分功能后再使用另一个策略类来完成剩余功能的情况。</p></li></ul><p><strong>适用场景</strong></p><ul><li><p>一个系统需要动态地在几种算法中选择一种，那么可以将这些算法封装到一个个的具体算法类中，而这些具体算法类都是一个抽象算法类的子类。换言之，这些具体算法类均有统一的接口，根据 “里氏代换原则” 和面向对象的多态性，客户端可以选择使用任何一个具体算法类，并只需要维持一个数据类型是抽象算法类的对象。</p></li><li><p>一个对象有很多的行为，如果不用恰当的模式，这些行为就只好使用多重条件选择语句来实现。此时，使用策略模式，把这些行为转移到相应的具体策略类里面，就可以避免使用难以维护的多重条件选择语句。</p></li><li><p>不希望客户端知道复杂的、与算法相关的数据结构，在具体策略类中封装算法与相关的数据结构，可以提高算法的保密性与安全性。</p></li></ul><h2 id="源码分析策略模式的典型应用"><a href="#源码分析策略模式的典型应用" class="headerlink" title="源码分析策略模式的典型应用"></a>源码分析策略模式的典型应用</h2><h3 id="Java-Comparator-中的策略模式"><a href="#Java-Comparator-中的策略模式" class="headerlink" title="Java Comparator 中的策略模式"></a>Java Comparator 中的策略模式</h3><p><code>java.util.Comparator</code> 接口是比较器接口，可以通过 <code>Collections.sort(List,Comparator)</code> 和 <code>Arrays.sort(Object[],Comparator)</code> 对集合和数据进行排序，下面为示例程序</p><p>一个学生类，有两个属性 <code>id</code> 和 <code>name</code></p><pre><code class="java">@Data@AllArgsConstructorpublic class Student {    private Integer id;    private String name;    @Override    public String toString() {        return &quot;{id=&quot; + id + &quot;, name=&#39;&quot; + name + &quot;&#39;}&quot;;    }}</code></pre><p>实现两个比较器，比较器实现了 <code>Comparator</code> 接口，一个升序，一个降序</p><pre><code class="java">// 降序public class DescSortor implements Comparator&lt;Student&gt; {    @Override    public int compare(Student o1, Student o2) {        return o2.getId() - o1.getId();    }}// 升序public class AscSortor implements Comparator&lt;Student&gt; {    @Override    public int compare(Student o1, Student o2) {        return o1.getId() - o2.getId();    }}</code></pre><p>通过 <code>Arrays.sort()</code> 对数组进行排序</p><pre><code class="java">public class Test1 {    public static void main(String[] args) {        Student[] students = {                new Student(3, &quot;张三&quot;),                new Student(1, &quot;李四&quot;),                new Student(4, &quot;王五&quot;),                new Student(2, &quot;赵六&quot;)        };        toString(students, &quot;排序前&quot;);        Arrays.sort(students, new AscSortor());        toString(students, &quot;升序后&quot;);        Arrays.sort(students, new DescSortor());        toString(students, &quot;降序后&quot;);    }    public static void toString(Student[] students, String desc){        for (int i = 0; i &lt; students.length; i++) {            System.out.print(desc + &quot;: &quot; +students[i].toString() + &quot;, &quot;);        }        System.out.println();    }}</code></pre><p>输出</p><pre><code>排序前: {id=3, name=&#39;张三&#39;}, 排序前: {id=1, name=&#39;李四&#39;}, 排序前: {id=4, name=&#39;王五&#39;}, 排序前: {id=2, name=&#39;赵六&#39;}, 升序后: {id=1, name=&#39;李四&#39;}, 升序后: {id=2, name=&#39;赵六&#39;}, 升序后: {id=3, name=&#39;张三&#39;}, 升序后: {id=4, name=&#39;王五&#39;}, 降序后: {id=4, name=&#39;王五&#39;}, 降序后: {id=3, name=&#39;张三&#39;}, 降序后: {id=2, name=&#39;赵六&#39;}, 降序后: {id=1, name=&#39;李四&#39;}, </code></pre><p>通过 <code>Collections.sort()</code> 对集合List进行排序</p><pre><code class="java">public class Test2 {    public static void main(String[] args) {        List&lt;Student&gt; students = Arrays.asList(                new Student(3, &quot;张三&quot;),                new Student(1, &quot;李四&quot;),                new Student(4, &quot;王五&quot;),                new Student(2, &quot;赵六&quot;)        );        toString(students, &quot;排序前&quot;);        Collections.sort(students, new AscSortor());        toString(students, &quot;升序后&quot;);        Collections.sort(students, new DescSortor());        toString(students, &quot;降序后&quot;);    }    public static void toString(List&lt;Student&gt; students, String desc) {        for (Student student : students) {            System.out.print(desc + &quot;: &quot; + student.toString() + &quot;, &quot;);        }        System.out.println();    }}</code></pre><p>输出</p><pre><code>排序前: {id=3, name=&#39;张三&#39;}, 排序前: {id=1, name=&#39;李四&#39;}, 排序前: {id=4, name=&#39;王五&#39;}, 排序前: {id=2, name=&#39;赵六&#39;}, 升序后: {id=1, name=&#39;李四&#39;}, 升序后: {id=2, name=&#39;赵六&#39;}, 升序后: {id=3, name=&#39;张三&#39;}, 升序后: {id=4, name=&#39;王五&#39;}, 降序后: {id=4, name=&#39;王五&#39;}, 降序后: {id=3, name=&#39;张三&#39;}, 降序后: {id=2, name=&#39;赵六&#39;}, 降序后: {id=1, name=&#39;李四&#39;}, </code></pre><p>我们向 <code>Collections.sort()</code> 和 <code>Arrays.sort()</code> 分别传入不同的比较器即可实现不同的排序效果（升序或降序）</p><p>这里 <code>Comparator</code> 接口充当了抽象策略角色，两个比较器 <code>DescSortor</code> 和 <code>AscSortor</code> 则充当了具体策略角色，<code>Collections</code> 和 <code>Arrays</code> 则是环境角色</p><h3 id="Spring-Resource-中的策略模式"><a href="#Spring-Resource-中的策略模式" class="headerlink" title="Spring Resource 中的策略模式"></a>Spring Resource 中的策略模式</h3><p>Spring 把所有能记录信息的载体，如各种类型的文件、二进制流等都称为资源，譬如最常用的Spring配置文件。</p><p>在 Sun 所提供的标准 API 里，资源访问通常由 <code>java.NET.URL</code> 和文件 IO 来完成，尤其是当我们需要访问来自网络的资源时，通常会选择 URL 类。</p><p>URL 类可以处理一些常规的资源访问问题，但依然不能很好地满足所有底层资源访问的需要，比如，暂时还无法从类加载路径、或相对于 <code>ServletContext</code> 的路径来访问资源，虽然 Java 允许使用特定的 URL 前缀注册新的处理类（例如已有的 http: 前缀的处理类），但是这样做通常比较复杂，而且 URL 接口还缺少一些有用的功能，比如检查所指向的资源是否存在等。</p><p>Spring 改进了 Java 资源访问的策略，Spring 为资源访问提供了一个 Resource 接口，该接口提供了更强的资源访问能力，Spring 框架本身大量使用了 Resource 接口来访问底层资源。</p><pre><code class="java">public interface Resource extends InputStreamSource {    boolean exists();    // 返回 Resource 所指向的资源是否存在    boolean isReadable();   // 资源内容是否可读    boolean isOpen();   // 返回资源文件是否打开    URL getURL() throws IOException;    URI getURI() throws IOException;    File getFile() throws IOException;  // 返回资源对应的 File 对象    long contentLength() throws IOException;    long lastModified() throws IOException;    Resource createRelative(String var1) throws IOException;    String getFilename();    String getDescription();    // 返回资源的描述信息}</code></pre><p><code>Resource</code> 接口是 Spring 资源访问策略的抽象，它本身并不提供任何资源访问实现，具体的资源访问由该接口的实现类完成——<strong>每个实现类代表一种资源访问策略</strong>。</p><p><img src="http://image.laijianfeng.org/20181018_171944.png" alt="Spring资源访问接口Resource的实现类"></p><p>Spring 为 Resource 接口提供的部分实现类如下：</p><ul><li><code>UrlResource</code>：访问网络资源的实现类。</li><li><code>ClassPathResource</code>：访问类加载路径里资源的实现类。</li><li><code>FileSystemResource</code>：访问文件系统里资源的实现类。</li><li><code>ServletContextResource</code>：访问相对于 <code>ServletContext</code> 路径里的资源的实现类：</li><li><code>InputStreamResource</code>：访问输入流资源的实现类。</li><li><code>ByteArrayResource</code>：访问字节数组资源的实现类。</li><li><code>WritableResource</code>：写资源文件</li></ul><p>这些 <code>Resource</code> 实现类，针对不同的的底层资源，提供了相应的资源访问逻辑，并提供便捷的包装，以利于客户端程序的资源访问。</p><p>它们之间的类关系如下所示：</p><p><img src="http://image.laijianfeng.org/20181018_171945.png" alt="Spring Resource 类图"></p><p>可以看到 <code>AbstractResource</code> 资源抽象类实现了 <code>Resource</code> 接口，为子类通用的操作提供了具体实现，非通用的操作留给子类实现，所以这里也应用了模板方法模式。（只不过缺少了模板方法）</p><p><code>Resource</code> 不仅可在 Spring 的项目中使用，也可直接作为资源访问的工具类使用。意思是说：即使不使用 Spring 框架，也可以使用 <code>Resource</code> 作为工具类，用来代替 <code>URL</code>。</p><p>譬如我们可以使用 <code>UrlResource</code> 访问网络资源。</p><blockquote><p>也可以通过其它协议访问资源，file: 用于访问文件系统；http: 用于通过 HTTP 协议访问资源；ftp: 用于通过 FTP 协议访问资源等</p></blockquote><pre><code class="java">public class Test {    public static void main(String[] args) throws IOException {        UrlResource ur = new UrlResource(&quot;http://image.laijianfeng.org/hello.txt&quot;);        System.out.println(&quot;文件名：&quot; + ur.getFilename());        System.out.println(&quot;网络文件URL：&quot; + ur.getURL());        System.out.println(&quot;是否存在：&quot; + ur.exists());        System.out.println(&quot;是否可读：&quot; + ur.isReadable());        System.out.println(&quot;文件长度：&quot; + ur.contentLength());        System.out.println(&quot;\n--------文件内容----------\n&quot;);        byte[] bytes = new byte[47];        ur.getInputStream().read(bytes);        System.out.println(new String(bytes));    }}</code></pre><p>输出的内容如下，符合预期</p><pre><code>文件名：hello.txt网络文件URL：http://image.laijianfeng.org/hello.txt是否存在：true是否可读：true文件长度：47--------文件内容----------hello world!welcome to http://laijianfeng.org</code></pre><blockquote><p>更多的示例可以参考：<a href="https://www.ibm.com/developerworks/cn/java/j-lo-spring-resource/index.html" target="_blank" rel="noopener">Spring 资源访问剖析和策略模式应用</a></p></blockquote><h3 id="Spring-Bean-实例化中的策略模式"><a href="#Spring-Bean-实例化中的策略模式" class="headerlink" title="Spring Bean 实例化中的策略模式"></a>Spring Bean 实例化中的策略模式</h3><p>Spring实例化Bean有三种方式：构造器实例化、静态工厂实例化、实例工厂实例化</p><p>譬如通过构造器实例化bean的XML示例如下：</p><pre><code class="xml">&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt;&lt;beans xmlns=&quot;http://www.springframework.org/schema/beans&quot;    xmlns:xsi=&quot;http://www.w3.org/2001/XMLSchema-instance&quot;    xsi:schemaLocation=&quot;http://www.springframework.org/schema/beans http://www.springframework.org/schema/beans/spring-beans.xsd&quot;&gt;    &lt;bean id=&quot;person&quot; class=&quot;com.demo.Person&quot;&gt;&lt;/bean&gt;    &lt;bean id=&quot;personWithParam&quot; class=&quot;com.demo.Person&quot;&gt;        &lt;constructor-arg name=&quot;name&quot; value=&quot;小旋锋&quot;/&gt;    &lt;/bean&gt;    &lt;bean id=&quot;personWirhParams&quot; class=&quot;com.demo.Person&quot;&gt;            &lt;constructor-arg name=&quot;name&quot; value=&quot;小旋锋&quot;/&gt;            &lt;constructor-arg name=&quot;age&quot; value=&quot;22&quot;/&gt;    &lt;/bean&gt;&lt;/beans&gt;</code></pre><p>具体实例化Bean的过程中，Spring中角色分工很明确，创建对象的时候先通过 <code>ConstructorResolver</code> 找到对应的实例化方法和参数，再通过实例化策略 <code>InstantiationStrategy</code> 进行实例化，根据创建对象的三个分支( 工厂方法、有参构造方法、无参构造方法 ), <code>InstantiationStrategy</code> 提供了三个接口方法：</p><pre><code class="java">public interface InstantiationStrategy {    // 默认构造方法    Object instantiate(RootBeanDefinition beanDefinition, String beanName, BeanFactory owner) throws BeansException;    // 指定构造方法    Object instantiate(RootBeanDefinition beanDefinition, String beanName, BeanFactory owner, Constructor&lt;?&gt; ctor,            Object[] args) throws BeansException;    // 指定工厂方法    Object instantiate(RootBeanDefinition beanDefinition, String beanName, BeanFactory owner, Object factoryBean,            Method factoryMethod, Object[] args) throws BeansException;}</code></pre><p><code>InstantiationStrategy</code> 为实例化策略接口，扮演抽象策略角色，有两种具体策略类，分别为 <code>SimpleInstantiationStrategy</code> 和 <code>CglibSubclassingInstantiationStrategy</code> </p><p><img src="http://image.laijianfeng.org/20181018_171946.png" alt="Spring 实例化策略类图"></p><p>在 <code>SimpleInstantiationStrategy</code> 中对这三个方法做了简单实现，如果工厂方法实例化直接用反射创建对象，如果是构造方法实例化的则判断是否有 <code>MethodOverrides</code>，如果有无 <code>MethodOverrides</code> 也是直接用反射，如果有 <code>MethodOverrides</code> 就需要用 <code>cglib</code> 实例化对象，<code>SimpleInstantiationStrategy</code> 把通过 <code>cglib</code> 实例化的任务交给了它的子类 <code>CglibSubclassingInstantiationStrategy</code>。</p><blockquote><p>参考：<br>刘伟：设计模式Java版<br>慕课网java设计模式精讲 Debug 方式+内存分析<br><a href="https://www.ibm.com/developerworks/cn/java/j-lo-spring-resource/index.html" target="_blank" rel="noopener">Spring 资源访问剖析和策略模式应用</a><br><a href="https://my.oschina.net/chengxiaoyuan/blog/823655" target="_blank" rel="noopener">Spring源码阅读-实例化策略InstantiationStrategy</a><br><a href="https://blog.csdn.net/u011726984/article/details/45290871" target="_blank" rel="noopener">Spring学习之实例化bean的三种方式</a>   </p></blockquote><h3 id="推荐阅读"><a href="#推荐阅读" class="headerlink" title="推荐阅读"></a>推荐阅读</h3><p><a href="https://mp.weixin.qq.com/s?__biz=MzI1NDU0MTE1NA==&amp;mid=2247483700&amp;idx=1&amp;sn=dd4d23f9400c8be248f5d125465ba941&amp;chksm=e9c2ed39deb5642fb809eca1351f00995f06c9a4875f09986cc5005059eff74d6c20fc1118a3&amp;scene=0#rd" target="_blank" rel="noopener">设计模式 | 简单工厂模式及典型应用</a><br><a href="https://mp.weixin.qq.com/s?__biz=MzI1NDU0MTE1NA==&amp;mid=2247483704&amp;idx=1&amp;sn=fa3ae947cebf22da35e6ac0a37f566f8&amp;chksm=e9c2ed35deb564230a69e43d93a3b74618287c6ddd402a6f1dc6a5b14a896e99584985e7cf92&amp;scene=0#rd" target="_blank" rel="noopener">设计模式 | 工厂方法模式及典型应用</a><br><a href="https://mp.weixin.qq.com/s?__biz=MzI1NDU0MTE1NA==&amp;mid=2247483708&amp;idx=1&amp;sn=9b8c155b86511ea6ec323dc6a72c52df&amp;chksm=e9c2ed31deb56427b2a6bbcbad5bdd3a4ef68b52eb88cc47b5bcfc76773d3d983d8aaf57761c&amp;scene=0#rd" target="_blank" rel="noopener">设计模式 | 抽象工厂模式及典型应用</a><br><a href="https://mp.weixin.qq.com/s?__biz=MzI1NDU0MTE1NA==&amp;mid=2247483712&amp;idx=1&amp;sn=1ffd9837eb9413dde74ff509bf69ecc5&amp;chksm=e9c2ed4ddeb5645b8cbf64c83d103a859ae49921c60e17fe8bebe63c26b04966be101d598848&amp;scene=0#rd" target="_blank" rel="noopener">设计模式 | 建造者模式及典型应用</a><br><a href="https://mp.weixin.qq.com/s?__biz=MzI1NDU0MTE1NA==&amp;mid=2247483716&amp;idx=1&amp;sn=df00c297c8f32e10e277db8941839c14&amp;chksm=e9c2ed49deb5645fa2586da358a8f0a00dd926f883637adebc59435f846c67c040ef759ba034&amp;scene=0#rd" target="_blank" rel="noopener">设计模式 | 原型模式及典型应用</a><br><a href="https://mp.weixin.qq.com/s?__biz=MzI1NDU0MTE1NA==&amp;mid=2247483721&amp;idx=1&amp;sn=721d0bce3bd516c10d4b6addbf3eced6&amp;chksm=e9c2ed44deb56452395c94a0b150994b94aa26cae71149e6c030d0ac32f9c3c37e2bfe9685b6&amp;scene=0#rd" target="_blank" rel="noopener">设计模式 | 外观模式及典型应用</a><br><a href="https://mp.weixin.qq.com/s?__biz=MzI1NDU0MTE1NA==&amp;mid=2247483726&amp;idx=1&amp;sn=df583e5b297ddaff5e1ab822df762274&amp;chksm=e9c2ed43deb56455d2a099f3c3e8622031027d6da00202e6a7d731eac691e4d87d673ca103b5&amp;scene=0#rd" target="_blank" rel="noopener">设计模式 | 装饰者模式及典型应用</a><br><a href="https://mp.weixin.qq.com/s?__biz=MzI1NDU0MTE1NA==&amp;mid=2247483730&amp;idx=1&amp;sn=859feab7f4632b7ba3d1b5a614d57bbe&amp;chksm=e9c2ed5fdeb56449575995778573fa05a3730ac72792d70fc91e38e2d2f5238899f620481d16&amp;scene=0#rd" target="_blank" rel="noopener">设计模式 | 适配器模式及典型应用</a><br><a href="https://mp.weixin.qq.com/s?__biz=MzI1NDU0MTE1NA==&amp;mid=2247483737&amp;idx=1&amp;sn=ed27a42a80b87ff74f1e1266d918ad5b&amp;chksm=e9c2ed54deb56442aba5c95fbddd4c774eb39ebe7ab8c03471a62e3cf3979e303cef43417bac&amp;scene=0#rd" target="_blank" rel="noopener">设计模式 | 享元模式及典型应用</a><br><a href="https://mp.weixin.qq.com/s?__biz=MzI1NDU0MTE1NA==&amp;mid=2247483742&amp;idx=1&amp;sn=436670dc4793c6c9e7207ca6222e062c&amp;chksm=e9c2ed53deb56445c7fb1aef89ab80b23bab96e6f9993618c98e1746209eec05f36b231cfaa8&amp;scene=0#rd" target="_blank" rel="noopener">设计模式 | 组合模式及典型应用</a><br><a href="https://mp.weixin.qq.com/s?__biz=MzI1NDU0MTE1NA==&amp;mid=2247483747&amp;idx=1&amp;sn=aa494215a2933e2424a6daa03587e478&amp;chksm=e9c2ed6edeb564783b9acd9f5372a08d53d04b001ca362c9213c4379bc7e1bff363e4ad01e3c&amp;scene=0#rd" target="_blank" rel="noopener">设计模式 | 模板方法模式及典型应用</a><br><a href="https://mp.weixin.qq.com/s?__biz=MzI1NDU0MTE1NA==&amp;mid=2247483752&amp;idx=1&amp;sn=7880679f18b5727ea64cd05c06817c35&amp;chksm=e9c2ed65deb56473da688784c4562995c24daf4b13425d0d4d080208728b86525f6600127925&amp;scene=0#rd" target="_blank" rel="noopener">设计模式 | 迭代器模式及典型应用</a>   </p><p><img src="http://image.laijianfeng.org/20180913_001328.png" alt="关注_小旋锋_微信公众号"></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;本文的主要内容：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;介绍策略模式&lt;/li&gt;
&lt;li&gt;示例&lt;ul&gt;
&lt;li&gt;商场购物打折策略的实现&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;策略模式总结&lt;/li&gt;
&lt;li&gt;源码分析策略模式的典型应用&lt;ul&gt;
&lt;li&gt;Java Comparator 中
      
    
    </summary>
    
      <category term="后端" scheme="http://laijianfeng.org/categories/%E5%90%8E%E7%AB%AF/"/>
    
    
      <category term="设计模式" scheme="http://laijianfeng.org/tags/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/"/>
    
  </entry>
  
  <entry>
    <title>20181013-燃烧吧，破铜烂铁！</title>
    <link href="http://laijianfeng.org/2018/10/20181013-%E7%87%83%E7%83%A7%E5%90%A7%EF%BC%8C%E7%A0%B4%E9%93%9C%E7%83%82%E9%93%81%EF%BC%81/"/>
    <id>http://laijianfeng.org/2018/10/20181013-燃烧吧，破铜烂铁！/</id>
    <published>2018-10-13T14:01:20.000Z</published>
    <updated>2018-10-13T14:18:47.380Z</updated>
    
    <content type="html"><![CDATA[<p>燃烧吧，破铜烂铁！</p><p><img src="http://image.laijianfeng.org/20181013220016.jpg" alt="英国Junnk乐队极限音乐会"></p><p>燃烧吧，青春！</p><video src="http://image.laijianfeng.org/WeChat_20181013215718.mp4" controls="controls"><br>英国Junnk乐队极限音乐会<br></video>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;燃烧吧，破铜烂铁！&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;http://image.laijianfeng.org/20181013220016.jpg&quot; alt=&quot;英国Junnk乐队极限音乐会&quot;&gt;&lt;/p&gt;
&lt;p&gt;燃烧吧，青春！&lt;/p&gt;
&lt;video src=&quot;http://i
      
    
    </summary>
    
      <category term="生活杂记" scheme="http://laijianfeng.org/categories/%E7%94%9F%E6%B4%BB%E6%9D%82%E8%AE%B0/"/>
    
    
  </entry>
  
  <entry>
    <title>设计模式 | 迭代器模式及典型应用</title>
    <link href="http://laijianfeng.org/2018/10/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F-%E8%BF%AD%E4%BB%A3%E5%99%A8%E6%A8%A1%E5%BC%8F%E5%8F%8A%E5%85%B8%E5%9E%8B%E5%BA%94%E7%94%A8/"/>
    <id>http://laijianfeng.org/2018/10/设计模式-迭代器模式及典型应用/</id>
    <published>2018-10-11T15:04:40.000Z</published>
    <updated>2018-10-11T15:06:25.849Z</updated>
    
    <content type="html"><![CDATA[<p>本文的主要内容：</p><ul><li>介绍迭代器模式</li><li>源码分析迭代器模式的典型应用<ul><li>Java集合中的迭代器模式</li><li>Mybatis中的迭代器模式</li></ul></li></ul><h2 id="迭代器模式"><a href="#迭代器模式" class="headerlink" title="迭代器模式"></a>迭代器模式</h2><p><strong>迭代器模式(Iterator Pattern)</strong>：提供一种方法来访问聚合对象，而不用暴露这个对象的内部表示，其别名为游标(Cursor)。迭代器模式是一种对象行为型模式。</p><h3 id="角色"><a href="#角色" class="headerlink" title="角色"></a>角色</h3><p><strong>Iterator（抽象迭代器）</strong>：它定义了访问和遍历元素的接口，声明了用于遍历数据元素的方法，例如：用于获取第一个元素的first()方法，用于访问下一个元素的next()方法，用于判断是否还有下一个元素的hasNext()方法，用于获取当前元素的currentItem()方法等，在具体迭代器中将实现这些方法。</p><p><strong>ConcreteIterator（具体迭代器）</strong>：它实现了抽象迭代器接口，完成对聚合对象的遍历，同时在具体迭代器中通过游标来记录在聚合对象中所处的当前位置，在具体实现时，游标通常是一个表示位置的非负整数。</p><p><strong>Aggregate（抽象聚合类）</strong>：它用于存储和管理元素对象，声明一个createIterator()方法用于创建一个迭代器对象，充当抽象迭代器工厂角色。</p><p><strong>ConcreteAggregate（具体聚合类）</strong>：它实现了在抽象聚合类中声明的createIterator()方法，该方法返回一个与该具体聚合类对应的具体迭代器ConcreteIterator实例。</p><p>在迭代器模式中，提供了一个外部的迭代器来对聚合对象进行访问和遍历，迭代器定义了一个访问该聚合元素的接口，并且可以跟踪当前遍历的元素，了解哪些元素已经遍历过而哪些没有。迭代器的引入，将使得对一个复杂聚合对象的操作变得简单。</p><p>在迭代器模式中应用了工厂方法模式，抽象迭代器对应于抽象产品角色，具体迭代器对应于具体产品角色，抽象聚合类对应于抽象工厂角色，具体聚合类对应于具体工厂角色。</p><h2 id="示例"><a href="#示例" class="headerlink" title="示例"></a>示例</h2><p>我们来实现一个学生报数的示例</p><p>定义一个学生类，有一个报数方法 <code>count()</code></p><pre><code class="java">@Getter@Setter@ToStringpublic class Student {    private String name;    private Integer number;    public Student(String name, Integer number) {        this.name = name;        this.number = number;    }    public void count() {        System.out.println(String.format(&quot;我是 %d 号 %s&quot;, this.number, this.name));    }}</code></pre><p>定义班级接口和班级类</p><pre><code class="java">public interface StudentAggregate {    void addStudent(Student student);    void removeStudent(Student student);    StudentIterator getStudentIterator();}public class StudentAggregateImpl implements StudentAggregate {    private List&lt;Student&gt; list;  // 学生列表    public StudentAggregateImpl() {        this.list = new ArrayList&lt;Student&gt;();    }    @Override    public void addStudent(Student student) {        this.list.add(student);    }    @Override    public void removeStudent(Student student) {        this.list.remove(student);    }    @Override    public StudentIterator getStudentIterator() {        return new StudentIteratorImpl(list);    }}</code></pre><p>定义迭代器接口并实现迭代器</p><pre><code class="java">public interface StudentIterator {    boolean hashNext();    Student next();}public class StudentIteratorImpl implements StudentIterator{    private List&lt;Student&gt; list;    private int position = 0;    private Student currentStudent;    public StudentIteratorImpl(List&lt;Student&gt; list) {        this.list = list;    }    @Override    public boolean hashNext() {        return position &lt; list.size();    }    @Override    public Student next() {        currentStudent = list.get(position);        position ++;        return currentStudent;    }}</code></pre><p>测试，进行报数</p><pre><code class="java">public class Test {    public static void main(String[] args) {        StudentAggregate classOne = new StudentAggregateImpl();        classOne.addStudent(new Student(&quot;张三&quot;, 1));        classOne.addStudent(new Student(&quot;李四&quot;, 2));        classOne.addStudent(new Student(&quot;王五&quot;, 3));        classOne.addStudent(new Student(&quot;赵六&quot;, 4));        // 遍历，报数        StudentIterator iterator = classOne.getStudentIterator();        while (iterator.hashNext()){            Student student = iterator.next();            student.count();        }    }}</code></pre><p>输出</p><pre><code>我是 1 号 张三我是 2 号 李四我是 3 号 王五我是 4 号 赵六</code></pre><p>迭代器模式类图如下</p><p><img src="http://image.laijianfeng.org/20181011_214704.jpg" alt="示例.迭代器类图"></p><h2 id="迭代器模式总结"><a href="#迭代器模式总结" class="headerlink" title="迭代器模式总结"></a>迭代器模式总结</h2><p>迭代器模式的<strong>主要优点</strong>如下：</p><ul><li>它支持以不同的方式遍历一个聚合对象，在同一个聚合对象上可以定义多种遍历方式。在迭代器模式中只需要用一个不同的迭代器来替换原有迭代器即可改变遍历算法，我们也可以自己定义迭代器的子类以支持新的遍历方式。</li><li>迭代器简化了聚合类。由于引入了迭代器，在原有的聚合对象中不需要再自行提供数据遍历等方法，这样可以简化聚合类的设计。</li><li>在迭代器模式中，由于引入了抽象层，增加新的聚合类和迭代器类都很方便，无须修改原有代码，满足 “开闭原则” 的要求。</li></ul><p>迭代器模式的<strong>主要缺点</strong>如下：</p><ul><li>由于迭代器模式将存储数据和遍历数据的职责分离，增加新的聚合类需要对应增加新的迭代器类，类的个数成对增加，这在一定程度上增加了系统的复杂性。</li><li>抽象迭代器的设计难度较大，需要充分考虑到系统将来的扩展，例如JDK内置迭代器Iterator就无法实现逆向遍历，如果需要实现逆向遍历，只能通过其子类ListIterator等来实现，而ListIterator迭代器无法用于操作Set类型的聚合对象。在自定义迭代器时，创建一个考虑全面的抽象迭代器并不是件很容易的事情。</li></ul><p><strong>适用场景</strong>:</p><ul><li>访问一个聚合对象的内容而无须暴露它的内部表示。将聚合对象的访问与内部数据的存储分离，使得访问聚合对象时无须了解其内部实现细节。</li><li>需要为一个聚合对象提供多种遍历方式。</li><li>为遍历不同的聚合结构提供一个统一的接口，在该接口的实现类中为不同的聚合结构提供不同的遍历方式，而客户端可以一致性地操作该接口。</li></ul><h2 id="源码分析迭代器模式的典型应用"><a href="#源码分析迭代器模式的典型应用" class="headerlink" title="源码分析迭代器模式的典型应用"></a>源码分析迭代器模式的典型应用</h2><h3 id="Java集合中的迭代器模式"><a href="#Java集合中的迭代器模式" class="headerlink" title="Java集合中的迭代器模式"></a>Java集合中的迭代器模式</h3><p>看 <code>java.util.ArrayList</code> 类</p><pre><code class="java">public class ArrayList&lt;E&gt; extends AbstractList&lt;E&gt; implements List&lt;E&gt;, RandomAccess, Cloneable, java.io.Serializable {    transient Object[] elementData; // non-private to simplify nested class access    private int size;    public E get(int index) {        rangeCheck(index);        return elementData(index);    }    public boolean add(E e) {        ensureCapacityInternal(size + 1);  // Increments modCount!!        elementData[size++] = e;        return true;    }    public ListIterator&lt;E&gt; listIterator() {        return new ListItr(0);    }    public ListIterator&lt;E&gt; listIterator(int index) {        if (index &lt; 0 || index &gt; size)            throw new IndexOutOfBoundsException(&quot;Index: &quot;+index);        return new ListItr(index);    }    public Iterator&lt;E&gt; iterator() {        return new Itr();    }    private class Itr implements Iterator&lt;E&gt; {        int cursor;       // index of next element to return        int lastRet = -1; // index of last element returned; -1 if no such        int expectedModCount = modCount;        public boolean hasNext() {            return cursor != size;        }        public E next() {            //...        }        public E next() {            //...        }        public void remove() {            //...        }        //...    }      private class ListItr extends Itr implements ListIterator&lt;E&gt; {        public boolean hasPrevious() {            return cursor != 0;        }        public int nextIndex() {            return cursor;        }        public int previousIndex() {            return cursor - 1;        }        public E previous() {            //...        }        public void set(E e) {            //...        }        public void add(E e) {            //...        }    //...}</code></pre><p>从 <code>ArrayList</code> 源码中看到了有两个迭代器 <code>Itr</code> 和 <code>ListItr</code>，分别实现 <code>Iterator</code> 和 <code>ListIterator</code> 接口；</p><p>第一个当然很容易看明白，它跟我们示例的迭代器的区别是这里是一个内部类，可以直接使用 <code>ArrayList</code> 的数据列表；第二个迭代器是第一次见到， <code>ListIterator</code> 跟 <code>Iterator</code> 有什么区别呢？</p><p>先看 <code>ListIterator</code> 源码</p><pre><code class="java">public interface ListIterator&lt;E&gt; extends Iterator&lt;E&gt; {    boolean hasNext();    E next();    boolean hasPrevious();  // 返回该迭代器关联的集合是否还有上一个元素    E previous();           // 返回该迭代器的上一个元素    int nextIndex();        // 返回列表中ListIterator所需位置后面元素的索引    int previousIndex();    // 返回列表中ListIterator所需位置前面元素的索引    void remove();    void set(E var1);       // 从列表中将next()或previous()返回的最后一个元素更改为指定元素e    void add(E var1);   }</code></pre><p>接着是 <code>Iterator</code> 的源码</p><pre><code class="java">public interface Iterator&lt;E&gt; {    boolean hasNext();    E next();    default void remove() {        throw new UnsupportedOperationException(&quot;remove&quot;);    }    // 备注：JAVA8允许接口方法定义默认实现    default void forEachRemaining(Consumer&lt;? super E&gt; action) {        Objects.requireNonNull(action);        while (hasNext())            action.accept(next());    }}</code></pre><p>通过源码我们看出：<code>ListIterator</code> 是一个功能更加强大的迭代器，它继承于 <code>Iterator</code> 接口，只能用于各种List类型的访问。可以通过调用 <code>listIterator()</code> 方法产生一个指向List开始处的 <code>ListIterator</code>, 还可以调用 <code>listIterator(n)</code> 方法创建一个一开始就指向列表索引为n的元素处的 <code>ListIterator</code>。</p><p><code>Iterator</code> 和 <code>ListIterator</code> 主要区别概括如下:</p><ul><li><code>ListIterator</code> 有 <code>add()</code> 方法，可以向List中添加对象，而 <code>Iterator</code> 不能</li><li><code>ListIterator</code> 和 <code>Iterator</code> 都有 <code>hasNext()</code> 和 <code>next()</code> 方法，可以实现顺序向后遍历，但是 <code>ListIterator</code> 有 <code>hasPrevious()</code> 和 <code>previous()</code> 方法，可以实现逆向（顺序向前）遍历。<code>Iterator</code> 就不可以。</li><li><code>ListIterator</code> 可以定位当前的索引位置，<code>nextIndex()</code> 和 <code>previousIndex()</code> 可以实现。<code>Iterator</code> 没有此功能。</li><li>都可实现删除对象，但是 <code>ListIterator</code> 可以实现对象的修改，<code>set()</code> 方法可以实现。<code>Iierator</code> 仅能遍历，不能修改。</li></ul><p>敲一个 Iterator 的 Demo 探究一下</p><pre><code class="java">public class Test3 {    public static void main(String[] args) {        List&lt;String&gt; list = new ArrayList&lt;String&gt;();        list.add(&quot;张三&quot;);        list.add(&quot;李四&quot;);        list.add(&quot;王五&quot;);        list.add(&quot;赵六&quot;);        Iterator&lt;String&gt; iterator = list.iterator();        String first = iterator.next();        System.out.println(&quot;first: &quot; + first);        System.out.println(&quot;-----------next-------------&quot;);        while (iterator.hasNext()){            System.out.println(iterator.next());        }        iterator.remove();        System.out.println(&quot;-----------list-------------&quot;);        for (String name: list){            System.out.println(name);        }    }}</code></pre><p>输出结果</p><pre><code>first: 张三-----------next-------------李四王五赵六-----------list-------------张三李四王五</code></pre><p>可以看到 <code>Iterator.remove()</code> 会删除原来的 List 对象的数据</p><p>再敲一个 ListIterator 的 Demo 探究一下</p><pre><code class="java">public class Test2 {    public static void main(String[] args) {        List&lt;String&gt; list = new ArrayList&lt;String&gt;();        list.add(&quot;张三&quot;);        list.add(&quot;李四&quot;);        list.add(&quot;王五&quot;);        list.add(&quot;赵六&quot;);        ListIterator&lt;String&gt; listIterator = list.listIterator();        String first = listIterator.next();        listIterator.set(&quot;小明&quot;);        System.out.println(&quot;first: &quot; + first);        System.out.println(&quot;-----------next-------------&quot;);        listIterator.add(&quot;大明&quot;);        while (listIterator.hasNext()){            System.out.println(listIterator.nextIndex() + &quot;: &quot; + listIterator.next());        }        listIterator.remove();        System.out.println(&quot;------------previous------------&quot;);        while (listIterator.hasPrevious()){            System.out.println(listIterator.previousIndex() + &quot;: &quot; + listIterator.previous());        }        System.out.println(&quot;-----------list-------------&quot;);        for (String name: list){            System.out.println(name);        }    }}</code></pre><p>结果如下</p><pre><code class="java">first: 张三-----------next-------------2: 李四3: 王五4: 赵六------------previous------------3: 王五2: 李四1: 大明0: 小明-----------list-------------小明大明李四王五</code></pre><p>可以看出 <code>ListIterator</code> 的 <code>add</code>、<code>set</code>、<code>remove</code> 方法会直接改变原来的 List 对象，而且可以通过 <code>previous</code> 反向遍历</p><h3 id="Mybatis中的迭代器模式"><a href="#Mybatis中的迭代器模式" class="headerlink" title="Mybatis中的迭代器模式"></a>Mybatis中的迭代器模式</h3><p>当查询数据库返回大量的数据项时可以使用游标 <code>Cursor</code>，利用其中的迭代器可以懒加载数据，避免因为一次性加载所有数据导致内存奔溃，Mybatis 为 <code>Cursor</code> 接口提供了一个默认实现类 <code>DefaultCursor</code>，代码如下</p><pre><code class="java">public interface Cursor&lt;T&gt; extends Closeable, Iterable&lt;T&gt; {    boolean isOpen();    boolean isConsumed();    int getCurrentIndex();}public class DefaultCursor&lt;T&gt; implements Cursor&lt;T&gt; {    private final DefaultResultSetHandler resultSetHandler;    private final ResultMap resultMap;    private final ResultSetWrapper rsw;    private final RowBounds rowBounds;    private final ObjectWrapperResultHandler&lt;T&gt; objectWrapperResultHandler = new ObjectWrapperResultHandler&lt;T&gt;();    // 游标迭代器    private final CursorIterator cursorIterator = new CursorIterator();     protected T fetchNextUsingRowBound() {        T result = fetchNextObjectFromDatabase();        while (result != null &amp;&amp; indexWithRowBound &lt; rowBounds.getOffset()) {            result = fetchNextObjectFromDatabase();        }        return result;    }    @Override    public Iterator&lt;T&gt; iterator() {        if (iteratorRetrieved) {            throw new IllegalStateException(&quot;Cannot open more than one iterator on a Cursor&quot;);        }        iteratorRetrieved = true;        return cursorIterator;    }    private class CursorIterator implements Iterator&lt;T&gt; {        T object;        int iteratorIndex = -1;        @Override        public boolean hasNext() {            if (object == null) {                object = fetchNextUsingRowBound();            }            return object != null;        }        @Override        public T next() {            T next = object;            if (next == null) {                next = fetchNextUsingRowBound();            }            if (next != null) {                object = null;                iteratorIndex++;                return next;            }            throw new NoSuchElementException();        }        @Override        public void remove() {            throw new UnsupportedOperationException(&quot;Cannot remove element from Cursor&quot;);        }    }    // ...}</code></pre><p>游标迭代器 <code>CursorIterator</code> 实现了 <code>java.util.Iterator</code> 迭代器接口，这里的迭代器模式跟 <code>ArrayList</code> 中的迭代器几乎一样</p><blockquote><p>参考：<br>刘伟：设计模式Java版<br>慕课网java设计模式精讲 Debug 方式+内存分析<br><a href="https://blog.csdn.net/weixin_39241397/article/details/79687789" target="_blank" rel="noopener">Java 集合中关于Iterator 和ListIterator的详解</a>   </p></blockquote><h3 id="推荐阅读"><a href="#推荐阅读" class="headerlink" title="推荐阅读"></a>推荐阅读</h3><p><a href="https://mp.weixin.qq.com/s?__biz=MzI1NDU0MTE1NA==&amp;mid=2247483700&amp;idx=1&amp;sn=dd4d23f9400c8be248f5d125465ba941&amp;chksm=e9c2ed39deb5642fb809eca1351f00995f06c9a4875f09986cc5005059eff74d6c20fc1118a3&amp;scene=0#rd" target="_blank" rel="noopener">设计模式 | 简单工厂模式及典型应用</a><br><a href="https://mp.weixin.qq.com/s?__biz=MzI1NDU0MTE1NA==&amp;mid=2247483704&amp;idx=1&amp;sn=fa3ae947cebf22da35e6ac0a37f566f8&amp;chksm=e9c2ed35deb564230a69e43d93a3b74618287c6ddd402a6f1dc6a5b14a896e99584985e7cf92&amp;scene=0#rd" target="_blank" rel="noopener">设计模式 | 工厂方法模式及典型应用</a><br><a href="https://mp.weixin.qq.com/s?__biz=MzI1NDU0MTE1NA==&amp;mid=2247483708&amp;idx=1&amp;sn=9b8c155b86511ea6ec323dc6a72c52df&amp;chksm=e9c2ed31deb56427b2a6bbcbad5bdd3a4ef68b52eb88cc47b5bcfc76773d3d983d8aaf57761c&amp;scene=0#rd" target="_blank" rel="noopener">设计模式 | 抽象工厂模式及典型应用</a><br><a href="https://mp.weixin.qq.com/s?__biz=MzI1NDU0MTE1NA==&amp;mid=2247483712&amp;idx=1&amp;sn=1ffd9837eb9413dde74ff509bf69ecc5&amp;chksm=e9c2ed4ddeb5645b8cbf64c83d103a859ae49921c60e17fe8bebe63c26b04966be101d598848&amp;scene=0#rd" target="_blank" rel="noopener">设计模式 | 建造者模式及典型应用</a><br><a href="https://mp.weixin.qq.com/s?__biz=MzI1NDU0MTE1NA==&amp;mid=2247483716&amp;idx=1&amp;sn=df00c297c8f32e10e277db8941839c14&amp;chksm=e9c2ed49deb5645fa2586da358a8f0a00dd926f883637adebc59435f846c67c040ef759ba034&amp;scene=0#rd" target="_blank" rel="noopener">设计模式 | 原型模式及典型应用</a><br><a href="https://mp.weixin.qq.com/s?__biz=MzI1NDU0MTE1NA==&amp;mid=2247483721&amp;idx=1&amp;sn=721d0bce3bd516c10d4b6addbf3eced6&amp;chksm=e9c2ed44deb56452395c94a0b150994b94aa26cae71149e6c030d0ac32f9c3c37e2bfe9685b6&amp;scene=0#rd" target="_blank" rel="noopener">设计模式 | 外观模式及典型应用</a><br><a href="https://mp.weixin.qq.com/s?__biz=MzI1NDU0MTE1NA==&amp;mid=2247483726&amp;idx=1&amp;sn=df583e5b297ddaff5e1ab822df762274&amp;chksm=e9c2ed43deb56455d2a099f3c3e8622031027d6da00202e6a7d731eac691e4d87d673ca103b5&amp;scene=0#rd" target="_blank" rel="noopener">设计模式 | 装饰者模式及典型应用</a><br><a href="https://mp.weixin.qq.com/s?__biz=MzI1NDU0MTE1NA==&amp;mid=2247483730&amp;idx=1&amp;sn=859feab7f4632b7ba3d1b5a614d57bbe&amp;chksm=e9c2ed5fdeb56449575995778573fa05a3730ac72792d70fc91e38e2d2f5238899f620481d16&amp;scene=0#rd" target="_blank" rel="noopener">设计模式 | 适配器模式及典型应用</a><br><a href="https://mp.weixin.qq.com/s?__biz=MzI1NDU0MTE1NA==&amp;mid=2247483737&amp;idx=1&amp;sn=ed27a42a80b87ff74f1e1266d918ad5b&amp;chksm=e9c2ed54deb56442aba5c95fbddd4c774eb39ebe7ab8c03471a62e3cf3979e303cef43417bac&amp;scene=0#rd" target="_blank" rel="noopener">设计模式 | 享元模式及典型应用</a><br><a href="https://mp.weixin.qq.com/s?__biz=MzI1NDU0MTE1NA==&amp;mid=2247483742&amp;idx=1&amp;sn=436670dc4793c6c9e7207ca6222e062c&amp;chksm=e9c2ed53deb56445c7fb1aef89ab80b23bab96e6f9993618c98e1746209eec05f36b231cfaa8&amp;scene=0#rd" target="_blank" rel="noopener">设计模式 | 组合模式及典型应用</a><br><a href="https://mp.weixin.qq.com/s?__biz=MzI1NDU0MTE1NA==&amp;mid=2247483747&amp;idx=1&amp;sn=aa494215a2933e2424a6daa03587e478&amp;chksm=e9c2ed6edeb564783b9acd9f5372a08d53d04b001ca362c9213c4379bc7e1bff363e4ad01e3c&amp;scene=0#rd" target="_blank" rel="noopener">设计模式 | 模板方法模式及典型应用</a>   </p><p><img src="http://image.laijianfeng.org/20180913_001328.png" alt="关注_小旋锋_微信公众号"></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;本文的主要内容：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;介绍迭代器模式&lt;/li&gt;
&lt;li&gt;源码分析迭代器模式的典型应用&lt;ul&gt;
&lt;li&gt;Java集合中的迭代器模式&lt;/li&gt;
&lt;li&gt;Mybatis中的迭代器模式&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;h2 id=&quot;迭代器模式&quot;
      
    
    </summary>
    
      <category term="后端" scheme="http://laijianfeng.org/categories/%E5%90%8E%E7%AB%AF/"/>
    
    
      <category term="设计模式" scheme="http://laijianfeng.org/tags/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/"/>
    
  </entry>
  
  <entry>
    <title>设计模式 | 模板方法模式及典型应用</title>
    <link href="http://laijianfeng.org/2018/10/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F-%E6%A8%A1%E6%9D%BF%E6%96%B9%E6%B3%95%E6%A8%A1%E5%BC%8F%E5%8F%8A%E5%85%B8%E5%9E%8B%E5%BA%94%E7%94%A8/"/>
    <id>http://laijianfeng.org/2018/10/设计模式-模板方法模式及典型应用/</id>
    <published>2018-10-10T16:22:11.000Z</published>
    <updated>2018-10-10T16:28:29.836Z</updated>
    
    <content type="html"><![CDATA[<p>本文的主要内容：</p><ul><li>介绍模板方法模式</li><li>源码分析模板方法模式的典型应用<ul><li>Servlet 中的模板方法模式</li><li>Mybatis BaseExecutor接口中的模板方法模式</li></ul></li></ul><h2 id="模板方法模式"><a href="#模板方法模式" class="headerlink" title="模板方法模式"></a>模板方法模式</h2><p>在程序开发中，经常会遇到这种情况：某个方法要实现的算法需要多个步骤，但其中有一些步骤是固定不变的，而另一些步骤则是不固定的。为了提高代码的可扩展性和可维护性，模板方法模式在这种场景下就派上了用场。</p><p>譬如制作一节网课的步骤可以简化为4个步骤：</p><ol><li>制作PPT</li><li>录制视频</li><li>编写笔记</li><li>提供课程资料</li></ol><p>其中1、2、3的动作在所有课程中的固定不变的，步骤3可有可无，步骤4在每个课程都不同（有些课程需要提供源代码，有些需要提供图片文件等）</p><p>我们可以在父类中确定整个流程的循序，并实现固定不变的步骤，而把不固定的步骤留给子类实现。甚至可以通过一个钩子方法，让子类来决定流程中某个方法的执行与否</p><p><img src="http://image.laijianfeng.org/20181010_214705.jpg" alt="示例.模板方法模式"></p><p><strong>模板方法模式</strong>：定义一个操作中算法的框架，而将一些步骤延迟到子类中。模板方法模式使得子类可以不改变一个算法的结构即可重定义该算法的某些特定步骤。模板方法模式是一种基于继承的代码复用技术，它是一种类行为型模式。</p><h3 id="角色"><a href="#角色" class="headerlink" title="角色"></a>角色</h3><p><strong>AbstractClass（抽象类）</strong>：在抽象类中定义了一系列基本操作(PrimitiveOperations)，这些基本操作可以是具体的，也可以是抽象的，每一个基本操作对应算法的一个步骤，在其子类中可以重定义或实现这些步骤。同时，在抽象类中实现了一个模板方法(Template Method)，用于定义一个算法的框架，模板方法不仅可以调用在抽象类中实现的基本方法，也可以调用在抽象类的子类中实现的基本方法，还可以调用其他对象中的方法。</p><p><strong>ConcreteClass（具体子类）</strong>：它是抽象类的子类，用于实现在父类中声明的抽象基本操作以完成子类特定算法的步骤，也可以覆盖在父类中已经实现的具体基本操作。</p><p>一个模板方法是定义在抽象类中的、把基本操作方法组合在一起形成一个总算法或一个总行为的方法。这个模板方法定义在抽象类中，并由子类不加以修改地完全继承下来。模板方法是一个具体方法，它给出了一个顶层逻辑框架，而逻辑的组成步骤在抽象类中可以是具体方法，也可以是抽象方法。</p><p>基本方法是实现算法各个步骤的方法，是模板方法的组成部分。基本方法又可以分为三种：抽象方法(Abstract Method)、具体方法(Concrete Method)和钩子方法(Hook Method)。</p><ul><li>抽象方法：一个抽象方法由抽象类声明、由其具体子类实现。</li><li>具体方法：一个具体方法由一个抽象类或具体类声明并实现，其子类可以进行覆盖也可以直接继承。</li><li>钩子方法：可以与一些具体步骤 “挂钩” ，以实现在不同条件下执行模板方法中的不同步骤</li></ul><h2 id="示例"><a href="#示例" class="headerlink" title="示例"></a>示例</h2><p>所以我们通过模板方法模式，在抽象类中把整个流程固定下来，其中1、2、3的实现在抽象类中完成，3的执行与否则由子类通过钩子方法来控制，4则由子类来实现</p><p>抽象类定义如下：</p><pre><code class="java">public abstract class ACourse {    protected final void makeCourse() {        this.makePPT();        this.makeVideo();        if (needWriteArticle()) {            this.writeArticle();        }        this.packageCourse();    }    final void makePPT() {        System.out.println(&quot;1. 制作PPT&quot;);    }    final void makeVideo() {        System.out.println(&quot;2. 制作视频&quot;);    }    final void writeArticle() {        System.out.println(&quot;3. 编写课程笔记&quot;);    }    //钩子方法    protected boolean needWriteArticle() {        return false;    }    abstract void packageCourse();}</code></pre><p>其中的 <code>makeCourse</code> 方法是模板方法，它定义了制作网课的基本流程，<code>makePPT</code>、<code>makeVideo</code>、<code>writeArticle</code> 这三个步骤在所有课程中都是固定的，所以用 <code>final</code> 关键字修饰；<code>packageCourse</code> 方法在所有课程中都可能不一样，所以声明为抽象方法，由子类自行实现；钩子方法 <code>needWriteArticle</code> 返回一个 <code>boolean</code> 类型的值，控制是否编写课程笔记</p><p>子类 JavaCourse，实现了抽象方法 <code>packageCourse</code>，重写了钩子方法 <code>needWriteArticle</code></p><pre><code class="java">public class JavaCourse extends ACourse {    @Override    void packageCourse() {        System.out.println(&quot;4. 提供Java课程源代码&quot;);    }    @Override    protected boolean needWriteArticle() {        return true;    }}</code></pre><p>子类 FECourse，实现了抽象方法 <code>packageCourse</code>，重写了钩子方法 <code>needWriteArticle</code>，其中把钩子方法的结果交给客户端确定</p><pre><code class="java">public class FECourse extends ACourse {    private boolean needWriteArticleFlag = false;    @Override    void packageCourse() {        System.out.println(&quot;4.1 提供课程的前端代码&quot;);        System.out.println(&quot;4.2 提供课程的图片等多媒体素材&quot;);    }    public FECourse(boolean needWriteArticleFlag) {        this.needWriteArticleFlag = needWriteArticleFlag;    }    @Override    protected boolean needWriteArticle() {        return this.needWriteArticleFlag;    }}</code></pre><p>客户端测试</p><pre><code class="java">public class Test {    public static void main(String[] args) {        System.out.println(&quot;Java课程start---&quot;);        ACourse javaCourse = new JavaCourse();        javaCourse.makeCourse();        System.out.println(&quot;Java课程end---\n&quot;);        System.out.println(&quot;前端课程start---&quot;);        ACourse feCourse = new FECourse(false);        feCourse.makeCourse();        System.out.println(&quot;前端课程end---&quot;);    }}</code></pre><p>输出结果</p><pre><code>Java课程start---1. 制作PPT2. 制作视频3. 编写笔记4. 提供Java课程源代码Java课程end---前端课程start---1. 制作PPT2. 制作视频4.1 提供课程的前端代码4.2 提供课程的图片等多媒体素材前端课程end---</code></pre><p>它们的类图如下</p><p><img src="http://image.laijianfeng.org/20181010_213837.png" alt="示例.模板方法模式"></p><h2 id="模板方法模式总结"><a href="#模板方法模式总结" class="headerlink" title="模板方法模式总结"></a>模板方法模式总结</h2><p>模板方法模式的<strong>主要优点</strong>如下：</p><ul><li>在父类中形式化地定义一个算法，而由它的子类来实现细节的处理，在子类实现详细的处理算法时并不会改变算法中步骤的执行次序。</li><li>模板方法模式是一种代码复用技术，它在类库设计中尤为重要，它提取了类库中的公共行为，将公共行为放在父类中，而通过其子类来实现不同的行为，它鼓励我们恰当使用继承来实现代码复用。</li><li>可实现一种反向控制结构，通过子类覆盖父类的钩子方法来决定某一特定步骤是否需要执行。</li><li>在模板方法模式中可以通过子类来覆盖父类的基本方法，不同的子类可以提供基本方法的不同实现，更换和增加新的子类很方便，符合单一职责原则和开闭原则。</li></ul><p>模板方法模式的<strong>主要缺点</strong>如下：</p><ul><li>需要为每一个基本方法的不同实现提供一个子类，如果父类中可变的基本方法太多，将会导致类的个数增加，系统更加庞大，设计也更加抽象，此时，可结合桥接模式来进行设计。</li></ul><p><strong>适用场景</strong>：</p><ul><li>对一些复杂的算法进行分割，将其算法中固定不变的部分设计为模板方法和父类具体方法，而一些可以改变的细节由其子类来实现。即：一次性实现一个算法的不变部分，并将可变的行为留给子类来实现。</li><li>各子类中公共的行为应被提取出来并集中到一个公共父类中以避免代码重复。</li><li>需要通过子类来决定父类算法中某个步骤是否执行，实现子类对父类的反向控制。</li></ul><h2 id="源码分析模板方法模式的典型应用"><a href="#源码分析模板方法模式的典型应用" class="headerlink" title="源码分析模板方法模式的典型应用"></a>源码分析模板方法模式的典型应用</h2><h3 id="Servlet-中的模板方法模式"><a href="#Servlet-中的模板方法模式" class="headerlink" title="Servlet 中的模板方法模式"></a>Servlet 中的模板方法模式</h3><p><code>Servlet</code>（Server Applet）是Java Servlet的简称，用Java编写的服务器端程序，主要功能在于交互式地浏览和修改数据，生成动态Web内容。在每一个 <code>Servlet</code> 都必须要实现 <code>Servlet</code> 接口，<code>GenericServlet</code> 是个通用的、不特定于任何协议的Servlet，它实现了 <code>Servlet</code> 接口，而 <code>HttpServlet</code> 继承于 <code>GenericServlet</code>，实现了 <code>Servlet</code> 接口，为 <code>Servlet</code> 接口提供了处理HTTP协议的通用实现，所以我们定义的 <code>Servlet</code> 只需要继承 <code>HttpServlet</code> 即可。</p><p><img src="http://image.laijianfeng.org/20181010_214703.png" alt="HttpServlet的继承关系"></p><p><code>HttpServlet</code> 的简要代码如下所示</p><pre><code class="java">public abstract class HttpServlet extends GenericServlet {    protected void doGet(HttpServletRequest req, HttpServletResponse resp) throws ServletException, IOException {        // ...    }    protected void doPost(HttpServletRequest req, HttpServletResponse resp) throws ServletException, IOException {        // ...    }    protected void doHead(HttpServletRequest req, HttpServletResponse resp) throws ServletException, IOException {        // ...    }    protected void doPut(HttpServletRequest req, HttpServletResponse resp) throws ServletException, IOException {        // ...    }    protected void doDelete(HttpServletRequest req,  HttpServletResponse resp) throws ServletException, IOException {        // ...    }    protected void doOptions(HttpServletRequest req, HttpServletResponse resp) throws ServletException, IOException {        // ...    }    protected void doTrace(HttpServletRequest req, HttpServletResponse resp) throws ServletException, IOException {        // ...    }    protected void service(HttpServletRequest req, HttpServletResponse resp) throws ServletException, IOException {        String method = req.getMethod();        if (method.equals(METHOD_GET)) {            long lastModified = getLastModified(req);            if (lastModified == -1) {                // servlet doesn&#39;t support if-modified-since, no reason                // to go through further expensive logic                doGet(req, resp);            } else {                long ifModifiedSince = req.getDateHeader(HEADER_IFMODSINCE);                if (ifModifiedSince &lt; lastModified) {                    // If the servlet mod time is later, call doGet()                    // Round down to the nearest second for a proper compare                    // A ifModifiedSince of -1 will always be less                    maybeSetLastModified(resp, lastModified);                    doGet(req, resp);                } else {                    resp.setStatus(HttpServletResponse.SC_NOT_MODIFIED);                }            }        } else if (method.equals(METHOD_HEAD)) {            long lastModified = getLastModified(req);            maybeSetLastModified(resp, lastModified);            doHead(req, resp);        } else if (method.equals(METHOD_POST)) {            doPost(req, resp);        } else if (method.equals(METHOD_PUT)) {            doPut(req, resp);        } else if (method.equals(METHOD_DELETE)) {            doDelete(req, resp);        } else if (method.equals(METHOD_OPTIONS)) {            doOptions(req,resp);        } else if (method.equals(METHOD_TRACE)) {            doTrace(req,resp);        } else {            //            // Note that this means NO servlet supports whatever            // method was requested, anywhere on this server.            //            String errMsg = lStrings.getString(&quot;http.method_not_implemented&quot;);            Object[] errArgs = new Object[1];            errArgs[0] = method;            errMsg = MessageFormat.format(errMsg, errArgs);            resp.sendError(HttpServletResponse.SC_NOT_IMPLEMENTED, errMsg);        }    }    // ...省略...}</code></pre><p>在 <code>HttpServlet</code> 的 <code>service</code> 方法中，首先获得到请求的方法名，然后根据方法名调用对应的 <code>doXXX</code> 方法，比如说请求方法为GET，那么就去调用 <code>doGet</code> 方法；请求方法为POST，那么就去调用 <code>doPost</code> 方法</p><p><code>HttpServlet</code> 相当于定义了一套处理 HTTP 请求的模板；<code>service</code> 方法为模板方法，定义了处理HTTP请求的基本流程；<code>doXXX</code> 等方法为基本方法，根据请求方法做相应的处理，子类可重写这些方法；<code>HttpServletRequest</code> 中的Method则起到钩子方法的作用.</p><p>在开发javaWeb应用时，自定义的Servlet类一般都扩展 <code>HttpServlet</code> 类，譬如我们实现一个输出 <code>Hello World!</code> 的 <code>Servlet</code> 如下</p><pre><code class="java">import java.io.*;import javax.servlet.*;import javax.servlet.http.*;// 扩展 HttpServlet 类public class HelloWorld extends HttpServlet {  public void init() throws ServletException {    // ...  }  public void doGet(HttpServletRequest request, HttpServletResponse response) throws ServletException, IOException {      response.setContentType(&quot;text/html&quot;);      PrintWriter out = response.getWriter();      out.println(&quot;&lt;h1&gt;Hello World!&lt;/h1&gt;&quot;);  }  public void destroy() {      // ...  }}</code></pre><p>该自定义的 <code>Servlet</code> 重写了 <code>doGet</code> 方法，当客户端发起 GET 请求时将得到 <code>&lt;h1&gt;Hello World!&lt;/h1&gt;</code>。</p><h3 id="Mybatis-BaseExecutor接口中的模板方法模式"><a href="#Mybatis-BaseExecutor接口中的模板方法模式" class="headerlink" title="Mybatis BaseExecutor接口中的模板方法模式"></a>Mybatis BaseExecutor接口中的模板方法模式</h3><p><code>Executor</code> 是 Mybatis 的核心接口之一，其中定义了数据库操作的基本方法，该接口的代码如下：</p><pre><code>public interface Executor {  ResultHandler NO_RESULT_HANDLER = null;  // 执行 update、insert、delete 三种类型的SQL语句  int update(MappedStatement ms, Object parameter) throws SQLException;  // 执行selete类型的SQL语句，返回值分为结果对象列表或游标对象  &lt;E&gt; List&lt;E&gt; query(MappedStatement ms, Object parameter, RowBounds rowBounds, ResultHandler resultHandler, CacheKey cacheKey, BoundSql boundSql) throws SQLException;  /  &lt;E&gt; List&lt;E&gt; query(MappedStatement ms, Object parameter, RowBounds rowBounds, ResultHandler resultHandler) throws SQLException;  &lt;E&gt; Cursor&lt;E&gt; queryCursor(MappedStatement ms, Object parameter, RowBounds rowBounds) throws SQLException;   // 批量执行SQL语句  List&lt;BatchResult&gt; flushStatements() throws SQLException;  // 提交事务  void commit(boolean required) throws SQLException;  // 回滚事务  void rollback(boolean required) throws SQLException;  // 创建缓存中用到的CacheKey对象  CacheKey createCacheKey(MappedStatement ms, Object parameterObject, RowBounds rowBounds, BoundSql boundSql);  // 根据CacheKey对象查找缓存  boolean isCached(MappedStatement ms, CacheKey key);  // 清空一级缓存  void clearLocalCache();  // 延迟加载一级缓存中的数据  void deferLoad(MappedStatement ms, MetaObject resultObject, String property, CacheKey key, Class&lt;?&gt; targetType);  // 获取事务对象  Transaction getTransaction();  // 关闭Executor对象  void close(boolean forceRollback);  // 检测Executor是否已关闭  boolean isClosed();  void setExecutorWrapper(Executor executor);}</code></pre><p><code>Executor</code> 类的类图如下</p><p><img src="http://image.laijianfeng.org/20181010_214704.png" alt="Executor与其子类的类图"></p><p><code>BaseExecutor</code> 中主要提供了缓存管理和事务管理的基本功能，继承 <code>BaseExecutor</code> 的子类只需要实现四个基本方法来完成数据库的相关操作即可，这四个方法分别是：<code>doUpdate()</code> 方法、<code>doQuery()</code> 方法、<code>doQueryCursor()</code> 方法、<code>doFlushStatement()</code> 方法，其余功能都在 <code>BaseExecutor</code> 中实现。</p><p><code>BaseExecutor</code>的部分代码如下，其中的 <code>query()</code> 方法首先会创建 <code>CacheKey</code> 对象，并根据 <code>CacheKey</code> 对象查找一级缓存，如果缓存命中则返回缓存中记录的结果对象，如果未命中则查询数据库得到结果集，之后将结果集映射成结果对象并保存到一级缓存中，同时返回结果对象。</p><pre><code class="java">public abstract class BaseExecutor implements Executor {  protected Transaction transaction;  protected Executor wrapper;  protected ConcurrentLinkedQueue&lt;DeferredLoad&gt; deferredLoads;  protected PerpetualCache localCache;  protected PerpetualCache localOutputParameterCache;  protected Configuration configuration;  protected int queryStack = 0;  private boolean closed;  @Override  public &lt;E&gt; List&lt;E&gt; query(MappedStatement ms, Object parameter, RowBounds rowBounds, ResultHandler resultHandler, CacheKey key, BoundSql boundSql) throws SQLException {    ErrorContext.instance().resource(ms.getResource()).activity(&quot;executing a query&quot;).object(ms.getId());    if (closed) {      throw new ExecutorException(&quot;Executor was closed.&quot;);    }    if (queryStack == 0 &amp;&amp; ms.isFlushCacheRequired()) {      clearLocalCache();    }    List&lt;E&gt; list;    try {      queryStack++;      list = resultHandler == null ? (List&lt;E&gt;) localCache.getObject(key) : null;      if (list != null) {        handleLocallyCachedOutputParameters(ms, key, parameter, boundSql);      } else {        list = queryFromDatabase(ms, parameter, rowBounds, resultHandler, key, boundSql);      }    } finally {      queryStack--;    }    if (queryStack == 0) {      for (DeferredLoad deferredLoad : deferredLoads) {        deferredLoad.load();      }      // issue #601      deferredLoads.clear();      if (configuration.getLocalCacheScope() == LocalCacheScope.STATEMENT) {        // issue #482        clearLocalCache();      }    }    return list;  }  protected abstract int doUpdate(MappedStatement ms, Object parameter)      throws SQLException;  protected abstract List&lt;BatchResult&gt; doFlushStatements(boolean isRollback)      throws SQLException;  protected abstract &lt;E&gt; List&lt;E&gt; doQuery(MappedStatement ms, Object parameter, RowBounds rowBounds, ResultHandler resultHandler, BoundSql boundSql)      throws SQLException;  protected abstract &lt;E&gt; Cursor&lt;E&gt; doQueryCursor(MappedStatement ms, Object parameter, RowBounds rowBounds, BoundSql boundSql)      throws SQLException;  // 省略....}</code></pre><p><code>BaseExecutor</code> 的子类有四个分别是 <code>SimpleExecotor</code>、<code>ReuseExecutor</code>、<code>BatchExecutor</code>、<code>ClosedExecutor</code>，由于这里使用了模板方法模式，一级缓存等固定不变的操作都封装到了 <code>BaseExecutor</code> 中，因此子类就不必再关心一级缓存等操作，只需要专注实现4个基本方法的实现即可。</p><p>这里对这四个子类的功能做一个简要的介绍：</p><ul><li><code>SimpleExecutor</code> 是Mybatis执行Mapper语句时默认使用的 <code>Executor</code>，提供最基本的Mapper语句执行功能，没有过多的封装的</li><li><code>ReuseExecutor</code> 提供了 <code>Statement</code> 重用的功能，通过 <code>statementMap</code> 字段缓存使用过的 <code>Statement</code> 对象进行重用，可以减少SQL预编译以及创建和销毁 <code>Statement</code> 对象的开销，从而提高性能</li><li><code>BatchExecutor</code> 实现了批处理多条SQL语句的功能，在客户端缓存多条SQL并在合适的时机将多条SQL打包发送给数据库执行，从而减少网络方面的开销，提升系统的性能</li><li><code>ClosedExecutor</code> 只是某个类的一个内部类</li></ul><blockquote><p>参考：<br>刘伟：设计模式Java版<br>慕课网java设计模式精讲 Debug 方式+内存分析<br>徐郡明：Mybatis技术内幕 3.6 Executor</p></blockquote><h3 id="推荐阅读"><a href="#推荐阅读" class="headerlink" title="推荐阅读"></a>推荐阅读</h3><p><a href="https://mp.weixin.qq.com/s?__biz=MzI1NDU0MTE1NA==&amp;mid=2247483700&amp;idx=1&amp;sn=dd4d23f9400c8be248f5d125465ba941&amp;chksm=e9c2ed39deb5642fb809eca1351f00995f06c9a4875f09986cc5005059eff74d6c20fc1118a3&amp;scene=0#rd" target="_blank" rel="noopener">设计模式 | 简单工厂模式及典型应用</a><br><a href="https://mp.weixin.qq.com/s?__biz=MzI1NDU0MTE1NA==&amp;mid=2247483704&amp;idx=1&amp;sn=fa3ae947cebf22da35e6ac0a37f566f8&amp;chksm=e9c2ed35deb564230a69e43d93a3b74618287c6ddd402a6f1dc6a5b14a896e99584985e7cf92&amp;scene=0#rd" target="_blank" rel="noopener">设计模式 | 工厂方法模式及典型应用</a><br><a href="https://mp.weixin.qq.com/s?__biz=MzI1NDU0MTE1NA==&amp;mid=2247483708&amp;idx=1&amp;sn=9b8c155b86511ea6ec323dc6a72c52df&amp;chksm=e9c2ed31deb56427b2a6bbcbad5bdd3a4ef68b52eb88cc47b5bcfc76773d3d983d8aaf57761c&amp;scene=0#rd" target="_blank" rel="noopener">设计模式 | 抽象工厂模式及典型应用</a><br><a href="https://mp.weixin.qq.com/s?__biz=MzI1NDU0MTE1NA==&amp;mid=2247483712&amp;idx=1&amp;sn=1ffd9837eb9413dde74ff509bf69ecc5&amp;chksm=e9c2ed4ddeb5645b8cbf64c83d103a859ae49921c60e17fe8bebe63c26b04966be101d598848&amp;scene=0#rd" target="_blank" rel="noopener">设计模式 | 建造者模式及典型应用</a><br><a href="https://mp.weixin.qq.com/s?__biz=MzI1NDU0MTE1NA==&amp;mid=2247483716&amp;idx=1&amp;sn=df00c297c8f32e10e277db8941839c14&amp;chksm=e9c2ed49deb5645fa2586da358a8f0a00dd926f883637adebc59435f846c67c040ef759ba034&amp;scene=0#rd" target="_blank" rel="noopener">设计模式 | 原型模式及典型应用</a><br><a href="https://mp.weixin.qq.com/s?__biz=MzI1NDU0MTE1NA==&amp;mid=2247483721&amp;idx=1&amp;sn=721d0bce3bd516c10d4b6addbf3eced6&amp;chksm=e9c2ed44deb56452395c94a0b150994b94aa26cae71149e6c030d0ac32f9c3c37e2bfe9685b6&amp;scene=0#rd" target="_blank" rel="noopener">设计模式 | 外观模式及典型应用</a><br><a href="https://mp.weixin.qq.com/s?__biz=MzI1NDU0MTE1NA==&amp;mid=2247483726&amp;idx=1&amp;sn=df583e5b297ddaff5e1ab822df762274&amp;chksm=e9c2ed43deb56455d2a099f3c3e8622031027d6da00202e6a7d731eac691e4d87d673ca103b5&amp;scene=0#rd" target="_blank" rel="noopener">设计模式 | 装饰者模式及典型应用</a><br><a href="https://mp.weixin.qq.com/s?__biz=MzI1NDU0MTE1NA==&amp;mid=2247483730&amp;idx=1&amp;sn=859feab7f4632b7ba3d1b5a614d57bbe&amp;chksm=e9c2ed5fdeb56449575995778573fa05a3730ac72792d70fc91e38e2d2f5238899f620481d16&amp;scene=0#rd" target="_blank" rel="noopener">设计模式 | 适配器模式及典型应用</a><br><a href="https://mp.weixin.qq.com/s?__biz=MzI1NDU0MTE1NA==&amp;mid=2247483737&amp;idx=1&amp;sn=ed27a42a80b87ff74f1e1266d918ad5b&amp;chksm=e9c2ed54deb56442aba5c95fbddd4c774eb39ebe7ab8c03471a62e3cf3979e303cef43417bac&amp;scene=0#rd" target="_blank" rel="noopener">设计模式 | 享元模式及典型应用</a><br><a href="https://mp.weixin.qq.com/s?__biz=MzI1NDU0MTE1NA==&amp;mid=2247483742&amp;idx=1&amp;sn=436670dc4793c6c9e7207ca6222e062c&amp;chksm=e9c2ed53deb56445c7fb1aef89ab80b23bab96e6f9993618c98e1746209eec05f36b231cfaa8&amp;scene=0#rd" target="_blank" rel="noopener">设计模式 | 组合模式及典型应用</a></p><p><img src="http://image.laijianfeng.org/20180913_001328.png" alt="关注_小旋锋_微信公众号"></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;本文的主要内容：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;介绍模板方法模式&lt;/li&gt;
&lt;li&gt;源码分析模板方法模式的典型应用&lt;ul&gt;
&lt;li&gt;Servlet 中的模板方法模式&lt;/li&gt;
&lt;li&gt;Mybatis BaseExecutor接口中的模板方法模式&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
      
    
    </summary>
    
      <category term="后端" scheme="http://laijianfeng.org/categories/%E5%90%8E%E7%AB%AF/"/>
    
    
      <category term="设计模式" scheme="http://laijianfeng.org/tags/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/"/>
    
  </entry>
  
  <entry>
    <title>设计模式 | 组合模式及典型应用</title>
    <link href="http://laijianfeng.org/2018/10/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F-%E7%BB%84%E5%90%88%E6%A8%A1%E5%BC%8F%E5%8F%8A%E5%85%B8%E5%9E%8B%E5%BA%94%E7%94%A8/"/>
    <id>http://laijianfeng.org/2018/10/设计模式-组合模式及典型应用/</id>
    <published>2018-10-05T09:18:04.000Z</published>
    <updated>2018-10-05T09:20:40.553Z</updated>
    
    <content type="html"><![CDATA[<p>本文的主要内容：</p><ul><li>介绍组合模式</li><li>示例</li><li>组合模式总结</li><li>源码分析组合模式的典型应用<ul><li>java.awt中的组合模式</li><li>Java集合中的组合模式</li><li>Mybatis SqlNode中的组合模式</li></ul></li></ul><h2 id="组合模式"><a href="#组合模式" class="headerlink" title="组合模式"></a>组合模式</h2><p>树形结构不论在生活中或者是开发中都是一种非常常见的结构，一个容器对象（如文件夹）下可以存放多种不同的叶子对象或者容器对象，容器对象与叶子对象之间属性差别可能非常大。</p><p>由于容器对象和叶子对象在功能上的区别，在使用这些对象的代码中必须有区别地对待容器对象和叶子对象，而实际上<strong>大多数情况下我们希望一致地处理它们</strong>，因为对于这些对象的区别对待将会使得程序非常复杂。</p><p><img src="http://image.laijianfeng.org/20181005_123836.jpg" alt="一个简化的Linux目录树"></p><p>组合模式为解决此类问题而诞生，<strong>它可以让叶子对象和容器对象的使用具有一致性</strong>。</p><p><strong>组合模式(Composite Pattern)</strong>：组合多个对象形成树形结构以表示具有 “整体—部分” 关系的层次结构。组合模式对单个对象（即叶子对象）和组合对象（即容器对象）的使用具有一致性，组合模式又可以称为 “整体—部分”(Part-Whole) 模式，它是一种对象结构型模式。</p><p>由于在软件开发中存在大量的树形结构，因此组合模式是一种使用频率较高的结构型设计模式，Java SE中的AWT和Swing包的设计就基于组合模式。</p><p>除此以外，在XML解析、组织结构树处理、文件系统设计等领域，组合模式都得到了广泛应用。</p><h3 id="角色"><a href="#角色" class="headerlink" title="角色"></a>角色</h3><p><strong>Component（抽象构件）</strong>：它可以是接口或抽象类，为叶子构件和容器构件对象声明接口，在该角色中可以包含所有子类共有行为的声明和实现。在抽象构件中定义了访问及管理它的子构件的方法，如增加子构件、删除子构件、获取子构件等。</p><p><strong>Leaf（叶子构件）</strong>：它在组合结构中表示叶子节点对象，叶子节点没有子节点，它实现了在抽象构件中定义的行为。对于那些访问及管理子构件的方法，可以通过异常等方式进行处理。</p><p><strong>Composite（容器构件）</strong>：它在组合结构中表示容器节点对象，容器节点包含子节点，其子节点可以是叶子节点，也可以是容器节点，它提供一个集合用于存储子节点，实现了在抽象构件中定义的行为，包括那些访问及管理子构件的方法，在其业务方法中可以递归调用其子节点的业务方法。</p><p>组合模式的<strong>关键是定义了一个抽象构件类，它既可以代表叶子，又可以代表容器</strong>，而客户端针对该抽象构件类进行编程，无须知道它到底表示的是叶子还是容器，可以对其进行统一处理。<strong>同时容器对象与抽象构件类之间还建立一个聚合关联关系</strong>，在容器对象中既可以包含叶子，也可以包含容器，以此实现递归组合，形成一个树形结构。</p><h2 id="示例"><a href="#示例" class="headerlink" title="示例"></a>示例</h2><p>我们来实现一个简单的目录树，有文件夹和文件两种类型，首先需要一个抽象构件类，声明了文件夹类和文件类需要的方法</p><pre><code class="java">public abstract class Component {    public String getName() {        throw new UnsupportedOperationException(&quot;不支持获取名称操作&quot;);    }    public void add(Component component) {        throw new UnsupportedOperationException(&quot;不支持添加操作&quot;);    }    public void remove(Component component) {        throw new UnsupportedOperationException(&quot;不支持删除操作&quot;);    }    public void print() {        throw new UnsupportedOperationException(&quot;不支持打印操作&quot;);    }    public String getContent() {        throw new UnsupportedOperationException(&quot;不支持获取内容操作&quot;);    }}</code></pre><p>实现一个文件夹类 Folder，继承 Component，定义一个 <code>List&lt;Component&gt;</code> 类型的componentList属性，用来存储该文件夹下的文件和子文件夹，并实现 getName、add、remove、print等方法</p><pre><code class="java">public class Folder extends Component {    private String name;    private List&lt;Component&gt; componentList = new ArrayList&lt;Component&gt;();    public Folder(String name) {        this.name = name;    }    @Override    public String getName() {        return this.name;    }    @Override    public void add(Component component) {        this.componentList.add(component);    }    @Override    public void remove(Component component) {        this.componentList.remove(component);    }    @Override    public void print() {        System.out.println(this.getName());        for (Component component : this.componentList) {            component.print();        }    }}</code></pre><p>文件类 File，继承Component父类，实现 getName、print、getContent等方法</p><pre><code class="java">public class File extends Component {    private String name;    private String content;    public File(String name, String content) {        this.name = name;        this.content = content;    }    @Override    public String getName() {        return this.name;    }    @Override    public void print() {        System.out.println(this.getName());    }    @Override    public String getContent() {        return this.content;    }}</code></pre><p>我们来测试一下</p><pre><code class="java">public class Test {    public static void main(String[] args) {        Folder DSFolder = new Folder(&quot;设计模式资料&quot;);        File note1 = new File(&quot;组合模式笔记.md&quot;, &quot;组合模式组合多个对象形成树形结构以表示具有 \&quot;整体—部分\&quot; 关系的层次结构&quot;);        File note2 = new File(&quot;工厂方法模式.md&quot;, &quot;工厂方法模式定义一个用于创建对象的接口，让子类决定将哪一个类实例化。&quot;);        DSFolder.add(note1);        DSFolder.add(note2);        Folder codeFolder = new Folder(&quot;样例代码&quot;);        File readme = new File(&quot;README.md&quot;, &quot;# 设计模式示例代码项目&quot;);        Folder srcFolder = new Folder(&quot;src&quot;);        File code1 = new File(&quot;组合模式示例.java&quot;, &quot;这是组合模式的示例代码&quot;);        srcFolder.add(code1);        codeFolder.add(readme);        codeFolder.add(srcFolder);        DSFolder.add(codeFolder);        DSFolder.print();    }}</code></pre><p>输出结果</p><pre><code>设计模式资料组合模式笔记.md工厂方法模式.md样例代码README.mdsrc组合模式示例.java</code></pre><p>输出正常，不过有个小问题，<strong>从输出看不出它们的层级结构</strong>，为了体现出它们之间的层级关系，我们需要改造一下 Folder 类，增加一个 level 属性，并修改 print 方法</p><pre><code class="java">public class Folder extends Component {    private String name;    private List&lt;Component&gt; componentList = new ArrayList&lt;Component&gt;();    public Integer level;    public Folder(String name) {        this.name = name;    }    @Override    public String getName() {        return this.name;    }    @Override    public void add(Component component) {        this.componentList.add(component);    }    @Override    public void remove(Component component) {        this.componentList.remove(component);    }    @Override    public void print() {        System.out.println(this.getName());        if (this.level == null) {            this.level = 1;        }        String prefix = &quot;&quot;;        for (int i = 0; i &lt; this.level; i++) {            prefix += &quot;\t- &quot;;        }        for (Component component : this.componentList) {            if (component instanceof Folder){                ((Folder)component).level = this.level + 1;            }            System.out.print(prefix);            component.print();        }        this.level = null;    }}</code></pre><p>现在的输出就有相应的层级结构了</p><pre><code>设计模式资料    - 组合模式笔记.md    - 工厂方法模式.md    - 样例代码    -     - README.md    -     - src    -     -     - 组合模式示例.java</code></pre><p>我们可以画出它们之间的类图</p><p><img src="http://image.laijianfeng.org/20181004_164219.png" alt="示例.组合模式类图"></p><p>在这里父类 <code>Component</code> 是一个抽象构件类，<code>Folder</code> 类是一个容器构件类，<code>File</code> 是一个叶子构件类，Folder 和 File 继承了 Component，Folder 与 Component 又是聚合关系</p><h2 id="透明与安全"><a href="#透明与安全" class="headerlink" title="透明与安全"></a>透明与安全</h2><p>在使用组合模式时，根据抽象构件类的定义形式，我们可将组合模式分为透明组合模式和安<br>全组合模式两种形式。</p><p><strong>透明组合模式</strong></p><p>透明组合模式中，抽象构件角色中声明了所有用于管理成员对象的方法，譬如在示例中 <code>Component</code> 声明了 <code>add</code>、<code>remove</code> 方法，这样做的好处是确保所有的构件类都有相同的接口。透明组合模式也是组合模式的标准形式。</p><p>透明组合模式的缺点是不够安全，因为叶子对象和容器对象在本质上是有区别的，叶子对象不可能有下一个层次的对象，即不可能包含成员对象，因此为其提供 <code>add()</code>、<code>remove()</code> 等方法是没有意义的，这在编译阶段不会出错，但在运行阶段如果调用这些方法可能会出错（如果没有提供相应的错误处理代码）</p><p><strong>安全组合模式</strong> </p><p>在安全组合模式中，在抽象构件角色中没有声明任何用于管理成员对象的方法，而是在容器构件 <code>Composite</code> 类中声明并实现这些方法。</p><p><img src="http://image.laijianfeng.org/20181005_123837.jpg" alt="安全组合模式模式图"></p><p>安全组合模式的缺点是不够透明，因为叶子构件和容器构件具有不同的方法，且容器构件中那些用于管理成员对象的方法没有在抽象构件类中定义，因此客户端不能完全针对抽象编程，必须有区别地对待叶子构件和容器构件。</p><p>在实际应用中 <code>java.awt</code> 和 <code>swing</code> 中的组合模式即为安全组合模式。</p><h2 id="组合模式总结"><a href="#组合模式总结" class="headerlink" title="组合模式总结"></a>组合模式总结</h2><p>组合模式的<strong>主要优点</strong>如下：</p><ul><li>组合模式可以清楚地定义分层次的复杂对象，表示对象的全部或部分层次，它让客户端忽略了层次的差异，方便对整个层次结构进行控制。</li><li>客户端可以一致地使用一个组合结构或其中单个对象，不必关心处理的是单个对象还是整个组合结构，简化了客户端代码。</li><li>在组合模式中增加新的容器构件和叶子构件都很方便，无须对现有类库进行任何修改，符合“开闭原则”。</li><li>组合模式为树形结构的面向对象实现提供了一种灵活的解决方案，通过叶子对象和容器对象的递归组合，可以形成复杂的树形结构，但对树形结构的控制却非常简单。</li></ul><p>组合模式的<strong>主要缺点</strong>如下：</p><ul><li>使得设计更加复杂，客户端需要花更多时间理清类之间的层次关系。</li><li>在增加新构件时很难对容器中的构件类型进行限制。</li></ul><p><strong>适用场景</strong>：</p><ul><li>在具有整体和部分的层次结构中，希望通过一种方式忽略整体与部分的差异，客户端可以一致地对待它们。</li><li>在一个使用面向对象语言开发的系统中需要处理一个树形结构。</li><li>在一个系统中能够分离出叶子对象和容器对象，而且它们的类型不固定，需要增加一些新的类型。</li></ul><h2 id="源码分析组合模式的典型应用"><a href="#源码分析组合模式的典型应用" class="headerlink" title="源码分析组合模式的典型应用"></a>源码分析组合模式的典型应用</h2><h3 id="java-awt中的组合模式"><a href="#java-awt中的组合模式" class="headerlink" title="java.awt中的组合模式"></a>java.awt中的组合模式</h3><p>Java GUI分两种：</p><ul><li><p>AWT(Abstract Window Toolkit)：抽象窗口工具集，是第一代的Java GUI组件。绘制依赖于底层的操作系统。基本的AWT库处理用户界面元素的方法是把这些元素的创建和行为委托给每个目标平台上（Windows、 Unix、 Macintosh等）的本地GUI工具进行处理。</p></li><li><p>Swing，不依赖于底层细节，是轻量级的组件。现在多是基于Swing来开发。</p></li></ul><p>我们来看一个AWT的简单示例：</p><blockquote><p>注意：为了正常显示中文，需要在IDEA中的 <code>Edit Configurations -&gt; VM Options</code> 中设置参数 <code>-Dfile.encoding=GB18030</code></p></blockquote><pre><code class="java">import java.awt.*;import java.awt.event.WindowAdapter;import java.awt.event.WindowEvent;public class MyFrame extends Frame {    public MyFrame(String title) {        super(title);    }    public static void main(String[] args) {        MyFrame frame = new MyFrame(&quot;这是一个 Frame&quot;);        // 定义三个构件，添加到Frame中去        Button button = new Button(&quot;按钮 A&quot;);        Label label = new Label(&quot;这是一个 AWT Label!&quot;);        TextField textField = new TextField(&quot;这是一个 AWT TextField!&quot;);        frame.add(button, BorderLayout.EAST);        frame.add(label, BorderLayout.SOUTH);        frame.add(textField, BorderLayout.NORTH);        // 定义一个 Panel，在Panel中添加三个构件，然后再把Panel添加到Frame中去        Panel panel = new Panel();        panel.setBackground(Color.pink);        Label lable1 = new Label(&quot;用户名&quot;);        TextField textField1 = new TextField(&quot;请输入用户名：&quot;, 20);        Button button1 = new Button(&quot;确定&quot;);        panel.add(lable1);        panel.add(textField1);        panel.add(button1);        frame.add(panel, BorderLayout.CENTER);        // 设置Frame的属性        frame.setSize(500, 300);        frame.setBackground(Color.orange);        // 设置点击关闭事件        frame.addWindowListener(new WindowAdapter() {            @Override            public void windowClosing(WindowEvent e) {                System.exit(0);            }        });        frame.setVisible(true);    }}</code></pre><p>运行后窗体显示如下</p><p><img src="http://image.laijianfeng.org/20181005_123833.png" alt="示例.AWT绘制窗体"></p><p>我们在Frame容器中添加了三个不同的构件 <code>Button</code>、<code>Label</code>、<code>TextField</code>，还添加了一个 <code>Panel</code> 容器，<code>Panel</code> 容器中又添加了 <code>Button</code>、<code>Label</code>、<code>TextField</code> 三个构件，为什么容器 <code>Frame</code> 和 <code>Panel</code> 可以添加类型不同的构件和容器呢？</p><p>我们先来看下AWT Component的类图</p><p><img src="http://image.laijianfeng.org/20181004_164221.png" alt="AWT Component类图"></p><p>GUI组件根据作用可以分为两种：基本组件和容器组件。</p><ul><li>基本组件又称构件，诸如按钮、文本框之类的图形界面元素。</li><li>容器是一种比较特殊的组件，可以容纳其他组件，容器如窗口、对话框等。所有的容器类都是 <code>java.awt.Container</code> 的直接或间接子类</li></ul><p>容器父类 <code>Container</code> 的部分代码如下</p><pre><code>public class Container extends Component {    /**     * The components in this container.     * @see #add     * @see #getComponents     */    private java.util.List&lt;Component&gt; component = new ArrayList&lt;&gt;();    public Component add(Component comp) {        addImpl(comp, null, -1);        return comp;    }    // 省略...}</code></pre><p>容器父类 <code>Container</code> 内部定义了一个集合用于存储 <code>Component</code> 对象，而容器组件 <code>Container</code> 和 基本组件如 <code>Button</code>、<code>Label</code>、<code>TextField</code> 等都是 <code>Component</code> 的子类，所以可以很清楚的看到这里应用了组合模式</p><p><code>Component</code> 类中封装了组件通用的方法和属性，如图形的组件对象、大小、显示位置、前景色和背景色、边界、可见性等，因此许多组件类也就继承了 <code>Component</code> 类的成员方法和成员变量，相应的成员方法包括：</p><pre><code class="java">　　　getComponentAt(int x, int y)　　　getFont()　　　getForeground()　　　getName()　　　getSize()　　　paint(Graphics g)　　　repaint()　　　update()　　　setVisible(boolean b)　　　setSize(Dimension d)　　　setName(String name)</code></pre><h3 id="Java集合中的组合模式"><a href="#Java集合中的组合模式" class="headerlink" title="Java集合中的组合模式"></a>Java集合中的组合模式</h3><p><code>HashMap</code> 提供 <code>putAll</code> 的方法，可以将另一个 <code>Map</code> 对象放入自己的存储空间中，如果有相同的 key 值则会覆盖之前的 key 值所对应的 value 值</p><pre><code class="java">public class Test {    public static void main(String[] args) {        Map&lt;String, Integer&gt; map1 = new HashMap&lt;String, Integer&gt;();        map1.put(&quot;aa&quot;, 1);        map1.put(&quot;bb&quot;, 2);        map1.put(&quot;cc&quot;, 3);        System.out.println(&quot;map1: &quot; + map1);        Map&lt;String, Integer&gt; map2 = new LinkedMap();        map2.put(&quot;cc&quot;, 4);        map2.put(&quot;dd&quot;, 5);        System.out.println(&quot;map2: &quot; + map2);        map1.putAll(map2);        System.out.println(&quot;map1.putAll(map2): &quot; + map1);    }}</code></pre><p>输出结果</p><pre><code>map1: {aa=1, bb=2, cc=3}map2: {cc=4, dd=5}map1.putAll(map2): {aa=1, bb=2, cc=4, dd=5}</code></pre><p>查看 <code>putAll</code> 源码</p><pre><code>    public void putAll(Map&lt;? extends K, ? extends V&gt; m) {        putMapEntries(m, true);    }</code></pre><p><code>putAll</code> 接收的参数为父类 <code>Map</code> 类型，所以 <code>HashMap</code> 是一个容器类，<code>Map</code> 的子类为叶子类，当然如果 <code>Map</code> 的其他子类也实现了 <code>putAll</code> 方法，那么它们都既是容器类，又都是叶子类</p><p>同理，<code>ArrayList</code> 中的 <code>addAll(Collection&lt;? extends E&gt; c)</code> 方法也是一个组合模式的应用，在此不做探讨</p><h2 id="Mybatis-SqlNode中的组合模式"><a href="#Mybatis-SqlNode中的组合模式" class="headerlink" title="Mybatis SqlNode中的组合模式"></a>Mybatis SqlNode中的组合模式</h2><p>MyBatis 的强大特性之一便是它的动态SQL，其通过 <code>if</code>, <code>choose</code>, <code>when</code>, <code>otherwise</code>, <code>trim</code>, <code>where</code>, <code>set</code>, <code>foreach</code> 标签，可组合成非常灵活的SQL语句，从而提高开发人员的效率。</p><p>来几个官方示例：</p><p>动态SQL – IF</p><pre><code class="sql">&lt;select id=&quot;findActiveBlogLike&quot;  resultType=&quot;Blog&quot;&gt;  SELECT * FROM BLOG WHERE state = ‘ACTIVE’   &lt;if test=&quot;title != null&quot;&gt;    AND title like #{title}  &lt;/if&gt;  &lt;if test=&quot;author != null and author.name != null&quot;&gt;    AND author_name like #{author.name}  &lt;/if&gt;&lt;/select&gt;</code></pre><p>动态SQL – choose, when, otherwise</p><pre><code class="sql">&lt;select id=&quot;findActiveBlogLike&quot;  resultType=&quot;Blog&quot;&gt;  SELECT * FROM BLOG WHERE state = ‘ACTIVE’  &lt;choose&gt;    &lt;when test=&quot;title != null&quot;&gt;      AND title like #{title}    &lt;/when&gt;    &lt;when test=&quot;author != null and author.name != null&quot;&gt;      AND author_name like #{author.name}    &lt;/when&gt;    &lt;otherwise&gt;      AND featured = 1    &lt;/otherwise&gt;  &lt;/choose&gt;&lt;/select&gt;</code></pre><p>动态SQL – where</p><pre><code class="sql">&lt;select id=&quot;findActiveBlogLike&quot;  resultType=&quot;Blog&quot;&gt;  SELECT * FROM BLOG   &lt;where&gt;     &lt;if test=&quot;state != null&quot;&gt;         state = #{state}    &lt;/if&gt;     &lt;if test=&quot;title != null&quot;&gt;        AND title like #{title}    &lt;/if&gt;    &lt;if test=&quot;author != null and author.name != null&quot;&gt;        AND author_name like #{author.name}    &lt;/if&gt;  &lt;/where&gt;&lt;/select&gt;</code></pre><p>动态SQL – foreach</p><pre><code class="sql">&lt;select id=&quot;selectPostIn&quot; resultType=&quot;domain.blog.Post&quot;&gt;  SELECT * FROM POST P WHERE ID in  &lt;foreach item=&quot;item&quot; index=&quot;index&quot; collection=&quot;list&quot;      open=&quot;(&quot; separator=&quot;,&quot; close=&quot;)&quot;&gt;        #{item}  &lt;/foreach&gt;&lt;/select&gt;</code></pre><p>Mybatis在处理动态SQL节点时，应用到了组合设计模式，Mybatis会将映射配置文件中定义的动态SQL节点、文本节点等解析成对应的 SqlNode 实现，并形成树形结构。</p><p><code>SQLNode</code> 的类图如下所示</p><p><img src="http://image.laijianfeng.org/20181005_123835.png" alt="Mybatis SqlNode 类图"></p><p>需要先了解 <code>DynamicContext</code> 类的作用：主要用于记录解析动态SQL语句之后产生的SQL语句片段，可以认为它是一个用于记录动态SQL语句解析结果的容器</p><p>抽象构件为 <code>SqlNode</code> 接口，源码如下</p><pre><code class="java">public interface SqlNode {  boolean apply(DynamicContext context);}</code></pre><p><code>apply</code> 是 <code>SQLNode</code> 接口中定义的唯一方法，该方法会根据用户传入的实参，参数解析该SQLNode所记录的动态SQL节点，并调用 <code>DynamicContext.appendSql()</code> 方法将解析后的SQL片段追加到 <code>DynamicContext.sqlBuilder</code> 中保存，当SQL节点下所有的 <code>SqlNode</code> 完成解析后，我们就可以从 <code>DynamicContext</code> 中获取一条动态生产的、完整的SQL语句</p><p>然后来看 <code>MixedSqlNode</code> 类的源码</p><pre><code>public class MixedSqlNode implements SqlNode {  private List&lt;SqlNode&gt; contents;  public MixedSqlNode(List&lt;SqlNode&gt; contents) {    this.contents = contents;  }  @Override  public boolean apply(DynamicContext context) {    for (SqlNode sqlNode : contents) {      sqlNode.apply(context);    }    return true;  }}</code></pre><p><code>MixedSqlNode</code> 维护了一个 <code>List&lt;SqlNode&gt;</code> 类型的列表，用于存储 <code>SqlNode</code> 对象，<code>apply</code> 方法通过 <code>for循环</code> 遍历 contents 并调用其中对象的 <code>apply</code> 方法，这里跟我们的示例中的 <code>Folder</code> 类中的 <code>print</code> 方法非常类似，很明显 <code>MixedSqlNode</code> 扮演了容器构件角色</p><p>对于其他SqlNode子类的功能，稍微概括如下：</p><ul><li><code>TextSqlNode</code>：表示包含 <code>${}</code> 占位符的动态SQL节点，其 apply 方法会使用 <code>GenericTokenParser</code> 解析 <code>${}</code> 占位符，并直接替换成用户给定的实际参数值</li><li><code>IfSqlNode</code>：对应的是动态SQL节点 <code>&lt;If&gt;</code> 节点，其 apply 方法首先通过 <code>ExpressionEvaluator.evaluateBoolean()</code> 方法检测其 test 表达式是否为 true，然后根据 test 表达式的结果，决定是否执行其子节点的 apply() 方法</li><li><code>TrimSqlNode</code> ：会根据子节点的解析结果，添加或删除相应的前缀或后缀。</li><li><code>WhereSqlNode</code> 和 <code>SetSqlNode</code> 都继承了 <code>TrimSqlNode</code></li><li><code>ForeachSqlNode</code>：对应 <code>&lt;foreach&gt;</code> 标签，对集合进行迭代</li><li>动态SQL中的 <code>&lt;choose&gt;</code>、<code>&lt;when&gt;</code>、<code>&lt;otherwise&gt;</code> 分别解析成 <code>ChooseSqlNode</code>、<code>IfSqlNode</code>、<code>MixedSqlNode</code></li></ul><p>综上，<code>SqlNode</code> 接口有多个实现类，每个实现类对应一个动态SQL节点，其中 <code>SqlNode</code> 扮演抽象构件角色，<code>MixedSqlNode</code> 扮演容器构件角色，其它一般是叶子构件角色</p><blockquote><p>参考：<br>刘伟：设计模式Java版<br>慕课网java设计模式精讲 Debug 方式+内存分析<br><a href="https://www.cnblogs.com/mengdd/archive/2013/02/06/2906959.html" target="_blank" rel="noopener">Java AWT基础及布局管理</a><br><a href="https://segmentfault.com/a/1190000009324403" target="_blank" rel="noopener">【java源码一带一路系列】之HashMap.putAll()</a><br>徐郡明：Mybatis技术内幕 3.2 SqlNode&amp;SqlSource<br><a href="http://www.mybatis.org/mybatis-3/zh/dynamic-sql.html" target="_blank" rel="noopener">Mybatis 3.4.7 文档：动态 SQL</a>   </p></blockquote><h3 id="推荐阅读"><a href="#推荐阅读" class="headerlink" title="推荐阅读"></a>推荐阅读</h3><p><a href="https://mp.weixin.qq.com/s?__biz=MzI1NDU0MTE1NA==&amp;mid=2247483700&amp;idx=1&amp;sn=dd4d23f9400c8be248f5d125465ba941&amp;chksm=e9c2ed39deb5642fb809eca1351f00995f06c9a4875f09986cc5005059eff74d6c20fc1118a3&amp;scene=0#rd" target="_blank" rel="noopener">设计模式 | 简单工厂模式及典型应用</a><br><a href="https://mp.weixin.qq.com/s?__biz=MzI1NDU0MTE1NA==&amp;mid=2247483704&amp;idx=1&amp;sn=fa3ae947cebf22da35e6ac0a37f566f8&amp;chksm=e9c2ed35deb564230a69e43d93a3b74618287c6ddd402a6f1dc6a5b14a896e99584985e7cf92&amp;scene=0#rd" target="_blank" rel="noopener">设计模式 | 工厂方法模式及典型应用</a><br><a href="https://mp.weixin.qq.com/s?__biz=MzI1NDU0MTE1NA==&amp;mid=2247483708&amp;idx=1&amp;sn=9b8c155b86511ea6ec323dc6a72c52df&amp;chksm=e9c2ed31deb56427b2a6bbcbad5bdd3a4ef68b52eb88cc47b5bcfc76773d3d983d8aaf57761c&amp;scene=0#rd" target="_blank" rel="noopener">设计模式 | 抽象工厂模式及典型应用</a><br><a href="https://mp.weixin.qq.com/s?__biz=MzI1NDU0MTE1NA==&amp;mid=2247483712&amp;idx=1&amp;sn=1ffd9837eb9413dde74ff509bf69ecc5&amp;chksm=e9c2ed4ddeb5645b8cbf64c83d103a859ae49921c60e17fe8bebe63c26b04966be101d598848&amp;scene=0#rd" target="_blank" rel="noopener">设计模式 | 建造者模式及典型应用</a><br><a href="https://mp.weixin.qq.com/s?__biz=MzI1NDU0MTE1NA==&amp;mid=2247483716&amp;idx=1&amp;sn=df00c297c8f32e10e277db8941839c14&amp;chksm=e9c2ed49deb5645fa2586da358a8f0a00dd926f883637adebc59435f846c67c040ef759ba034&amp;scene=0#rd" target="_blank" rel="noopener">设计模式 | 原型模式及典型应用</a><br><a href="https://mp.weixin.qq.com/s?__biz=MzI1NDU0MTE1NA==&amp;mid=2247483721&amp;idx=1&amp;sn=721d0bce3bd516c10d4b6addbf3eced6&amp;chksm=e9c2ed44deb56452395c94a0b150994b94aa26cae71149e6c030d0ac32f9c3c37e2bfe9685b6&amp;scene=0#rd" target="_blank" rel="noopener">设计模式 | 外观模式及典型应用</a><br><a href="https://mp.weixin.qq.com/s?__biz=MzI1NDU0MTE1NA==&amp;mid=2247483726&amp;idx=1&amp;sn=df583e5b297ddaff5e1ab822df762274&amp;chksm=e9c2ed43deb56455d2a099f3c3e8622031027d6da00202e6a7d731eac691e4d87d673ca103b5&amp;scene=0#rd" target="_blank" rel="noopener">设计模式 | 装饰者模式及典型应用</a><br><a href="https://mp.weixin.qq.com/s?__biz=MzI1NDU0MTE1NA==&amp;mid=2247483730&amp;idx=1&amp;sn=859feab7f4632b7ba3d1b5a614d57bbe&amp;chksm=e9c2ed5fdeb56449575995778573fa05a3730ac72792d70fc91e38e2d2f5238899f620481d16&amp;scene=0#rd" target="_blank" rel="noopener">设计模式 | 适配器模式及典型应用</a><br><a href="https://mp.weixin.qq.com/s?__biz=MzI1NDU0MTE1NA==&amp;mid=2247483737&amp;idx=1&amp;sn=ed27a42a80b87ff74f1e1266d918ad5b&amp;chksm=e9c2ed54deb56442aba5c95fbddd4c774eb39ebe7ab8c03471a62e3cf3979e303cef43417bac&amp;scene=0#rd" target="_blank" rel="noopener">设计模式 | 享元模式及典型应用</a>   </p><p><img src="http://image.laijianfeng.org/20180913_001328.png" alt="关注_小旋锋_微信公众号"></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;本文的主要内容：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;介绍组合模式&lt;/li&gt;
&lt;li&gt;示例&lt;/li&gt;
&lt;li&gt;组合模式总结&lt;/li&gt;
&lt;li&gt;源码分析组合模式的典型应用&lt;ul&gt;
&lt;li&gt;java.awt中的组合模式&lt;/li&gt;
&lt;li&gt;Java集合中的组合模式&lt;/li&gt;
&lt;li&gt;Myb
      
    
    </summary>
    
      <category term="后端" scheme="http://laijianfeng.org/categories/%E5%90%8E%E7%AB%AF/"/>
    
    
      <category term="设计模式" scheme="http://laijianfeng.org/tags/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/"/>
    
  </entry>
  
  <entry>
    <title>设计模式 | 享元模式及典型应用</title>
    <link href="http://laijianfeng.org/2018/09/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F-%E4%BA%AB%E5%85%83%E6%A8%A1%E5%BC%8F%E5%8F%8A%E5%85%B8%E5%9E%8B%E5%BA%94%E7%94%A8/"/>
    <id>http://laijianfeng.org/2018/09/设计模式-享元模式及典型应用/</id>
    <published>2018-09-24T17:15:00.000Z</published>
    <updated>2018-09-24T17:24:17.933Z</updated>
    
    <content type="html"><![CDATA[<h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>本文的主要内容：</p><ul><li>介绍享元模式</li><li>示例-云盘</li><li>总结</li><li>源码分析享元模式的典型应用<ul><li>String中的享元模式</li><li>Integer中的享元模式</li><li>Long中的享元模式</li><li>Apache Common Pool2中的享元模式</li></ul></li></ul><h2 id="享元模式"><a href="#享元模式" class="headerlink" title="享元模式"></a>享元模式</h2><p><strong>享元模式(Flyweight Pattern)</strong>：运用共享技术有效地支持大量细粒度对象的复用。系统只使用少量的对象，而这些对象都很相似，状态变化很小，可以实现对象的多次复用。由于享元模式要求能够共享的对象必须是细粒度对象，因此它又称为轻量级模式，它是一种对象结构型模式。享元模式结构较为复杂，一般结合工厂模式一起使用。</p><h3 id="角色"><a href="#角色" class="headerlink" title="角色"></a>角色</h3><p><strong>Flyweight（抽象享元类）</strong>：通常是一个接口或抽象类，在抽象享元类中声明了具体享元类公共的方法，这些方法可以向外界提供享元对象的内部数据（内部状态），同时也可以通过这些方法来设置外部数据（外部状态）。</p><p><strong>ConcreteFlyweight（具体享元类）</strong>：它实现了抽象享元类，其实例称为享元对象；在具体享元类中为内部状态提供了存储空间。通常我们可以结合单例模式来设计具体享元类，为每一个具体享元类提供唯一的享元对象。</p><p><strong>UnsharedConcreteFlyweight（非共享具体享元类）</strong>：并不是所有的抽象享元类的子类都需要被共享，不能被共享的子类可设计为非共享具体享元类；当需要一个非共享具体享元类的对象时可以直接通过实例化创建。</p><p><strong>FlyweightFactory（享元工厂类）</strong>：享元工厂类用于创建并管理享元对象，它针对抽象享元类编程，将各种类型的具体享元对象存储在一个享元池中，享元池一般设计为一个存储“键值对”的集合（也可以是其他类型的集合），可以结合工厂模式进行设计；当用户请求一个具体享元对象时，享元工厂提供一个存储在享元池中已创建的实例或者创建一个新的实例（如果不存在的话），返回新创建的实例并将其存储在享元池中。</p><blockquote><p>单纯享元模式：在单纯享元模式中，所有的具体享元类都是可以共享的，不存在非共享具体享元类。<br>复合享元模式：将一些单纯享元对象使用组合模式加以组合，还可以形成复合享元对象，这样的复合享元对象本身不能共享，但是它们可以分解成单纯享元对象，而后者则可以共享</p></blockquote><p>在享元模式中引入了享元工厂类，享元工厂类的作用在于提供一个用于存储享元对象的享元池，当用户需要对象时，首先从享元池中获取，如果享元池中不存在，则创建一个新的享元对象返回给用户，并在享元池中保存该新增对象。</p><p>典型的享元工厂类的代码如下：</p><pre><code>class FlyweightFactory {    //定义一个HashMap用于存储享元对象，实现享元池    private HashMap flyweights = newHashMap();    public Flyweight getFlyweight(String key){        //如果对象存在，则直接从享元池获取        if(flyweights.containsKey(key)){            return(Flyweight)flyweights.get(key);        }        //如果对象不存在，先创建一个新的对象添加到享元池中，然后返回        else {            Flyweight fw = newConcreteFlyweight();            flyweights.put(key,fw);            return fw;        }    }}</code></pre><p>享元类的设计是享元模式的要点之一，在享元类中要将内部状态和外部状态分开处理，通常将内部状态作为享元类的成员变量，而外部状态通过注入的方式添加到享元类中。</p><p>典型的享元类代码如下所示：</p><pre><code>class Flyweight {    //内部状态intrinsicState作为成员变量，同一个享元对象其内部状态是一致的    private String intrinsicState;    public Flyweight(String intrinsicState) {        this.intrinsicState=intrinsicState;    }    //外部状态extrinsicState在使用时由外部设置，不保存在享元对象中，即使是同一个对象    public void operation(String extrinsicState) {        //......    }}</code></pre><p>享元模式一般的类图如下</p><p><img src="http://image.laijianfeng.org/20180925_002554.png" alt="享元模式类图"></p><h2 id="示例"><a href="#示例" class="headerlink" title="示例"></a>示例</h2><p>一般网盘对于相同的文件只保留一份，譬如有一个场景：当我们上传一部别人上传过的电影，会发现很快就上传完成了，实际上不是真的上传，而是引用别人曾经上传过的那部电影，这样一可以提高我们的用户体验，二可以节约存储空间避免资源浪费</p><blockquote><p>注意：这个场景是小编想的，与一般见到的例子不太一样，小编其实不确定是不是享元模式，请大家多多指教</p></blockquote><p>首先定义一个工具类 HashUtil，计算内容的hash值（注：计算hash是从 <a href="https://www.cnblogs.com/oxgen/p/3962085.html" target="_blank" rel="noopener">https://www.cnblogs.com/oxgen/p/3962085.html</a> 处复制的）</p><pre><code>public class HashUtil {    public static String computeHashId(String key) {        String cacheKey;        try {            final MessageDigest mDigest = MessageDigest.getInstance(&quot;MD5&quot;);            mDigest.update(key.getBytes());            cacheKey = bytesToHexString(mDigest.digest());        } catch (NoSuchAlgorithmException e) {            cacheKey = String.valueOf(key.hashCode());        }        return cacheKey;    }    private static String bytesToHexString(byte[] bytes) {        // http://stackoverflow.com/questions/332079        StringBuilder sb = new StringBuilder();        for (int i = 0; i &lt; bytes.length; i++) {            String hex = Integer.toHexString(0xFF &amp; bytes[i]);            if (hex.length() == 1) {                sb.append(&#39;0&#39;);            }            sb.append(hex);        }        return sb.toString();    }}</code></pre><p>资源类 Resource，相当于享元类的内部状态</p><pre><code>public class Resource {    private String hashId;    private int byteSize;    private String content;    public Resource(String content) {        this.content = content;        this.hashId = HashUtil.computeHashId(content);   // 文件的hash值        this.byteSize = content.length();    }    // ....getter、setter、toString...}</code></pre><p>用户的文件类 File，其中的 resource 为内部状态，owner和filename为外部状态</p><pre><code>public  class File {    protected String owner;    protected String filename;    protected Resource resource;    public File(String owner, String filename) {        this.owner = owner;        this.filename = filename;    }    public String fileMeta() {// 文件存储到文件系统中需要的key        if (this.owner == null || filename == null || resource == null) {            return &quot;未知文件&quot;;        }        return owner + &quot;-&quot; + filename + resource.getHashId();    }    public String display() {        return fileMeta() + &quot;, 资源内容：&quot; + getResource().toString();    }    // ....getter、setter、toString...}</code></pre><p>网盘类 PanServer，该类使用单例模式（在其他例子中该类还使用工厂方法模式），在upload方法中根据所上传的文件的hashId判断是否已经有相同内容的文件存在，存在则引用，不存在才上传该文件</p><pre><code>public class PanServer {    private static PanServer panServer = new PanServer(); // 单例模式    private Map&lt;String, Resource&gt; resourceSystem; // 资源系统，相当于享元池    private Map&lt;String, File&gt; fileSystem;   // 文件系统    public PanServer() {        resourceSystem = new HashMap&lt;String, Resource&gt;();        fileSystem = new HashMap&lt;String, File&gt;();    }    public static PanServer getInstance() {        return panServer;    }    public String upload(String username, LocalFile localFile) {        long startTime = System.currentTimeMillis();        File file = new File(username, localFile.getFilename());        String hashId = HashUtil.computeHashId(localFile.getContent());     // 计算文件hash值        System.out.println(username + &quot; 上传文件&quot;);        try {            if (resourceSystem.containsKey(hashId)) {                System.out.println(String.format(&quot;检测到内容相同的文件《%s》，为了节约空间，重用文件&quot;, localFile.getFilename()));                file.setResource(this.resourceSystem.get(hashId));                Thread.sleep(100);            } else {                System.out.println(String.format(&quot;文件《%s》上传中....&quot;, localFile.getFilename()));                Resource newResource = new Resource(localFile.getContent());                file.setResource(newResource);                this.resourceSystem.put(newResource.getHashId(), newResource); // 将资源对象存储到资源池中                Thread.sleep(3000);     // 上传文件需要耗费一定时间            }        } catch (Exception e) {            e.printStackTrace();        }        fileSystem.put(file.fileMeta(), file);        long endTime = System.currentTimeMillis();        System.out.println(String.format(&quot;文件上传完成，共耗费 %s 毫秒\n&quot;, endTime - startTime));        return file.fileMeta();    }    public void download(String fileKey) {        File file = this.fileSystem.get(fileKey);        if (file == null) {            System.out.println(&quot;文件不存在&quot;);        } else {            System.out.println(&quot;下载文件：&quot; + file.display());        }        // 转为 LocalFile 返回    }}</code></pre><p>客户端和本地文件类</p><pre><code>public class LocalFile {    private String filename;    private String content;    public LocalFile(String filename, String content) {        this.filename = filename;        this.content = content;    }    //...省略...}public class Test {    public static void main(String[] args) {        PanServer panServer = PanServer.getInstance();        String fileContent = &quot;这是一个pdf文件《设计模式：从入门到放弃》&quot;;        LocalFile localFile1 = new LocalFile(&quot;小明的设计模式.pdf&quot;, fileContent);        String fikeKey1 = panServer.upload(&quot;小明&quot;, localFile1);        LocalFile localFile2 = new LocalFile(&quot;大明的设计模式.pdf&quot;, fileContent);        String fikeKey2 = panServer.upload(&quot;大明&quot;, localFile2);        panServer.download(fikeKey1);        panServer.download(fikeKey2);    }}</code></pre><p>输出</p><pre><code>小明 上传文件文件《小明的设计模式.pdf》上传中....文件上传完成，共耗费 3077 毫秒大明 上传文件检测到内容相同的文件《大明的设计模式.pdf》，为了节约空间，重用文件文件上传完成，共耗费 100 毫秒下载文件：小明-小明的设计模式.pdf-f73ea50f00f87b42d1f2e4eb6b71d383, 资源内容：Resource {hashId=&#39;f73ea50f00f87b42d1f2e4eb6b71d383&#39;, byteSize=22, content=&#39;这是一个pdf文件《设计模式：从入门到放弃》&#39;}下载文件：大明-大明的设计模式.pdf-f73ea50f00f87b42d1f2e4eb6b71d383, 资源内容：Resource {hashId=&#39;f73ea50f00f87b42d1f2e4eb6b71d383&#39;, byteSize=22, content=&#39;这是一个pdf文件《设计模式：从入门到放弃》&#39;}</code></pre><p>小明和大明各自上传了一份文件，文件的内容（内部状态）是相同的，但是名称（外部状态）不同，由于内部状态相同没有必要重复存储，所以内部状态之拷贝了一份</p><h2 id="享元模式总结"><a href="#享元模式总结" class="headerlink" title="享元模式总结"></a>享元模式总结</h2><p>享元模式的<strong>主要优点</strong>如下：</p><ul><li>可以极大减少内存中对象的数量，使得相同或相似对象在内存中只保存一份，从而可以节约系统资源，提高系统性能。</li><li>享元模式的外部状态相对独立，而且不会影响其内部状态，从而使得享元对象可以在不同的环境中被共享。</li></ul><p>享元模式的<strong>主要缺点</strong>如下：</p><ul><li>享元模式使得系统变得复杂，需要分离出内部状态和外部状态，这使得程序的逻辑复杂化。</li><li>为了使对象可以共享，享元模式需要将享元对象的部分状态外部化，而读取外部状态将使得运行时间变长。</li></ul><p><strong>适用场景</strong>：</p><ul><li>一个系统有大量相同或者相似的对象，造成内存的大量耗费。</li><li>对象的大部分状态都可以外部化，可以将这些外部状态传入对象中。</li><li>在使用享元模式时需要维护一个存储享元对象的享元池，而这需要耗费一定的系统资源，因此，应当在需要多次重复使用享元对象时才值得使用享元模式。</li></ul><h2 id="源码分析享元模式的典型应用"><a href="#源码分析享元模式的典型应用" class="headerlink" title="源码分析享元模式的典型应用"></a>源码分析享元模式的典型应用</h2><h3 id="String中的享元模式"><a href="#String中的享元模式" class="headerlink" title="String中的享元模式"></a>String中的享元模式</h3><p>Java中将String类定义为final（不可改变的），JVM中字符串一般保存在字符串常量池中，java会确保一个字符串在常量池中只有一个拷贝，这个字符串常量池在JDK6.0以前是位于常量池中，位于永久代，而在JDK7.0中，JVM将其从永久代拿出来放置于堆中。</p><p>我们做一个测试：</p><pre><code>public class Main {    public static void main(String[] args) {        String s1 = &quot;hello&quot;;        String s2 = &quot;hello&quot;;        String s3 = &quot;he&quot; + &quot;llo&quot;;        String s4 = &quot;hel&quot; + new String(&quot;lo&quot;);        String s5 = new String(&quot;hello&quot;);        String s6 = s5.intern();        String s7 = &quot;h&quot;;        String s8 = &quot;ello&quot;;        String s9 = s7 + s8;        System.out.println(s1==s2);//true        System.out.println(s1==s3);//true        System.out.println(s1==s4);//false        System.out.println(s1==s9);//false        System.out.println(s4==s5);//false        System.out.println(s1==s6);//true    }}</code></pre><p>String类的<code>final</code>修饰的，以字面量的形式创建String变量时，jvm会在编译期间就把该字面量<code>hello</code>放到字符串常量池中，由Java程序启动的时候就已经加载到内存中了。这个字符串常量池的特点就是有且只有一份相同的字面量，如果有其它相同的字面量，jvm则返回这个字面量的引用，如果没有相同的字面量，则在字符串常量池创建这个字面量并返回它的引用。</p><p>由于s2指向的字面量<code>hello</code>在常量池中已经存在了（s1先于s2），于是jvm就返回这个字面量绑定的引用，所以<code>s1==s2</code>。</p><p>s3中字面量的拼接其实就是<code>hello</code>，jvm在编译期间就已经对它进行优化，所以s1和s3也是相等的。</p><p>s4中的<code>new String(&quot;lo&quot;)</code>生成了两个对象，<code>lo</code>，<code>new String(&quot;lo&quot;)</code>，<code>lo</code>存在字符串常量池，<code>new String(&quot;lo&quot;)</code>存在堆中，<code>String s4 = &quot;hel&quot; + new String(&quot;lo&quot;)</code>实质上是两个对象的相加，编译器不会进行优化，相加的结果存在堆中，而s1存在字符串常量池中，当然不相等。<code>s1==s9</code>的原理一样。</p><p><code>s4==s5</code>两个相加的结果都在堆中，不用说，肯定不相等。</p><p><code>s1==s6</code>中，<code>s5.intern()</code>方法能使一个位于堆中的字符串在运行期间动态地加入到字符串常量池中（字符串常量池的内容是程序启动的时候就已经加载好了），如果字符串常量池中有该对象对应的字面量，则返回该字面量在字符串常量池中的引用，否则，创建复制一份该字面量到字符串常量池并返回它的引用。因此<code>s1==s6</code>输出true。</p><h3 id="Integer-中的享元模式"><a href="#Integer-中的享元模式" class="headerlink" title="Integer 中的享元模式"></a>Integer 中的享元模式</h3><p>使用例子如下：</p><pre><code class="java">    public static void main(String[] args) {        Integer i1 = 12 ;        Integer i2 = 12 ;        System.out.println(i1 == i2);        Integer b1 = 128 ;        Integer b2 = 128 ;        System.out.println(b1 == b2);    }</code></pre><p>输出是</p><pre><code>truefalse</code></pre><p>为什么第一个是true，第二个是false？<br>反编译后可以发现 <code>Integer b1 = 128;</code> 实际变成了 <code>Integer b1 = Integer.valueOf(128);</code>，所以我们来看 <code>Integer</code> 中的 <code>valueOf</code> 方法的实现</p><pre><code class="java">public final class Integer extends Number implements Comparable&lt;Integer&gt; {    public static Integer valueOf(int var0) {        return var0 &gt;= -128 &amp;&amp; var0 &lt;= Integer.IntegerCache.high ? Integer.IntegerCache.cache[var0 + 128] : new Integer(var0);    }    //...省略...}</code></pre><p>IntegerCache 缓存类</p><pre><code>    //是Integer内部的私有静态类,里面的cache[]就是jdk事先缓存的Integer。    private static class IntegerCache {        static final int low = -128;//区间的最低值        static final int high;//区间的最高值，后面默认赋值为127，也可以用户手动设置虚拟机参数        static final Integer cache[]; //缓存数组        static {            // high value may be configured by property            int h = 127;            //这里可以在运行时设置虚拟机参数来确定h  :-Djava.lang.Integer.IntegerCache.high=250            String integerCacheHighPropValue =                sun.misc.VM.getSavedProperty(&quot;java.lang.Integer.IntegerCache.high&quot;);            if (integerCacheHighPropValue != null) {//用户设置了                int i = parseInt(integerCacheHighPropValue);                i = Math.max(i, 127);//虽然设置了但是还是不能小于127                // 也不能超过最大值                h = Math.min(i, Integer.MAX_VALUE - (-low) -1);            }            high = h;            cache = new Integer[(high - low) + 1];            int j = low;            //循环将区间的数赋值给cache[]数组            for(int k = 0; k &lt; cache.length; k++)                cache[k] = new Integer(j++);        }        private IntegerCache() {}    }</code></pre><p>可以看到 <code>Integer</code> 默认先创建并缓存 <code>-128 ~ 127</code> 之间数的 <code>Integer</code> 对象，当调用 <code>valueOf</code> 时如果参数在 <code>-128 ~ 127</code> 之间则计算下标并从缓存中返回，否则创建一个新的 <code>Integer</code> 对象</p><h3 id="Long中的享元模式"><a href="#Long中的享元模式" class="headerlink" title="Long中的享元模式"></a>Long中的享元模式</h3><pre><code>public final class Long extends Number implements Comparable&lt;Long&gt; {    public static Long valueOf(long var0) {        return var0 &gt;= -128L &amp;&amp; var0 &lt;= 127L ? Long.LongCache.cache[(int)var0 + 128] : new Long(var0);    }       private static class LongCache {        private LongCache(){}        static final Long cache[] = new Long[-(-128) + 127 + 1];        static {            for(int i = 0; i &lt; cache.length; i++)                cache[i] = new Long(i - 128);        }    }    //...}</code></pre><p>同理，<code>Long</code> 中也有缓存，不过不能指定缓存最大值</p><h3 id="Apache-Commons-Pool2中的享元模式"><a href="#Apache-Commons-Pool2中的享元模式" class="headerlink" title="Apache Commons Pool2中的享元模式"></a>Apache Commons Pool2中的享元模式</h3><p>对象池化的基本思路是：将用过的对象保存起来，等下一次需要这种对象的时候，再拿出来重复使用，从而在一定程度上减少频繁创建对象所造成的开销。用于充当保存对象的“容器”的对象，被称为“对象池”（Object Pool，或简称Pool）</p><p>Apache Commons Pool实现了对象池的功能。定义了对象的生成、销毁、激活、钝化等操作及其状态转换，并提供几个默认的对象池实现。</p><p>有几个重要的对象：</p><p><strong>PooledObject（池对象）</strong>：用于封装对象（如：线程、数据库连接、TCP连接），将其包裹成可被池管理的对象。<br><strong>PooledObjectFactory（池对象工厂）</strong>：定义了操作PooledObject实例生命周期的一些方法，PooledObjectFactory必须实现线程安全。<br><strong>Object Pool （对象池）</strong>：Object Pool负责管理PooledObject，如：借出对象，返回对象，校验对象，有多少激活对象，有多少空闲对象。</p><pre><code> // 对象池 private final Map&lt;S, PooledObject&lt;S&gt;&gt; allObjects = new ConcurrentHashMap&lt;S, PooledObject&lt;S&gt;&gt;();</code></pre><p>重要方法：</p><p>borrowObject：从池中借出一个对象。<br>returnObject：将一个对象返还给池。</p><p>由于篇幅较长，后面会专门出一篇介绍并使用 <code>Apache Commons Pool2</code> 的文章，敬请期待</p><blockquote><p>参考：<br>刘伟：设计模式Java版<br>慕课网java设计模式精讲 Debug 方式+内存分析<br><a href="https://www.cnblogs.com/tongkey/p/8587060.html" target="_blank" rel="noopener">Java中String字符串常量池</a><br><a href="https://blog.csdn.net/LuoZheng4698729/article/details/53995925" target="_blank" rel="noopener">Integer的享元模式解析</a><br><a href="https://blog.csdn.net/qq_22075041/article/details/69802378?locationNum=7&amp;fps=1" target="_blank" rel="noopener">7种结构型模式之：享元模式（Flyweight）与数据库连接池的原理</a><br><a href="https://blog.csdn.net/zilong_zilong/article/details/78556281" target="_blank" rel="noopener">Apache commons-pool2-2.4.2源码学习笔记</a><br><a href="https://blog.csdn.net/amon1991/article/details/77110657" target="_blank" rel="noopener">Apache Commons Pool2 源码分析</a> </p></blockquote><h3 id="推荐阅读"><a href="#推荐阅读" class="headerlink" title="推荐阅读"></a>推荐阅读</h3><p><a href="https://mp.weixin.qq.com/s?__biz=MzI1NDU0MTE1NA==&amp;mid=2247483700&amp;idx=1&amp;sn=dd4d23f9400c8be248f5d125465ba941&amp;chksm=e9c2ed39deb5642fb809eca1351f00995f06c9a4875f09986cc5005059eff74d6c20fc1118a3&amp;scene=0#rd" target="_blank" rel="noopener">设计模式 | 简单工厂模式及典型应用</a><br><a href="https://mp.weixin.qq.com/s?__biz=MzI1NDU0MTE1NA==&amp;mid=2247483704&amp;idx=1&amp;sn=fa3ae947cebf22da35e6ac0a37f566f8&amp;chksm=e9c2ed35deb564230a69e43d93a3b74618287c6ddd402a6f1dc6a5b14a896e99584985e7cf92&amp;scene=0#rd" target="_blank" rel="noopener">设计模式 | 工厂方法模式及典型应用</a><br><a href="https://mp.weixin.qq.com/s?__biz=MzI1NDU0MTE1NA==&amp;mid=2247483708&amp;idx=1&amp;sn=9b8c155b86511ea6ec323dc6a72c52df&amp;chksm=e9c2ed31deb56427b2a6bbcbad5bdd3a4ef68b52eb88cc47b5bcfc76773d3d983d8aaf57761c&amp;scene=0#rd" target="_blank" rel="noopener">设计模式 | 抽象工厂模式及典型应用</a><br><a href="https://mp.weixin.qq.com/s?__biz=MzI1NDU0MTE1NA==&amp;mid=2247483712&amp;idx=1&amp;sn=1ffd9837eb9413dde74ff509bf69ecc5&amp;chksm=e9c2ed4ddeb5645b8cbf64c83d103a859ae49921c60e17fe8bebe63c26b04966be101d598848&amp;scene=0#rd" target="_blank" rel="noopener">设计模式 | 建造者模式及典型应用</a><br><a href="https://mp.weixin.qq.com/s?__biz=MzI1NDU0MTE1NA==&amp;mid=2247483716&amp;idx=1&amp;sn=df00c297c8f32e10e277db8941839c14&amp;chksm=e9c2ed49deb5645fa2586da358a8f0a00dd926f883637adebc59435f846c67c040ef759ba034&amp;scene=0#rd" target="_blank" rel="noopener">设计模式 | 原型模式及典型应用</a><br><a href="https://mp.weixin.qq.com/s?__biz=MzI1NDU0MTE1NA==&amp;mid=2247483721&amp;idx=1&amp;sn=721d0bce3bd516c10d4b6addbf3eced6&amp;chksm=e9c2ed44deb56452395c94a0b150994b94aa26cae71149e6c030d0ac32f9c3c37e2bfe9685b6&amp;scene=0#rd" target="_blank" rel="noopener">设计模式 | 外观模式及典型应用</a><br><a href="https://mp.weixin.qq.com/s?__biz=MzI1NDU0MTE1NA==&amp;mid=2247483726&amp;idx=1&amp;sn=df583e5b297ddaff5e1ab822df762274&amp;chksm=e9c2ed43deb56455d2a099f3c3e8622031027d6da00202e6a7d731eac691e4d87d673ca103b5&amp;scene=0#rd" target="_blank" rel="noopener">设计模式 | 装饰者模式及典型应用</a><br><a href="https://mp.weixin.qq.com/s?__biz=MzI1NDU0MTE1NA==&amp;mid=2247483730&amp;idx=1&amp;sn=859feab7f4632b7ba3d1b5a614d57bbe&amp;chksm=e9c2ed5fdeb56449575995778573fa05a3730ac72792d70fc91e38e2d2f5238899f620481d16&amp;scene=0#rd" target="_blank" rel="noopener">设计模式 | 适配器模式及典型应用</a></p><p><img src="http://image.laijianfeng.org/20180913_001328.png" alt="关注_小旋锋_微信公众号"></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;前言&quot;&gt;&lt;a href=&quot;#前言&quot; class=&quot;headerlink&quot; title=&quot;前言&quot;&gt;&lt;/a&gt;前言&lt;/h2&gt;&lt;p&gt;本文的主要内容：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;介绍享元模式&lt;/li&gt;
&lt;li&gt;示例-云盘&lt;/li&gt;
&lt;li&gt;总结&lt;/li&gt;
&lt;li&gt;源码分析享
      
    
    </summary>
    
      <category term="后端" scheme="http://laijianfeng.org/categories/%E5%90%8E%E7%AB%AF/"/>
    
    
      <category term="设计模式" scheme="http://laijianfeng.org/tags/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/"/>
    
  </entry>
  
  <entry>
    <title>设计模式 | 适配器模式及典型应用</title>
    <link href="http://laijianfeng.org/2018/09/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F-%E9%80%82%E9%85%8D%E5%99%A8%E6%A8%A1%E5%BC%8F%E5%8F%8A%E5%85%B8%E5%9E%8B%E5%BA%94%E7%94%A8/"/>
    <id>http://laijianfeng.org/2018/09/设计模式-适配器模式及典型应用/</id>
    <published>2018-09-19T17:00:54.000Z</published>
    <updated>2018-09-19T17:14:18.546Z</updated>
    
    <content type="html"><![CDATA[<h2 id="适配器模式"><a href="#适配器模式" class="headerlink" title="适配器模式"></a>适配器模式</h2><p><strong>适配器模式(Adapter Pattern)</strong>：将一个接口转换成客户希望的另一个接口，使接口不兼容的那些类可以一起工作，其别名为包装器(Wrapper)。适配器模式既可以作为类结构型模式，也可以作为对象结构型模式。</p><p>在适配器模式中，我们通过增加一个新的适配器类来解决接口不兼容的问题，使得原本没有任何关系的类可以协同工作。</p><p>根据适配器类与适配者类的关系不同，适配器模式可分为对象适配器和类适配器两种，在<strong>对象适配器模式</strong>中，适配器与适配者之间是<strong>关联</strong>关系；在<strong>类适配器模式</strong>中，适配器与适配者之间是<strong>继承</strong>（或实现）关系。</p><h3 id="角色"><a href="#角色" class="headerlink" title="角色"></a>角色</h3><p><strong>Target（目标抽象类）</strong>：目标抽象类定义客户所需接口，可以是一个抽象类或接口，也可以是具体类。</p><p><strong>Adapter（适配器类）</strong>：适配器可以调用另一个接口，作为一个转换器，对Adaptee和Target进行适配，适配器类是适配器模式的核心，在对象适配器中，它通过继承Target并关联一个Adaptee对象使二者产生联系。</p><p><strong>Adaptee（适配者类）</strong>：适配者即被适配的角色，它定义了一个已经存在的接口，这个接口需要适配，适配者类一般是一个具体类，包含了客户希望使用的业务方法，在某些情况下可能没有适配者类的源代码。</p><blockquote><p>缺省适配器模式(Default Adapter Pattern)：当不需要实现一个接口所提供的所有方法时，可先设计一个抽象类实现该接口，并为接口中每个方法提供一个默认实现（空方法），那么该抽象类的子类可以选择性地覆盖父类的某些方法来实现需求，它适用于不想使用一个接口中的所有方法的情况，又称为单接口适配器模式。缺省适配器模式是适配器模式的一种变体，其应用也较为广泛。在JDK类库的事件处理包java.awt.event中广泛使用了缺省适配器模式，如WindowAdapter、KeyAdapter、MouseAdapter等。</p></blockquote><h2 id="示例"><a href="#示例" class="headerlink" title="示例"></a>示例</h2><h3 id="类适配器"><a href="#类适配器" class="headerlink" title="类适配器"></a>类适配器</h3><p>首先有一个已存在的将被适配的类</p><pre><code>public class Adaptee {    public void adapteeRequest() {        System.out.println(&quot;被适配者的方法&quot;);    }}</code></pre><p>定义一个目标接口</p><pre><code>public interface Target {    void request();}</code></pre><p>怎么才可以在目标接口中的 <code>request()</code> 调用 <code>Adaptee</code> 的 <code>adapteeRequest()</code> 方法呢？</p><p>如果直接实现 <code>Target</code> 是不行的</p><pre><code>public class ConcreteTarget implements Target {    @Override    public void request() {        System.out.println(&quot;concreteTarget目标方法&quot;);    }}</code></pre><p>如果通过一个适配器类，实现 <code>Target</code> 接口，同时继承了 <code>Adaptee</code> 类，然后在实现的 <code>request()</code> 方法中调用父类的 <code>adapteeRequest()</code> 即可实现</p><pre><code>public class Adapter extends Adaptee implements Target{    @Override    public void request() {        //...一些操作...        super.adapteeRequest();        //...一些操作...    }}</code></pre><p>我们来测试一下</p><pre><code>public class Test {    public static void main(String[] args) {        Target target = new ConcreteTarget();        target.request();        Target adapterTarget = new Adapter();        adapterTarget.request();    }}</code></pre><p>输出</p><pre><code>concreteTarget目标方法被适配者的方法</code></pre><p><img src="http://image.laijianfeng.org/Package%20classadapter.png" alt="类适配器模式类图"></p><p>这样我们即可在新接口 <code>Target</code> 中适配旧的接口或类</p><h3 id="对象适配器"><a href="#对象适配器" class="headerlink" title="对象适配器"></a>对象适配器</h3><p>对象适配器与类适配器不同之处在于，类适配器通过继承来完成适配，对象适配器则是通过关联来完成，这里稍微修改一下 <code>Adapter</code> 类即可将转变为对象适配器</p><pre><code>public class Adapter implements Target{    // 适配者是对象适配器的一个属性    private Adaptee adaptee = new Adaptee();    @Override    public void request() {        //...        adaptee.adapteeRequest();        //...    }}</code></pre><p><img src="http://image.laijianfeng.org/20180919Package_objectadapter.png" alt="对象适配器模式类图"></p><p>注意这里的 <code>Adapter</code> 是将 <code>Adaptee</code> 作为一个成员属性，而不是继承它</p><h3 id="电压适配器"><a href="#电压适配器" class="headerlink" title="电压适配器"></a>电压适配器</h3><p>再来一个好理解的例子，我们国家的民用电都是 220V，日本是 110V，而我们的手机充电一般需要 5V，这时候要充电，就需要一个电压适配器，将 220V 或者 100V 的输入电压变换为 5V 输出</p><p>定义输出交流电接口，输出220V交流电类和输出110V交流电类</p><pre><code>public interface AC {    int outputAC();}public class AC110 implements AC {    public final int output = 110;    @Override    public int outputAC() {        return output;    }}public class AC220 implements AC {    public final int output = 220;    @Override    public int outputAC() {        return output;    }}</code></pre><p>适配器接口，其中 <code>support()</code> 方法用于检查输入的电压是否与适配器匹配，<code>outputDC5V()</code> 方法则用于将输入的电压变换为 5V 后输出 </p><pre><code>public interface DC5Adapter {    boolean support(AC ac);    int outputDC5V(AC ac);}</code></pre><p>实现中国变压适配器和日本变压适配器</p><pre><code>public class ChinaPowerAdapter implements DC5Adapter {    public static final int voltage = 220;    @Override    public boolean support(AC ac) {        return (voltage == ac.outputAC());    }    @Override    public int outputDC5V(AC ac) {        int adapterInput = ac.outputAC();        //变压器...        int adapterOutput = adapterInput / 44;        System.out.println(&quot;使用ChinaPowerAdapter变压适配器，输入AC:&quot; + adapterInput + &quot;V&quot; + &quot;，输出DC:&quot; + adapterOutput + &quot;V&quot;);        return adapterOutput;    }}public class JapanPowerAdapter implements DC5Adapter {    public static final int voltage = 110;    @Override    public boolean support(AC ac) {        return (voltage == ac.outputAC());    }    @Override    public int outputDC5V(AC ac) {        int adapterInput = ac.outputAC();        //变压器...        int adapterOutput = adapterInput / 22;        System.out.println(&quot;使用JapanPowerAdapter变压适配器，输入AC:&quot; + adapterInput + &quot;V&quot; + &quot;，输出DC:&quot; + adapterOutput + &quot;V&quot;);        return adapterOutput;    }}</code></pre><p>测试，准备中国变压适配器和日本变压适配器各一个，定义一个方法可以根据电压找到合适的变压器，然后进行测试</p><pre><code>public class Test {    private List&lt;DC5Adapter&gt; adapters = new LinkedList&lt;DC5Adapter&gt;();    public Test() {        this.adapters.add(new ChinaPowerAdapter());        this.adapters.add(new JapanPowerAdapter());    }    // 根据电压找合适的变压器    public DC5Adapter getPowerAdapter(AC ac) {        DC5Adapter adapter = null;        for (DC5Adapter ad : this.adapters) {            if (ad.support(ac)) {                adapter = ad;                break;            }        }        if (adapter == null){            throw new  IllegalArgumentException(&quot;没有找到合适的变压适配器&quot;);        }        return adapter;    }    public static void main(String[] args) {        Test test = new Test();        AC chinaAC = new AC220();        DC5Adapter adapter = test.getPowerAdapter(chinaAC);        adapter.outputDC5V(chinaAC);        // 去日本旅游，电压是 110V        AC japanAC = new AC110();        adapter = test.getPowerAdapter(japanAC);        adapter.outputDC5V(japanAC);    }}</code></pre><p>输出</p><pre><code>使用ChinaPowerAdapter变压适配器，输入AC:220V，输出DC:5V使用JapanPowerAdapter变压适配器，输入AC:110V，输出DC:5V</code></pre><h2 id="适配器模式总结"><a href="#适配器模式总结" class="headerlink" title="适配器模式总结"></a>适配器模式总结</h2><p><strong>主要优点</strong>：</p><ol><li>将目标类和适配者类解耦，通过引入一个适配器类来重用现有的适配者类，无须修改原有结构。</li><li>增加了类的透明性和复用性，将具体的业务实现过程封装在适配者类中，对于客户端类而言是透明的，而且提高了适配者的复用性，同一个适配者类可以在多个不同的系统中复用。</li><li>灵活性和扩展性都非常好，通过使用配置文件，可以很方便地更换适配器，也可以在不修改原有代码的基础上增加新的适配器类，完全符合“开闭原则”。</li></ol><p>具体来说，类适配器模式还有如下优点：</p><ul><li>由于适配器类是适配者类的子类，因此可以在适配器类中置换一些适配者的方法，使得适配器的灵活性更强。</li></ul><p>对象适配器模式还有如下优点：</p><ul><li>一个对象适配器可以把多个不同的适配者适配到同一个目标；</li><li>可以适配一个适配者的子类，由于适配器和适配者之间是关联关系，根据“里氏代换原则”，适配者的子类也可通过该适配器进行适配。</li></ul><p>类适配器模式的缺点如下：</p><ol><li>对于Java、C#等不支持多重类继承的语言，一次最多只能适配一个适配者类，不能同时适配多个适配者；</li><li>适配者类不能为最终类，如在Java中不能为final类，C#中不能为sealed类；</li><li>在Java、C#等语言中，类适配器模式中的目标抽象类只能为接口，不能为类，其使用有一定的局限性。</li></ol><p>对象适配器模式的缺点如下：</p><p>与类适配器模式相比，要在适配器中置换适配者类的某些方法比较麻烦。如果一定要置换掉适配者类的一个或多个方法，可以先做一个适配者类的子类，将适配者类的方法置换掉，然后再把适配者类的子类当做真正的适配者进行适配，实现过程较为复杂。</p><p><strong>适用场景</strong>：</p><ul><li>系统需要使用一些现有的类，而这些类的接口（如方法名）不符合系统的需要，甚至没有这些类的源代码。</li><li>想创建一个可以重复使用的类，用于与一些彼此之间没有太大关联的一些类，包括一些可能在将来引进的类一起工作。</li></ul><h2 id="源码分析适配器模式的典型应用"><a href="#源码分析适配器模式的典型应用" class="headerlink" title="源码分析适配器模式的典型应用"></a>源码分析适配器模式的典型应用</h2><h3 id="spring-AOP中的适配器模式"><a href="#spring-AOP中的适配器模式" class="headerlink" title="spring AOP中的适配器模式"></a>spring AOP中的适配器模式</h3><p>在Spring的Aop中，使用的 <code>Advice（通知）</code> 来增强被代理类的功能。<code>Advice</code>的类型有：<code>MethodBeforeAdvice</code>、<code>AfterReturningAdvice</code>、<code>ThrowsAdvice</code> ，在每个类型 <code>Advice</code> 都有对应的拦截器，<code>MethodBeforeAdviceInterceptor</code>、<code>AfterReturningAdviceInterceptor</code>、<code>ThrowsAdviceInterceptor</code>。Spring需要将每个 <code>Advice</code> <strong>都封装成对应的拦截器类型</strong>，返回给容器，所以需要使用适配器模式对 <code>Advice</code> 进行转换。</p><p>三个适配者类 Adaptee 如下：</p><pre><code>public interface MethodBeforeAdvice extends BeforeAdvice {    void before(Method var1, Object[] var2, @Nullable Object var3) throws Throwable;}public interface AfterReturningAdvice extends AfterAdvice {    void afterReturning(@Nullable Object var1, Method var2, Object[] var3, @Nullable Object var4) throws Throwable;}public interface ThrowsAdvice extends AfterAdvice {}</code></pre><p>目标接口 Target，有两个方法，一个判断 <code>Advice</code> 类型是否匹配，一个是工厂方法，创建对应类型的 <code>Advice</code> 对应的拦截器</p><pre><code>public interface AdvisorAdapter {    boolean supportsAdvice(Advice var1);    MethodInterceptor getInterceptor(Advisor var1);}</code></pre><p>三个适配器类 Adapter 分别如下，注意其中的 Advice、Adapter、Interceptor之间的对应关系</p><pre><code>class MethodBeforeAdviceAdapter implements AdvisorAdapter, Serializable {    @Override    public boolean supportsAdvice(Advice advice) {        return (advice instanceof MethodBeforeAdvice);    }    @Override    public MethodInterceptor getInterceptor(Advisor advisor) {        MethodBeforeAdvice advice = (MethodBeforeAdvice) advisor.getAdvice();        return new MethodBeforeAdviceInterceptor(advice);    }}@SuppressWarnings(&quot;serial&quot;)class AfterReturningAdviceAdapter implements AdvisorAdapter, Serializable {    @Override    public boolean supportsAdvice(Advice advice) {        return (advice instanceof AfterReturningAdvice);    }    @Override    public MethodInterceptor getInterceptor(Advisor advisor) {        AfterReturningAdvice advice = (AfterReturningAdvice) advisor.getAdvice();        return new AfterReturningAdviceInterceptor(advice);    }}class ThrowsAdviceAdapter implements AdvisorAdapter, Serializable {    @Override    public boolean supportsAdvice(Advice advice) {        return (advice instanceof ThrowsAdvice);    }    @Override    public MethodInterceptor getInterceptor(Advisor advisor) {        return new ThrowsAdviceInterceptor(advisor.getAdvice());    }}</code></pre><p>客户端 DefaultAdvisorAdapterRegistry</p><pre><code>public class DefaultAdvisorAdapterRegistry implements AdvisorAdapterRegistry, Serializable {    private final List&lt;AdvisorAdapter&gt; adapters = new ArrayList(3);    public DefaultAdvisorAdapterRegistry() {        // 这里注册了适配器        this.registerAdvisorAdapter(new MethodBeforeAdviceAdapter());        this.registerAdvisorAdapter(new AfterReturningAdviceAdapter());        this.registerAdvisorAdapter(new ThrowsAdviceAdapter());    }    public MethodInterceptor[] getInterceptors(Advisor advisor) throws UnknownAdviceTypeException {        List&lt;MethodInterceptor&gt; interceptors = new ArrayList(3);        Advice advice = advisor.getAdvice();        if (advice instanceof MethodInterceptor) {            interceptors.add((MethodInterceptor)advice);        }        Iterator var4 = this.adapters.iterator();        while(var4.hasNext()) {            AdvisorAdapter adapter = (AdvisorAdapter)var4.next();            if (adapter.supportsAdvice(advice)) {   // 这里调用适配器方法                interceptors.add(adapter.getInterceptor(advisor));  // 这里调用适配器方法            }        }        if (interceptors.isEmpty()) {            throw new UnknownAdviceTypeException(advisor.getAdvice());        } else {            return (MethodInterceptor[])interceptors.toArray(new MethodInterceptor[0]);        }    }    // ...省略...}    </code></pre><p>这里看 while 循环里，逐个取出注册的适配器，调用 <code>supportsAdvice()</code> 方法来判断 <code>Advice</code> 对应的类型，然后调用 <code>getInterceptor()</code> 创建对应类型的拦截器</p><p><img src="http://image.laijianfeng.org/20180919_2217.jpg" alt="spring aop 适配器模式"></p><p>这里应该属于对象适配器模式，关键字 <code>instanceof</code> 可看成是 <code>Advice</code> 的方法，不过这里的 <code>Advice</code> 对象是从外部传进来，而不是成员属性</p><h3 id="spring-JPA中的适配器模式"><a href="#spring-JPA中的适配器模式" class="headerlink" title="spring JPA中的适配器模式"></a>spring JPA中的适配器模式</h3><p>在Spring的ORM包中，对于JPA的支持也是采用了适配器模式，首先定义了一个接口的 <code>JpaVendorAdapter</code>，然后不同的持久层框架都实现此接口。</p><p>jpaVendorAdapter：用于设置实现厂商JPA实现的特定属性，如设置Hibernate的是否自动生成DDL的属性generateDdl；这些属性是厂商特定的，因此最好在这里设置；目前Spring提供 <code>HibernateJpaVendorAdapter</code>、<code>OpenJpaVendorAdapter</code>、<code>EclipseLinkJpaVendorAdapter</code>、<code>TopLinkJpaVendorAdapter</code> 四个实现。其中最重要的属性是 database，用来指定使用的数据库类型，从而能<strong>根据数据库类型来决定比如如何将数据库特定异常转换为Spring的一致性异常</strong>，目前支持如下数据库（DB2、DERBY、H2、HSQL、INFORMIX、MYSQL、ORACLE、POSTGRESQL、SQL_SERVER、SYBASE）</p><pre><code>public interface JpaVendorAdapter{  // 返回一个具体的持久层提供者  public abstract PersistenceProvider getPersistenceProvider();  // 返回持久层提供者的包名  public abstract String getPersistenceProviderRootPackage();  // 返回持久层提供者的属性  public abstract Map&lt;String, ?&gt; getJpaPropertyMap();  // 返回JpaDialect  public abstract JpaDialect getJpaDialect();  // 返回持久层管理器工厂  public abstract Class&lt;? extends EntityManagerFactory&gt; getEntityManagerFactoryInterface();  // 返回持久层管理器  public abstract Class&lt;? extends EntityManager&gt; getEntityManagerInterface();  // 自定义回调方法  public abstract void postProcessEntityManagerFactory(EntityManagerFactory paramEntityManagerFactory);}</code></pre><p>我们来看其中一个适配器实现类 HibernateJpaVendorAdapter</p><pre><code>public class HibernateJpaVendorAdapter extends AbstractJpaVendorAdapter {    //设定持久层提供者    private final PersistenceProvider persistenceProvider;    //设定持久层方言    private final JpaDialect jpaDialect;    public HibernateJpaVendorAdapter() {        this.persistenceProvider = new HibernatePersistence();        this.jpaDialect = new HibernateJpaDialect();    }    //返回持久层方言    public PersistenceProvider getPersistenceProvider() {        return this.persistenceProvider;    }    //返回持久层提供者    public String getPersistenceProviderRootPackage() {        return &quot;org.hibernate&quot;;    }    //返回JPA的属性    public Map&lt;String, Object&gt; getJpaPropertyMap() {        Map jpaProperties = new HashMap();        if (getDatabasePlatform() != null) {            jpaProperties.put(&quot;hibernate.dialect&quot;, getDatabasePlatform());        } else if (getDatabase() != null) {            Class databaseDialectClass = determineDatabaseDialectClass(getDatabase());            if (databaseDialectClass != null) {                jpaProperties.put(&quot;hibernate.dialect&quot;,                        databaseDialectClass.getName());            }        }        if (isGenerateDdl()) {            jpaProperties.put(&quot;hibernate.hbm2ddl.auto&quot;, &quot;update&quot;);        }        if (isShowSql()) {            jpaProperties.put(&quot;hibernate.show_sql&quot;, &quot;true&quot;);        }        return jpaProperties;    }    //设定数据库    protected Class determineDatabaseDialectClass(Database database)         {                                                                                               switch (1.$SwitchMap$org$springframework$orm$jpa$vendor$Database[database.ordinal()])         {                                                                                             case 1:                                                                                       return DB2Dialect.class;                                                                    case 2:                                                                                         return DerbyDialect.class;                                                                  case 3:                                                                                         return H2Dialect.class;                                                                     case 4:                                                                                         return HSQLDialect.class;                                                                   case 5:                                                                                         return InformixDialect.class;                                                               case 6:                                                                                         return MySQLDialect.class;                                                                  case 7:                                                                                         return Oracle9iDialect.class;                                                               case 8:                                                                                         return PostgreSQLDialect.class;                                                             case 9:                                                                                         return SQLServerDialect.class;                                                              case 10:                                                                                        return SybaseDialect.class; }                                                               return null;                  }    //返回JPA方言    public JpaDialect getJpaDialect() {        return this.jpaDialect;    }    //返回JPA实体管理器工厂    public Class&lt;? extends EntityManagerFactory&gt; getEntityManagerFactoryInterface() {        return HibernateEntityManagerFactory.class;    }    //返回JPA实体管理器    public Class&lt;? extends EntityManager&gt; getEntityManagerInterface() {        return HibernateEntityManager.class;    }}</code></pre><p>配置文件中可以这样指定</p><pre><code>&lt;bean id=&quot;jpaVendorAdapter&quot; class=&quot;org.springframework.orm.jpa.vendor.HibernateJpaVendorAdapter&quot;&gt;    &lt;property name=&quot;generateDdl&quot; value=&quot;false&quot; /&gt;     &lt;property name=&quot;database&quot; value=&quot;HSQL&quot;/&gt;  &lt;/bean&gt;  &lt;bean id=&quot;jpaDialect&quot; class=&quot;org.springframework.orm.jpa.vendor.HibernateJpaDialect&quot;/&gt;  </code></pre><h3 id="spring-MVC中的适配器模式"><a href="#spring-MVC中的适配器模式" class="headerlink" title="spring MVC中的适配器模式"></a>spring MVC中的适配器模式</h3><p>Spring MVC中的适配器模式主要用于执行目标 <code>Controller</code> 中的请求处理方法。</p><p>在Spring MVC中，<code>DispatcherServlet</code> 作为用户，<code>HandlerAdapter</code> 作为期望接口，具体的适配器实现类用于对目标类进行适配，<code>Controller</code> 作为需要适配的类。</p><p>为什么要在 Spring MVC 中使用适配器模式？Spring MVC 中的 <code>Controller</code> 种类众多，不同类型的 <code>Controller</code> 通过不同的方法来对请求进行处理。如果不利用适配器模式的话，<code>DispatcherServlet</code> 直接获取对应类型的 <code>Controller</code>，需要的自行来判断，像下面这段代码一样：</p><pre><code>if(mappedHandler.getHandler() instanceof MultiActionController){     ((MultiActionController)mappedHandler.getHandler()).xxx  }else if(mappedHandler.getHandler() instanceof XXX){      ...  }else if(...){     ...  }  </code></pre><p>这样假设如果我们增加一个 <code>HardController</code>,就要在代码中加入一行 <code>if(mappedHandler.getHandler() instanceof HardController)</code>，这种形式就使得程序难以维护，也违反了设计模式中的开闭原则 – 对扩展开放，对修改关闭。</p><p>我们来看看源码，首先是适配器接口 <code>HandlerAdapter</code></p><pre><code>public interface HandlerAdapter {    boolean supports(Object var1);    ModelAndView handle(HttpServletRequest var1, HttpServletResponse var2, Object var3) throws Exception;    long getLastModified(HttpServletRequest var1, Object var2);}</code></pre><p>现该接口的适配器每一个 <code>Controller</code> 都有一个适配器与之对应，这样的话，每自定义一个 <code>Controller</code> 需要定义一个实现 <code>HandlerAdapter</code> 的适配器。</p><p>springmvc 中提供的 <code>Controller</code> 实现类有如下</p><p><img src="http://image.laijianfeng.org/20180919_233327.png" alt="spring mvc Controller 提供的实现类"></p><p>springmvc 中提供的 <code>HandlerAdapter</code> 实现类如下</p><p><img src="http://image.laijianfeng.org/20180919_234325.png" alt="spring mvc HandlerAdapter 提供的实现类"></p><p><code>HttpRequestHandlerAdapter</code> 这个适配器代码如下</p><pre><code>public class HttpRequestHandlerAdapter implements HandlerAdapter {    public HttpRequestHandlerAdapter() {    }    public boolean supports(Object handler) {        return handler instanceof HttpRequestHandler;    }    public ModelAndView handle(HttpServletRequest request, HttpServletResponse response, Object handler) throws Exception {        ((HttpRequestHandler)handler).handleRequest(request, response);        return null;    }    public long getLastModified(HttpServletRequest request, Object handler) {        return handler instanceof LastModified ? ((LastModified)handler).getLastModified(request) : -1L;    }}</code></pre><p>当Spring容器启动后，会将所有定义好的适配器对象存放在一个List集合中，当一个请求来临时，<code>DispatcherServlet</code> 会通过 <code>handler</code> 的类型找到对应适配器，并将该适配器对象返回给用户，然后就可以统一通过适配器的 <code>hanle()</code> 方法来调用 <code>Controller</code> 中的用于处理请求的方法。</p><pre><code>public class DispatcherServlet extends FrameworkServlet {    private List&lt;HandlerAdapter&gt; handlerAdapters;    //初始化handlerAdapters    private void initHandlerAdapters(ApplicationContext context) {        //..省略...    }    // 遍历所有的 HandlerAdapters，通过 supports 判断找到匹配的适配器    protected HandlerAdapter getHandlerAdapter(Object handler) throws ServletException {        for (HandlerAdapter ha : this.handlerAdapters) {            if (logger.isTraceEnabled()) {                logger.trace(&quot;Testing handler adapter [&quot; + ha + &quot;]&quot;);            }            if (ha.supports(handler)) {                return ha;            }        }    }    // 分发请求，请求需要找到匹配的适配器来处理    protected void doDispatch(HttpServletRequest request, HttpServletResponse response) throws Exception {        HttpServletRequest processedRequest = request;        HandlerExecutionChain mappedHandler = null;        // Determine handler for the current request.        mappedHandler = getHandler(processedRequest);        // 确定当前请求的匹配的适配器.        HandlerAdapter ha = getHandlerAdapter(mappedHandler.getHandler());        ha.getLastModified(request, mappedHandler.getHandler());        mv = ha.handle(processedRequest, response, mappedHandler.getHandler());    }    // ...省略...}    </code></pre><p>通过适配器模式我们将所有的 <code>controller</code> 统一交给 <code>HandlerAdapter</code> 处理，免去了写大量的 <code>if-else</code> 语句对 <code>Controller</code> 进行判断，也更利于扩展新的 <code>Controller</code> 类型。</p><blockquote><p>参考：<br>刘伟：设计模式Java版<br>慕课网java设计模式精讲 Debug 方式+内存分析<br>孤落:<a href="https://blog.csdn.net/lu__peng/article/details/79117894" target="_blank" rel="noopener">Spring MVC中的适配器模式</a><br>ToughMind_：<a href="https://blog.csdn.net/liuquan0071/article/details/50506121" target="_blank" rel="noopener">深入浅出设计模式（五）：7.适配器模式</a>   </p></blockquote><h3 id="推荐阅读"><a href="#推荐阅读" class="headerlink" title="推荐阅读"></a>推荐阅读</h3><p><a href="https://mp.weixin.qq.com/s?__biz=MzI1NDU0MTE1NA==&amp;mid=2247483700&amp;idx=1&amp;sn=dd4d23f9400c8be248f5d125465ba941&amp;chksm=e9c2ed39deb5642fb809eca1351f00995f06c9a4875f09986cc5005059eff74d6c20fc1118a3&amp;scene=0#rd" target="_blank" rel="noopener">设计模式 | 简单工厂模式及典型应用</a><br><a href="https://mp.weixin.qq.com/s?__biz=MzI1NDU0MTE1NA==&amp;mid=2247483704&amp;idx=1&amp;sn=fa3ae947cebf22da35e6ac0a37f566f8&amp;chksm=e9c2ed35deb564230a69e43d93a3b74618287c6ddd402a6f1dc6a5b14a896e99584985e7cf92&amp;scene=0#rd" target="_blank" rel="noopener">设计模式 | 工厂方法模式及典型应用</a><br><a href="https://mp.weixin.qq.com/s?__biz=MzI1NDU0MTE1NA==&amp;mid=2247483708&amp;idx=1&amp;sn=9b8c155b86511ea6ec323dc6a72c52df&amp;chksm=e9c2ed31deb56427b2a6bbcbad5bdd3a4ef68b52eb88cc47b5bcfc76773d3d983d8aaf57761c&amp;scene=0#rd" target="_blank" rel="noopener">设计模式 | 抽象工厂模式及典型应用</a><br><a href="https://mp.weixin.qq.com/s?__biz=MzI1NDU0MTE1NA==&amp;mid=2247483712&amp;idx=1&amp;sn=1ffd9837eb9413dde74ff509bf69ecc5&amp;chksm=e9c2ed4ddeb5645b8cbf64c83d103a859ae49921c60e17fe8bebe63c26b04966be101d598848&amp;scene=0#rd" target="_blank" rel="noopener">设计模式 | 建造者模式及典型应用</a><br><a href="https://mp.weixin.qq.com/s?__biz=MzI1NDU0MTE1NA==&amp;mid=2247483716&amp;idx=1&amp;sn=df00c297c8f32e10e277db8941839c14&amp;chksm=e9c2ed49deb5645fa2586da358a8f0a00dd926f883637adebc59435f846c67c040ef759ba034&amp;scene=0#rd" target="_blank" rel="noopener">设计模式 | 原型模式及典型应用</a><br><a href="https://mp.weixin.qq.com/s?__biz=MzI1NDU0MTE1NA==&amp;mid=2247483721&amp;idx=1&amp;sn=721d0bce3bd516c10d4b6addbf3eced6&amp;chksm=e9c2ed44deb56452395c94a0b150994b94aa26cae71149e6c030d0ac32f9c3c37e2bfe9685b6&amp;scene=0#rd" target="_blank" rel="noopener">设计模式 | 外观模式及典型应用</a><br><a href="https://mp.weixin.qq.com/s?__biz=MzI1NDU0MTE1NA==&amp;mid=2247483726&amp;idx=1&amp;sn=df583e5b297ddaff5e1ab822df762274&amp;chksm=e9c2ed43deb56455d2a099f3c3e8622031027d6da00202e6a7d731eac691e4d87d673ca103b5&amp;scene=0#rd" target="_blank" rel="noopener">设计模式 | 装饰者模式及典型应用</a>  </p><p><img src="http://image.laijianfeng.org/20180913_001328.png" alt="关注_小旋锋_微信公众号"></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;适配器模式&quot;&gt;&lt;a href=&quot;#适配器模式&quot; class=&quot;headerlink&quot; title=&quot;适配器模式&quot;&gt;&lt;/a&gt;适配器模式&lt;/h2&gt;&lt;p&gt;&lt;strong&gt;适配器模式(Adapter Pattern)&lt;/strong&gt;：将一个接口转换成客户希望的另一个接口
      
    
    </summary>
    
      <category term="后端" scheme="http://laijianfeng.org/categories/%E5%90%8E%E7%AB%AF/"/>
    
    
      <category term="设计模式" scheme="http://laijianfeng.org/tags/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/"/>
    
  </entry>
  
  <entry>
    <title>设计模式 | 装饰者模式及典型应用</title>
    <link href="http://laijianfeng.org/2018/09/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F-%E8%A3%85%E9%A5%B0%E8%80%85%E6%A8%A1%E5%BC%8F%E5%8F%8A%E5%85%B8%E5%9E%8B%E5%BA%94%E7%94%A8/"/>
    <id>http://laijianfeng.org/2018/09/设计模式-装饰者模式及典型应用/</id>
    <published>2018-09-18T12:44:31.000Z</published>
    <updated>2018-09-18T13:31:51.211Z</updated>
    
    <content type="html"><![CDATA[<h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>本文的主要内容：</p><ul><li>介绍装饰者模式</li><li>示例</li><li>源码分析装饰者模式的典型应用<ul><li>Java I/O 中的装饰者模式</li><li>spring session 中的装饰者模式</li><li>Mybatis 缓存中的装饰者模式</li></ul></li><li>总结</li></ul><h2 id="装饰者模式"><a href="#装饰者模式" class="headerlink" title="装饰者模式"></a>装饰者模式</h2><p><strong>装饰者模式(Decorator Pattern)</strong>：动态地给一个对象增加一些额外的职责，增加对象功能来说，装饰模式比生成子类实现更为灵活。装饰模式是一种对象结构型模式。</p><p>在装饰者模式中，为了让系统具有更好的灵活性和可扩展性，我们通常会定义一个抽象装饰类，而将具体的装饰类作为它的子类</p><h3 id="角色"><a href="#角色" class="headerlink" title="角色"></a>角色</h3><p><strong>Component（抽象构件）</strong>：它是具体构件和抽象装饰类的共同父类，声明了在具体构件中实现的业务方法，它的引入可以使客户端以一致的方式处理未被装饰的对象以及装饰之后的对象，实现客户端的透明操作。</p><p><strong>ConcreteComponent（具体构件）</strong>：它是抽象构件类的子类，用于定义具体的构件对象，实现了在抽象构件中声明的方法，装饰器可以给它增加额外的职责（方法）。</p><p><strong>Decorator（抽象装饰类）</strong>：它也是抽象构件类的子类，用于给具体构件增加职责，但是具体职责在其子类中实现。它维护一个指向抽象构件对象的引用，通过该引用可以调用装饰之前构件对象的方法，并通过其子类扩展该方法，以达到装饰的目的。</p><p><strong>ConcreteDecorator（具体装饰类）</strong>：它是抽象装饰类的子类，负责向构件添加新的职责。每一个具体装饰类都定义了一些新的行为，它可以调用在抽象装饰类中定义的方法，并可以增加新的方法用以扩充对象的行为。</p><p>由于具体构件类和装饰类都实现了相同的抽象构件接口，因此装饰模式以对客户透明的方式动态地给一个对象附加上更多的责任，换言之，客户端并不会觉得对象在装饰前和装饰后有什么不同。装饰模式可以在不需要创造更多子类的情况下，将对象的功能加以扩展。</p><p>装饰模式的<strong>核心在于抽象装饰类的设计</strong>。</p><h2 id="示例"><a href="#示例" class="headerlink" title="示例"></a>示例</h2><p>煎饼抽象类</p><pre><code>public abstract class ABattercake {    protected abstract String getDesc();    protected abstract int cost();}</code></pre><p>煎饼类，继承了煎饼抽象类，一个煎饼 8 块钱</p><pre><code>public class Battercake extends ABattercake {    @Override    protected String getDesc() {        return &quot;煎饼&quot;;    }    @Override    protected int cost() {        return 8;    }}</code></pre><p>抽象装饰类，需要注意的是，<strong>抽象装饰类通过成员属性的方式将 煎饼抽象类组合进来，同时也继承了煎饼抽象类</strong>，且这里定义了新的业务方法 <code>doSomething()</code></p><pre><code>public abstract class AbstractDecorator extends ABattercake {    private ABattercake aBattercake;    public AbstractDecorator(ABattercake aBattercake) {        this.aBattercake = aBattercake;    }    protected abstract void doSomething();    @Override    protected String getDesc() {        return this.aBattercake.getDesc();    }    @Override    protected int cost() {        return this.aBattercake.cost();    }}</code></pre><p>鸡蛋装饰器，继承了抽象装饰类，鸡蛋装饰器在父类的基础上增加了一个鸡蛋，同时价格加上 1 块钱</p><pre><code>public class EggDecorator extends AbstractDecorator {    public EggDecorator(ABattercake aBattercake) {        super(aBattercake);    }    @Override    protected void doSomething() {    }    @Override    protected String getDesc() {        return super.getDesc() + &quot; 加一个鸡蛋&quot;;    }    @Override    protected int cost() {        return super.cost() + 1;    }    public void egg() {        System.out.println(&quot;增加了一个鸡蛋&quot;);    }}</code></pre><p>香肠装饰器，与鸡蛋装饰器类似，继承了抽象装饰类，给在父类的基础上加上一根香肠，同时价格增加 2 块钱</p><pre><code>public class SausageDecorator extends AbstractDecorator{    public SausageDecorator(ABattercake aBattercake) {        super(aBattercake);    }    @Override    protected void doSomething() {    }    @Override    protected String getDesc() {        return super.getDesc() + &quot; 加一根香肠&quot;;    }    @Override    protected int cost() {        return super.cost() + 2;    }}</code></pre><h3 id="测试，购买煎饼"><a href="#测试，购买煎饼" class="headerlink" title="测试，购买煎饼"></a>测试，购买煎饼</h3><p><strong>1、购买一个煎饼</strong></p><pre><code>public class Test {    public static void main(String[] args) {        ABattercake aBattercake = new Battercake();        System.out.println(aBattercake.getDesc() + &quot;, 销售价格: &quot; + aBattercake.cost());    }}</code></pre><p>输出</p><pre><code>煎饼, 销售价格: 8</code></pre><p><strong>2、购买一个加鸡蛋的煎饼</strong></p><pre><code>public class Test {    public static void main(String[] args) {        ABattercake aBattercake = new Battercake();        aBattercake = new EggDecorator(aBattercake);        System.out.println(aBattercake.getDesc() + &quot;, 销售价格: &quot; + aBattercake.cost());    }}</code></pre><p>输出</p><pre><code>煎饼 加一个鸡蛋, 销售价格: 9</code></pre><p><strong>3、购买一个加两个鸡蛋的煎饼</strong></p><pre><code>public class Test {    public static void main(String[] args) {        ABattercake aBattercake = new Battercake();        aBattercake = new EggDecorator(aBattercake);        aBattercake = new EggDecorator(aBattercake);        System.out.println(aBattercake.getDesc() + &quot;, 销售价格: &quot; + aBattercake.cost());    }}</code></pre><p>输出</p><pre><code>煎饼 加一个鸡蛋 加一个鸡蛋, 销售价格: 10</code></pre><p><strong>4、购买一个加两个鸡蛋和一根香肠的煎饼</strong></p><pre><code>public class Test {    public static void main(String[] args) {        ABattercake aBattercake = new Battercake();        aBattercake = new EggDecorator(aBattercake);        aBattercake = new EggDecorator(aBattercake);        aBattercake = new SausageDecorator(aBattercake);        System.out.println(aBattercake.getDesc() + &quot;, 销售价格: &quot; + aBattercake.cost());    }}</code></pre><p>输出</p><pre><code>煎饼 加一个鸡蛋 加一个鸡蛋 加一根香肠, 销售价格: 12</code></pre><p>画出UML类图如下所示</p><p><img src="http://image.laijianfeng.org/20180917_225232.png" alt="装饰者模式类图"></p><h3 id="小结一下"><a href="#小结一下" class="headerlink" title="小结一下"></a>小结一下</h3><p>由于具体构件类和装饰类都实现了相同的抽象构件接口，因此装饰模式以对客户透明的方式动态地给一个对象附加上更多的责任，换言之，客户端并不会觉得对象在装饰前和装饰后有什么不同。</p><p>譬如我们给煎饼加上一个鸡蛋可以这么写 <code>aBattercake = new EggDecorator(aBattercake);</code>，客户端仍然可以把 <code>aBattercake</code> 当成原来的 <code>aBattercake</code>一样，不过现在的 <code>aBattercake</code>已经被装饰加上了鸡蛋</p><p>装饰模式可以在不需要创造更多子类的情况下，将对象的功能加以扩展。</p><h3 id="透明装饰模式与半透明装饰模式"><a href="#透明装饰模式与半透明装饰模式" class="headerlink" title="透明装饰模式与半透明装饰模式"></a>透明装饰模式与半透明装饰模式</h3><p>在上面的示例中，装饰后的对象是通过抽象构建类类型 <code>ABattercake</code> 的变量来引用的，在鸡蛋装饰器这个类中我们新增了 <code>egg()</code> 方法，如果此时我们想要<strong>单独调用该方法</strong>是调用不到的</p><p>除非引用变量的类型改为 <code>EggDecorator</code>，这样就可以调用了</p><pre><code>EggDecorator eggBattercake = new EggDecorator(aBattercake); eggBattercake.egg();</code></pre><p>在实际使用过程中，由于新增行为可能需要单独调用，因此这种形式的装饰模式也经常出现，这种装饰模式被称为<strong>半透明(Semi-transparent)装饰模式</strong>，而标准的装饰模式是<strong>透明(Transparent)装饰模式</strong>。</p><p><strong>(1) 透明装饰模式</strong></p><p>在透明装饰模式中，要求客户端完全针对抽象编程，装饰模式的透明性要求客户端程序不应该将对象声明为具体构件类型或具体装饰类型，而应该全部声明为抽象构件类型。</p><p><strong>(2) 半透明装饰模式</strong></p><p>透明装饰模式的设计难度较大，而且有时我们需要单独调用新增的业务方法。为了能够调用到新增方法，我们不得不用具体装饰类型来定义装饰之后的对象，而具体构件类型还是可以使用抽象构件类型来定义，这种装饰模式即为半透明装饰模式。</p><p>半透明装饰模式可以给系统带来更多的灵活性，设计相对简单，使用起来也非常方便；但是其最大的缺点在于<strong>不能实现对同一个对象的多次装饰</strong>，而且客户端需要有区别地对待装饰之前的对象和装饰之后的对象。</p><h3 id="装饰模式注意事项"><a href="#装饰模式注意事项" class="headerlink" title="装饰模式注意事项"></a>装饰模式注意事项</h3><p>(1) 尽量保持装饰类的接口与被装饰类的接口相同，这样，对于客户端而言，无论是装饰之前的对象还是装饰之后的对象都可以一致对待。这也就是说，在可能的情况下，我们应该尽量使用透明装饰模式。</p><p>(2) 尽量保持具体构件类是一个“轻”类，也就是说不要把太多的行为放在具体构件类中，我们可以通过装饰类对其进行扩展。</p><p>(3) 如果只有一个具体构件类，那么抽象装饰类可以作为该具体构件类的直接子类。</p><h2 id="源码分析装饰者模式的典型应用"><a href="#源码分析装饰者模式的典型应用" class="headerlink" title="源码分析装饰者模式的典型应用"></a>源码分析装饰者模式的典型应用</h2><h3 id="Java-I-O中的装饰者模式"><a href="#Java-I-O中的装饰者模式" class="headerlink" title="Java I/O中的装饰者模式"></a>Java I/O中的装饰者模式</h3><p>使用 Java I/O 的时候总是有各种输入流、输出流、字符流、字节流、过滤流、缓冲流等等各种各样的流，不熟悉里边的设计模式的话总会看得云里雾里的，现在通过设计模式的角度来看 Java I/O，会好理解很多。</p><p>先用一幅图来看看Java I/O到底是什么，下面的这幅图生动的刻画了Java I/O的作用。</p><p><img src="http://image.laijianfeng.org/java-io-flow.png" alt="Java I/O的作用图"></p><p>由上图可知在Java中应用程序通过输入流（InputStream）的Read方法从源地址处读取字节，然后通过输出流（OutputStream）的Write方法将流写入到目的地址。</p><p>流的来源主要有三种：本地的文件（File）、控制台、通过socket实现的网络通信 </p><p>下面的图可以看出Java中的装饰者类和被装饰者类以及它们之间的关系，这里只列出了InputStream中的关系：</p><p><img src="http://image.laijianfeng.org/20180918InputStream.png" alt="InputStream部分类关系"></p><p>由上图可以看出只要继承了FilterInputStream的类就是装饰者类，可以用于包装其他的流，装饰者类还可以对装饰者和类进行再包装。</p><p><strong>这里总结几种常用流的应用场景</strong>：</p><table><thead><tr><th>流名称</th><th>应用场景</th></tr></thead><tbody><tr><td>ByteArrayInputStream</td><td>访问数组，把内存中的一个缓冲区作为 InputStream 使用，CPU从缓存区读取数据比从存储介质的速率快10倍以上</td></tr><tr><td>StringBufferInputStream</td><td>把一个 String 对象作为。InputStream。不建议使用，在转换字符的问题上有缺陷</td></tr><tr><td>FileInputStream</td><td>访问文件，把一个文件作为 InputStream ，实现对文件的读取操作</td></tr><tr><td>PipedInputStream</td><td>访问管道，主要在线程中使用，一个线程通过管道输出流发送数据，而另一个线程通过管道输入流读取数据，这样可实现两个线程间的通讯</td></tr><tr><td>SequenceInputStream</td><td>把多个 InputStream 合并为一个 InputStream . “序列输入流”类允许应用程序把几个输入流连续地合并起来</td></tr><tr><td>DataInputStream</td><td>特殊流，读各种基本类型数据,如byte、int、String的功能</td></tr><tr><td>ObjectInputStream</td><td>对象流，读对象的功能</td></tr><tr><td>PushBackInputStream</td><td>推回输入流，可以把读取进来的某些数据重新回退到输入流的缓冲区之中</td></tr><tr><td>BufferedInputStream</td><td>缓冲流，增加了缓冲功能</td></tr></tbody></table><p><strong>下面看一下Java中包装流的实例</strong>：</p><pre><code>import java.io.BufferedInputStream;import java.io.DataInputStream;import java.io.FileInputStream;import java.io.IOException;public class StreamDemo {    public static void main(String[] args) throws IOException{        DataInputStream in=new DataInputStream(new BufferedInputStream(new  FileInputStream(&quot;D:\\hello.txt&quot;)));        while(in.available()!=0) {            System.out.print((char)in.readByte());        }        in.close();    }}</code></pre><p>输出结果</p><pre><code>hello world!hello Java I/O!</code></pre><p>上面程序中对流进行了两次包装，先用 BufferedInputStream将FileInputStream包装成缓冲流也就是给FileInputStream增加缓冲功能，再DataInputStream进一步包装方便数据处理。</p><p>如果要<strong>实现一个自己的包装流</strong>，根据上面的类图，需要继承抽象装饰类 FilterInputStream</p><p>譬如来实现这样一个操作的装饰者类：将输入流中的所有小写字母变成大写字母</p><pre><code>import java.io.FileInputStream;import java.io.FilterInputStream;import java.io.IOException;import java.io.InputStream;public class UpperCaseInputStream extends FilterInputStream {    protected UpperCaseInputStream(InputStream in) {        super(in);    }    @Override    public int read() throws IOException {        int c = super.read();        return (c == -1 ? c : Character.toUpperCase(c));    }    @Override    public int read(byte[] b, int off, int len) throws IOException {        int result = super.read(b, off, len);        for (int i = off; i &lt; off + result; i++) {            b[i] = (byte) Character.toUpperCase((char) b[i]);        }        return result;    }    public static void main(String[] args) throws IOException {        int c;        InputStream in = new UpperCaseInputStream(new FileInputStream(&quot;D:\\hello.txt&quot;));        try {            while ((c = in.read()) &gt;= 0) {                System.out.print((char) c);            }        } finally {            in.close();        }    }}</code></pre><p>输出</p><pre><code>HELLO WORLD!HELLO JAVA I/O!</code></pre><p>整个Java IO体系都是基于字符流(InputStream/OutputStream) 和 字节流(Reader/Writer)作为基类，下面画出OutputStream、Reader、Writer的部分类图，更多细节请查看其它资料</p><p><img src="http://image.laijianfeng.org/20180918OutputStream.png" alt="OutputStream类图"></p><p><img src="http://image.laijianfeng.org/20180918Reader.png" alt="Reader类图"></p><p><img src="http://image.laijianfeng.org/20180918Writer.png" alt="Writer类图"></p><h3 id="spring-cache-中的装饰者模式"><a href="#spring-cache-中的装饰者模式" class="headerlink" title="spring cache 中的装饰者模式"></a>spring cache 中的装饰者模式</h3><p>看 <code>org.springframework.cache.transaction</code> 包下的 <code>TransactionAwareCacheDecorator</code> 这个类</p><pre><code>public class TransactionAwareCacheDecorator implements Cache {    private final Cache targetCache;    public TransactionAwareCacheDecorator(Cache targetCache) {        Assert.notNull(targetCache, &quot;Target Cache must not be null&quot;);        this.targetCache = targetCache;    }    public &lt;T&gt; T get(Object key, Class&lt;T&gt; type) {        return this.targetCache.get(key, type);    }    public void put(final Object key, final Object value) {        // 判断是否开启了事务        if (TransactionSynchronizationManager.isSynchronizationActive()) {            // 将操作注册到 afterCommit 阶段            TransactionSynchronizationManager.registerSynchronization(new TransactionSynchronizationAdapter() {                public void afterCommit() {                    TransactionAwareCacheDecorator.this.targetCache.put(key, value);                }            });        } else {            this.targetCache.put(key, value);        }    }    // ...省略...}</code></pre><p>该类实现了 <code>Cache</code> 接口，同时将 <code>Cache</code> 组合到类中成为了成员属性 <code>targetCache</code>，所以可以大胆猜测 <code>TransactionAwareCacheDecorator</code> 是一个装饰类，不过这里并没有抽象装饰类，且 <code>TransactionAwareCacheDecorator</code> 没有子类，这里的装饰类关系并没有Java I/O 中的装饰关系那么复杂</p><p><img src="http://image.laijianfeng.org/20180918Cache.png" alt="spring cache中类图关系"></p><p>该类的主要功能：通过 Spring 的 <code>TransactionSynchronizationManager</code> 将其 <code>put/evict/clear</code> 操作与 Spring 管理的事务同步，仅在成功的事务的 <code>after-commit</code> 阶段执行实际的缓存 <code>put/evict/clear</code> 操作。如果没有事务是 <code>active</code> 的，将立即执行 <code>put/evict/clear</code> 操作</p><h3 id="spring-session-中的装饰者模式"><a href="#spring-session-中的装饰者模式" class="headerlink" title="spring session 中的装饰者模式"></a>spring session 中的装饰者模式</h3><blockquote><p>注意：适配器模式的结尾也可能是 Wrapper</p></blockquote><p>类 <code>ServletRequestWrapper</code> 的代码如下：</p><pre><code>public class ServletRequestWrapper implements ServletRequest {    private ServletRequest request;    public ServletRequestWrapper(ServletRequest request) {        if (request == null) {            throw new IllegalArgumentException(&quot;Request cannot be null&quot;);        }        this.request = request;    }    @Override    public Object getAttribute(String name) {        return this.request.getAttribute(name);    }    //...省略...}    </code></pre><p>可以看到该类对 <code>ServletRequest</code> 进行了包装，这里是一个装饰者模式，再看下图，spring session 中 <code>SessionRepositoryFilter</code> 的一个内部类 <code>SessionRepositoryRequestWrapper</code> 与 <code>ServletRequestWrapper</code> 的关系</p><p><img src="http://image.laijianfeng.org/20180918HttpServletRequestWrapper.png" alt="ServletRequest类图"></p><p>可见 <code>ServletRequestWrapper</code> 是第一层包装，<code>HttpServletRequestWrapper</code> 通过继承进行包装，增加了 HTTP 相关的功能，<code>SessionRepositoryRequestWrapper</code> 又通过继承进行包装，增加了 Session 相关的功能</p><h3 id="Mybatis-缓存中的装饰者模式"><a href="#Mybatis-缓存中的装饰者模式" class="headerlink" title="Mybatis 缓存中的装饰者模式"></a>Mybatis 缓存中的装饰者模式</h3><p><code>org.apache.ibatis.cache</code> 包的文件结构如下所示</p><p><img src="http://image.laijianfeng.org/20180918_202157.png" alt="Mybatis cache 中的装饰者模式"></p><p>我们通过类所在的包名即可判断出该类的角色，<code>Cache</code> 为抽象构件类，<code>PerpetualCache</code> 为具体构件类，<code>decorators</code> 包下的类为装饰类，没有抽象装饰类</p><p>通过名称也可以判断出装饰类所要装饰的功能</p><h2 id="装饰者模式总结"><a href="#装饰者模式总结" class="headerlink" title="装饰者模式总结"></a>装饰者模式总结</h2><p>装饰模式的<strong>主要优点</strong>如下：</p><ol><li>对于扩展一个对象的功能，装饰模式比继承更加灵活性，不会导致类的个数急剧增加。</li><li>可以通过一种动态的方式来扩展一个对象的功能，通过配置文件可以在运行时选择不同的具体装饰类，从而实现不同的行为。</li><li>可以对一个对象进行多次装饰，通过使用不同的具体装饰类以及这些装饰类的排列组合，可以创造出很多不同行为的组合，得到功能更为强大的对象。</li><li>具体构件类与具体装饰类可以独立变化，用户可以根据需要增加新的具体构件类和具体装饰类，原有类库代码无须改变，符合 “开闭原则”。</li></ol><p>装饰模式的<strong>主要缺点</strong>如下：</p><ol><li>使用装饰模式进行系统设计时将产生很多小对象，这些对象的区别在于它们之间相互连接的方式有所不同，而不是它们的类或者属性值有所不同，大量小对象的产生势必会占用更多的系统资源，在一定程序上影响程序的性能。</li><li>装饰模式提供了一种比继承更加灵活机动的解决方案，但同时也意味着比继承更加易于出错，排错也很困难，对于多次装饰的对象，调试时寻找错误可能需要逐级排查，较为繁琐。</li></ol><p><strong>适用场景</strong>：</p><ol><li>在不影响其他对象的情况下，以动态、透明的方式给单个对象添加职责。</li><li>当不能采用继承的方式对系统进行扩展或者采用继承不利于系统扩展和维护时可以使用装饰模式。不能采用继承的情况主要有两类：第一类是系统中存在大量独立的扩展，为支持每一种扩展或者扩展之间的组合将产生大量的子类，使得子类数目呈爆炸性增长；第二类是因为类已定义为不能被继承（如Java语言中的final类）。</li></ol><blockquote><p>参考：<br>刘伟：设计模式Java版<br>慕课网java设计模式精讲 Debug 方式+内存分析<br><a href="https://blog.csdn.net/u013309870/article/details/75735676" target="_blank" rel="noopener">HankingHu：由装饰者模式来深入理解Java I/O整体框架</a><br><a href="https://blog.csdn.net/qq_33394088/article/details/78512407" target="_blank" rel="noopener">HryReal：Java的io类的使用场景</a></p></blockquote><h3 id="推荐阅读"><a href="#推荐阅读" class="headerlink" title="推荐阅读"></a>推荐阅读</h3><p><a href="https://mp.weixin.qq.com/s?__biz=MzI1NDU0MTE1NA==&amp;mid=2247483700&amp;idx=1&amp;sn=dd4d23f9400c8be248f5d125465ba941&amp;chksm=e9c2ed39deb5642fb809eca1351f00995f06c9a4875f09986cc5005059eff74d6c20fc1118a3&amp;scene=0#rd" target="_blank" rel="noopener">设计模式 | 简单工厂模式及典型应用</a><br><a href="https://mp.weixin.qq.com/s?__biz=MzI1NDU0MTE1NA==&amp;mid=2247483704&amp;idx=1&amp;sn=fa3ae947cebf22da35e6ac0a37f566f8&amp;chksm=e9c2ed35deb564230a69e43d93a3b74618287c6ddd402a6f1dc6a5b14a896e99584985e7cf92&amp;scene=0#rd" target="_blank" rel="noopener">设计模式 | 工厂方法模式及典型应用</a><br><a href="https://mp.weixin.qq.com/s?__biz=MzI1NDU0MTE1NA==&amp;mid=2247483708&amp;idx=1&amp;sn=9b8c155b86511ea6ec323dc6a72c52df&amp;chksm=e9c2ed31deb56427b2a6bbcbad5bdd3a4ef68b52eb88cc47b5bcfc76773d3d983d8aaf57761c&amp;scene=0#rd" target="_blank" rel="noopener">设计模式 | 抽象工厂模式及典型应用</a><br><a href="https://mp.weixin.qq.com/s?__biz=MzI1NDU0MTE1NA==&amp;mid=2247483712&amp;idx=1&amp;sn=1ffd9837eb9413dde74ff509bf69ecc5&amp;chksm=e9c2ed4ddeb5645b8cbf64c83d103a859ae49921c60e17fe8bebe63c26b04966be101d598848&amp;scene=0#rd" target="_blank" rel="noopener">设计模式 | 建造者模式及典型应用</a><br><a href="https://mp.weixin.qq.com/s?__biz=MzI1NDU0MTE1NA==&amp;mid=2247483716&amp;idx=1&amp;sn=df00c297c8f32e10e277db8941839c14&amp;chksm=e9c2ed49deb5645fa2586da358a8f0a00dd926f883637adebc59435f846c67c040ef759ba034&amp;scene=0#rd" target="_blank" rel="noopener">设计模式 | 原型模式及典型应用</a><br><a href="https://mp.weixin.qq.com/s?__biz=MzI1NDU0MTE1NA==&amp;mid=2247483721&amp;idx=1&amp;sn=721d0bce3bd516c10d4b6addbf3eced6&amp;chksm=e9c2ed44deb56452395c94a0b150994b94aa26cae71149e6c030d0ac32f9c3c37e2bfe9685b6&amp;scene=0#rd" target="_blank" rel="noopener">设计模式 | 外观模式及典型应用</a></p><p><img src="http://image.laijianfeng.org/20180913_001328.png" alt="关注_小旋锋_微信公众号"></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;前言&quot;&gt;&lt;a href=&quot;#前言&quot; class=&quot;headerlink&quot; title=&quot;前言&quot;&gt;&lt;/a&gt;前言&lt;/h2&gt;&lt;p&gt;本文的主要内容：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;介绍装饰者模式&lt;/li&gt;
&lt;li&gt;示例&lt;/li&gt;
&lt;li&gt;源码分析装饰者模式的典型应用&lt;ul&gt;

      
    
    </summary>
    
      <category term="后端" scheme="http://laijianfeng.org/categories/%E5%90%8E%E7%AB%AF/"/>
    
    
      <category term="设计模式" scheme="http://laijianfeng.org/tags/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/"/>
    
  </entry>
  
  <entry>
    <title>设计模式 | 外观模式及典型应用</title>
    <link href="http://laijianfeng.org/2018/09/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F-%E5%A4%96%E8%A7%82%E6%A8%A1%E5%BC%8F%E5%8F%8A%E5%85%B8%E5%9E%8B%E5%BA%94%E7%94%A8/"/>
    <id>http://laijianfeng.org/2018/09/设计模式-外观模式及典型应用/</id>
    <published>2018-09-16T12:29:56.000Z</published>
    <updated>2018-09-16T12:34:52.883Z</updated>
    
    <content type="html"><![CDATA[<h3 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h3><p>本文的主要内容：</p><ul><li>介绍外观模式</li><li>示例<ul><li>自己泡茶</li><li>到茶馆喝茶</li></ul></li><li>外观模式总结</li><li>外观模式的典型应用<ul><li>spring JDBC 中的外观模式</li><li>Mybatis中的外观模式</li><li>Tomcat 中的外观模式</li><li>SLF4J 中的外观模式</li></ul></li></ul><h3 id="外观模式"><a href="#外观模式" class="headerlink" title="外观模式"></a>外观模式</h3><p>外观模式是一种使用频率非常高的结构型设计模式，它通过引入一个外观角色来简化客户端与子系统之间的交互，为复杂的子系统调用提供一个统一的入口，降低子系统与客户端的耦合度，且客户端调用非常方便。</p><p>外观模式又称为门面模式，它是一种对象结构型模式。外观模式是迪米特法则的一种具体实现，通过引入一个新的外观角色可以降低原有系统的复杂度，同时降低客户类与子系统的耦合度。</p><p>外观模式包含如下两个角色：</p><p><strong>Facade（外观角色）</strong>：在客户端可以调用它的方法，在外观角色中可以知道相关的（一个或者多个）子系统的功能和责任；在正常情况下，它将所有从客户端发来的请求委派到相应的子系统去，传递给相应的子系统对象处理。</p><p><strong>SubSystem（子系统角色）</strong>：在软件系统中可以有一个或者多个子系统角色，每一个子系统可以不是一个单独的类，而是一个类的集合，它实现子系统的功能；每一个子系统都可以被客户端直接调用，或者被外观角色调用，它处理由外观类传过来的请求；子系统并不知道外观的存在，对于子系统而言，外观角色仅仅是另外一个客户端而已。</p><p>外观模式的目的不是给予子系统添加新的功能接口，而是为了让外部减少与子系统内多个模块的交互，松散耦合，从而让外部能够更简单地使用子系统。</p><p>外观模式的本质是：<strong>封装交互，简化调用</strong>。</p><h3 id="示例"><a href="#示例" class="headerlink" title="示例"></a>示例</h3><p>泡茶需要水 <code>Water</code></p><pre><code>public class Water {    private int temperature;    // 温度    private int capacity;       // 容量    public Water() {        this.temperature = 0;        this.capacity = 10;    }    // 省略...}    </code></pre><p>泡茶需要茶叶 <code>TeaLeaf</code></p><pre><code>public class TeaLeaf {    private String teaName;    // 省略...}    </code></pre><p>烧水需要用水壶烧，将水加热</p><pre><code>public class KettleService {    public void waterBurning(String who, Water water, int burnTime) {        // 烧水，计算最终温度        int finalTermperature = Math.min(100, water.getTemperature() + burnTime * 20);        water.setTemperature(finalTermperature);        System.out.println(who + &quot; 使用水壶烧水，最终水温为 &quot; + finalTermperature);    }}</code></pre><p>泡茶，将烧好的水与茶叶进行冲泡，最终得到一杯茶水</p><pre><code>public class TeasetService {    public Teawater makeTeaWater(String who, Water water, TeaLeaf teaLeaf) {        String teawater = &quot;一杯容量为 &quot; + water.getCapacity() + &quot;, 温度为 &quot; + water.getTemperature() + &quot; 的&quot; + teaLeaf.getTeaName() + &quot;茶水&quot;;        System.out.println(who + &quot; 泡了&quot; + teawater);        return new Teawater(teawater);    }}</code></pre><p>人喝茶水</p><pre><code>public class Man {    private String name;    public Man(String name) {        this.name = name;    }    public void drink(Teawater teawater) {        System.out.println(name + &quot; 喝了&quot; + teawater.getTeaWater());    }}</code></pre><h4 id="自己泡茶喝"><a href="#自己泡茶喝" class="headerlink" title="自己泡茶喝"></a>自己泡茶喝</h4><p>张三、李四各自泡茶喝，各自都需要准备茶具、茶叶、水，各自还要完成烧水、泡茶等操作</p><pre><code>public class Main {    public static void main(String[] args) {        Man zhangsan = new Man(&quot;张三&quot;);        KettleService kettleService1 = new KettleService();        TeasetService teasetService1 = new TeasetService();        Water water1 = new Water();        TeaLeaf teaLeaf1 = new TeaLeaf(&quot;西湖龙井&quot;);        kettleService1.waterBurning(zhangsan.getName(), water1, 4);        Teawater teawater1 = teasetService1.makeTeaWater(zhangsan.getName(), water1, teaLeaf1);        zhangsan.drink(teawater1);        System.out.println();        Man lisi = new Man(&quot;李四&quot;);        KettleService kettleService2 = new KettleService();        TeasetService teasetService2 = new TeasetService();        Water water2 = new Water(10, 15);        TeaLeaf teaLeaf2 = new TeaLeaf(&quot;碧螺春&quot;);        kettleService2.waterBurning(lisi.getName(), water2, 4);        Teawater teawater2 = teasetService2.makeTeaWater(lisi.getName(), water2, teaLeaf2);        lisi.drink(teawater2);    }}</code></pre><p>输出为</p><pre><code>张三 使用水壶烧水，最终水温为 80张三 泡了一杯容量为 10, 温度为 80 的西湖龙井茶水张三 喝了一杯容量为 10, 温度为 80 的西湖龙井茶水李四 使用水壶烧水，最终水温为 90李四 泡了一杯容量为 15, 温度为 90 的碧螺春茶水李四 喝了一杯容量为 15, 温度为 90 的碧螺春茶水</code></pre><p>自己泡茶喝模式图</p><p><img src="http://image.laijianfeng.org/2018-09-16_174501.jpg" alt="自己泡茶喝模式图"></p><h4 id="到茶馆喝茶"><a href="#到茶馆喝茶" class="headerlink" title="到茶馆喝茶"></a>到茶馆喝茶</h4><p>茶馆，茶馆有不同的套餐</p><pre><code>public class TeaHouseFacade {    private String name;    private TeasetService teasetService;    private KettleService kettleService;    public TeaHouseFacade(String name) {        this.name = name;        this.teasetService = new TeasetService();        this.kettleService = new KettleService();    }    public Teawater makeTea(int teaNumber) {        switch (teaNumber) {            case 1:                Water water1 = new Water();                TeaLeaf teaLeaf1 = new TeaLeaf(&quot;西湖龙井&quot;);                kettleService.waterBurning(this.name, water1, 4);                Teawater teawater1 = teasetService.makeTeaWater(this.name, water1, teaLeaf1);                return teawater1;            case 2:                Water water2 = new Water(10, 15);                TeaLeaf teaLeaf2 = new TeaLeaf(&quot;碧螺春&quot;);                kettleService.waterBurning(this.name, water2, 4);                Teawater teawater2 = teasetService.makeTeaWater(this.name, water2, teaLeaf2);                return teawater2;            default:                Water water3 = new Water();                TeaLeaf teaLeaf3 = new TeaLeaf(&quot;招牌乌龙&quot;);                kettleService.waterBurning(this.name, water3, 5);                Teawater teawater3 = teasetService.makeTeaWater(this.name, water3, teaLeaf3);                return teawater3;        }    }}</code></pre><p>张三和李四点茶，只需要告诉茶馆套餐编号即可，水、茶叶由茶馆准备，烧水泡茶的操作由茶馆统一完成</p><pre><code>public class Test {    public static void main(String[] args) {        TeaHouseFacade teaHouseFacade = new TeaHouseFacade(&quot;老舍茶馆&quot;);        Man zhangsan = new Man(&quot;张三&quot;);        Teawater teawater = teaHouseFacade.makeTea(1);        zhangsan.drink(teawater);        System.out.println();        Man lisi = new Man(&quot;李四&quot;);        Teawater teawater1 = teaHouseFacade.makeTea(2);        lisi.drink(teawater1);    }}</code></pre><p>输出为</p><pre><code>老舍茶馆 使用水壶烧水，最终水温为 80老舍茶馆 泡了一杯容量为 10, 温度为 80 的西湖龙井茶水张三 喝了一杯容量为 10, 温度为 80 的西湖龙井茶水老舍茶馆 使用水壶烧水，最终水温为 90老舍茶馆 泡了一杯容量为 15, 温度为 90 的碧螺春茶水李四 喝了一杯容量为 15, 温度为 90 的碧螺春茶水</code></pre><p>到茶馆喝茶模式图</p><p><img src="http://image.laijianfeng.org/2018-09-16_174502.jpg" alt="到茶馆喝茶模式图"></p><h3 id="外观模式总结"><a href="#外观模式总结" class="headerlink" title="外观模式总结"></a>外观模式总结</h3><p>外观模式的<strong>主要优点</strong>如下：</p><ul><li>它对客户端屏蔽了子系统组件，减少了客户端所需处理的对象数目，并使得子系统使用起来更加容易。通过引入外观模式，客户端代码将变得很简单，与之关联的对象也很少。</li><li>它实现了子系统与客户端之间的松耦合关系，这使得子系统的变化不会影响到调用它的客户端，只需要调整外观类即可。</li><li>一个子系统的修改对其他子系统没有任何影响，而且子系统内部变化也不会影响到外观对象。</li></ul><p>外观模式的<strong>主要缺点</strong>如下：</p><ul><li>不能很好地限制客户端直接使用子系统类，如果对客户端访问子系统类做太多的限制则减少了可变性和灵活性。</li><li>如果设计不当，增加新的子系统可能需要修改外观类的源代码，违背了开闭原则。</li></ul><p><strong>适用场景：</strong></p><ul><li>当要为访问一系列复杂的子系统提供一个简单入口时可以使用外观模式。</li><li>客户端程序与多个子系统之间存在很大的依赖性。引入外观类可以将子系统与客户端解耦，从而提高子系统的独立性和可移植性。</li><li>在层次化结构中，可以使用外观模式定义系统中每一层的入口，层与层之间不直接产生联系，而通过外观类建立联系，降低层之间的耦合度。</li></ul><h3 id="源码分析外观模式的典型应用"><a href="#源码分析外观模式的典型应用" class="headerlink" title="源码分析外观模式的典型应用"></a>源码分析外观模式的典型应用</h3><h4 id="spring-jdbc中的外观模式"><a href="#spring-jdbc中的外观模式" class="headerlink" title="spring jdbc中的外观模式"></a>spring jdbc中的外观模式</h4><p>查看 <code>org.springframework.jdbc.support.JdbcUtils</code></p><pre><code>public abstract class JdbcUtils {    public static void closeConnection(Connection con) {        if (con != null) {            try {                con.close();            }            catch (SQLException ex) {                logger.debug(&quot;Could not close JDBC Connection&quot;, ex);            }            catch (Throwable ex) {                // We don&#39;t trust the JDBC driver: It might throw RuntimeException or Error.                logger.debug(&quot;Unexpected exception on closing JDBC Connection&quot;, ex);            }        }    }    public static Object getResultSetValue(ResultSet rs, int index, Class&lt;?&gt; requiredType) throws SQLException {        if (requiredType == null) {            return getResultSetValue(rs, index);        }        Object value = null;        boolean wasNullCheck = false;        // Explicitly extract typed value, as far as possible.        if (String.class.equals(requiredType)) {            value = rs.getString(index);        }        else if (boolean.class.equals(requiredType) || Boolean.class.equals(requiredType)) {            value = rs.getBoolean(index);            wasNullCheck = true;        }        else if (byte.class.equals(requiredType) || Byte.class.equals(requiredType)) {            value = rs.getByte(index);            wasNullCheck = true;        }        else if (short.class.equals(requiredType) || Short.class.equals(requiredType)) {            value = rs.getShort(index);            wasNullCheck = true;        }        else if (int.class.equals(requiredType) || Integer.class.equals(requiredType)) {            value = rs.getInt(index);            wasNullCheck = true;        }        else if (long.class.equals(requiredType) || Long.class.equals(requiredType)) {            value = rs.getLong(index);            wasNullCheck = true;        }        else if (float.class.equals(requiredType) || Float.class.equals(requiredType)) {            value = rs.getFloat(index);            wasNullCheck = true;        }        else if (double.class.equals(requiredType) || Double.class.equals(requiredType) ||                Number.class.equals(requiredType)) {            value = rs.getDouble(index);            wasNullCheck = true;        }        else if (byte[].class.equals(requiredType)) {            value = rs.getBytes(index);        }        else if (java.sql.Date.class.equals(requiredType)) {            value = rs.getDate(index);        }        else if (java.sql.Time.class.equals(requiredType)) {            value = rs.getTime(index);        }        else if (java.sql.Timestamp.class.equals(requiredType) || java.util.Date.class.equals(requiredType)) {            value = rs.getTimestamp(index);        }        else if (BigDecimal.class.equals(requiredType)) {            value = rs.getBigDecimal(index);        }        else if (Blob.class.equals(requiredType)) {            value = rs.getBlob(index);        }        else if (Clob.class.equals(requiredType)) {            value = rs.getClob(index);        }        else {            // Some unknown type desired -&gt; rely on getObject.            value = getResultSetValue(rs, index);        }        if (wasNullCheck &amp;&amp; value != null &amp;&amp; rs.wasNull()) {            value = null;        }        return value;    }    // ...省略...}    </code></pre><p>该工具类主要是对原生的 jdbc 进行了封装</p><h4 id="Mybatis中的外观模式"><a href="#Mybatis中的外观模式" class="headerlink" title="Mybatis中的外观模式"></a>Mybatis中的外观模式</h4><p>查看 <code>org.apache.ibatis.session.Configuration</code> 类中以 <code>new</code> 开头的方法</p><pre><code>public class Configuration {    public Executor newExecutor(Transaction transaction, ExecutorType executorType) {        executorType = executorType == null ? defaultExecutorType : executorType;        executorType = executorType == null ? ExecutorType.SIMPLE : executorType;        Executor executor;        if (ExecutorType.BATCH == executorType) {          executor = new BatchExecutor(this, transaction);        } else if (ExecutorType.REUSE == executorType) {          executor = new ReuseExecutor(this, transaction);        } else {          executor = new SimpleExecutor(this, transaction);        }        if (cacheEnabled) {          executor = new CachingExecutor(executor);        }        executor = (Executor) interceptorChain.pluginAll(executor);        return executor;    }    public ResultSetHandler newResultSetHandler(Executor executor, MappedStatement mappedStatement, RowBounds rowBounds, ParameterHandler parameterHandler,          ResultHandler resultHandler, BoundSql boundSql) {        ResultSetHandler resultSetHandler = new DefaultResultSetHandler(executor, mappedStatement, parameterHandler, resultHandler, boundSql, rowBounds);        resultSetHandler = (ResultSetHandler) interceptorChain.pluginAll(resultSetHandler);        return resultSetHandler;    }    // ...省略...}</code></pre><p>该类主要对一些创建对象的操作进行封装</p><h4 id="Tomcat-中的外观模式"><a href="#Tomcat-中的外观模式" class="headerlink" title="Tomcat 中的外观模式"></a>Tomcat 中的外观模式</h4><p>Tomcat 源码中大量使用了很多外观模式</p><p><img src="http://image.laijianfeng.org/20180916_193616.png" alt="Tomcat中的外观模式"></p><p><code>org.apache.catalina.connector.Request</code> 和 <code>org.apache.catalina.connector.RequestFacade</code> 这两个类都实现了 <code>HttpServletRequest</code> 接口</p><p>在 <code>Request</code> 中调用 <code>getRequest()</code> 实际获取的是 <code>RequestFacade</code> 的对象 </p><pre><code>protected RequestFacade facade = null;public HttpServletRequest getRequest() {    if (facade == null) {        facade = new RequestFacade(this);    }    return facade;}</code></pre><p>在 <code>RequestFacade</code> 中再对认为是子系统的操作进行封装</p><pre><code>public class RequestFacade implements HttpServletRequest {    /**     * The wrapped request.     */    protected Request request = null;    @Override    public Object getAttribute(String name) {        if (request == null) {            throw new IllegalStateException(sm.getString(&quot;requestFacade.nullRequest&quot;));        }        return request.getAttribute(name);    }    // ...省略...}    </code></pre><h4 id="SLF4J-中的外观模式"><a href="#SLF4J-中的外观模式" class="headerlink" title="SLF4J 中的外观模式"></a>SLF4J 中的外观模式</h4><p><code>SLF4J</code> 是简单的日志外观模式框架，抽象了各种日志框架例如 <code>Logback</code>、<code>Log4j</code>、<code>Commons-logging</code> 和 <code>JDK</code> 自带的 <code>logging</code> 实现接口。它使得用户可以在部署时使用自己想要的日志框架。</p><p><code>SLF4J</code> <strong>没有替代任何日志框架，它仅仅是标准日志框架的外观模式</strong>。如果在类路径下除了 <code>SLF4J</code> 再没有任何日志框架，那么默认状态是在控制台输出日志。</p><blockquote><p>日志处理框架 Logback 是 Log4j 的改进版本，原生支持SLF4J（因为是同一作者开发的），因此 Logback＋SLF4J 的组合是日志框架的最佳选择，比 SLF4J+其它日志框架 的组合要快一些。而且Logback的配置可以是XML或Groovy代码。</p></blockquote><p>SLF4J 的 helloworld 如下：</p><pre><code>import org.slf4j.Logger;import org.slf4j.LoggerFactory;public class HelloWorld {  public static void main(String[] args) {    Logger logger = LoggerFactory.getLogger(HelloWorld.class);    logger.info(&quot;Hello World&quot;);  }}</code></pre><p>下图为 SLF4J 与日志处理框架的绑定调用关系</p><p><img src="https://www.slf4j.org/images/concrete-bindings.png" alt="SLF4J与日志处理框架的绑定调用关系"></p><p>应用层调用 <code>slf4j-api.jar</code>，<code>slf4j-api.jar</code> 再根据所绑定的日志处理框架调用不同的 jar 包进行处理</p><blockquote><p>参考：<br>刘伟：设计模式Java版<br>慕课网java设计模式精讲 Debug 方式+内存分析<br><a href="https://www.cnblogs.com/xrq730/p/8619156.html" target="_blank" rel="noopener">Java日志框架：slf4j作用及其实现原理</a></p></blockquote><h4 id="推荐阅读"><a href="#推荐阅读" class="headerlink" title="推荐阅读"></a>推荐阅读</h4><p><a href="https://mp.weixin.qq.com/s?__biz=MzI1NDU0MTE1NA==&amp;mid=2247483700&amp;idx=1&amp;sn=dd4d23f9400c8be248f5d125465ba941&amp;chksm=e9c2ed39deb5642fb809eca1351f00995f06c9a4875f09986cc5005059eff74d6c20fc1118a3&amp;scene=0#rd" target="_blank" rel="noopener">设计模式 | 简单工厂模式及典型应用</a><br><a href="https://mp.weixin.qq.com/s?__biz=MzI1NDU0MTE1NA==&amp;mid=2247483704&amp;idx=1&amp;sn=fa3ae947cebf22da35e6ac0a37f566f8&amp;chksm=e9c2ed35deb564230a69e43d93a3b74618287c6ddd402a6f1dc6a5b14a896e99584985e7cf92&amp;scene=0#rd" target="_blank" rel="noopener">设计模式 | 工厂方法模式及典型应用</a><br><a href="https://mp.weixin.qq.com/s?__biz=MzI1NDU0MTE1NA==&amp;mid=2247483708&amp;idx=1&amp;sn=9b8c155b86511ea6ec323dc6a72c52df&amp;chksm=e9c2ed31deb56427b2a6bbcbad5bdd3a4ef68b52eb88cc47b5bcfc76773d3d983d8aaf57761c&amp;scene=0#rd" target="_blank" rel="noopener">设计模式 | 抽象工厂模式及典型应用</a><br><a href="https://mp.weixin.qq.com/s?__biz=MzI1NDU0MTE1NA==&amp;mid=2247483712&amp;idx=1&amp;sn=1ffd9837eb9413dde74ff509bf69ecc5&amp;chksm=e9c2ed4ddeb5645b8cbf64c83d103a859ae49921c60e17fe8bebe63c26b04966be101d598848&amp;scene=0#rd" target="_blank" rel="noopener">设计模式 | 建造者模式及典型应用</a><br><a href="https://mp.weixin.qq.com/s?__biz=MzI1NDU0MTE1NA==&amp;mid=2247483716&amp;idx=1&amp;sn=df00c297c8f32e10e277db8941839c14&amp;chksm=e9c2ed49deb5645fa2586da358a8f0a00dd926f883637adebc59435f846c67c040ef759ba034&amp;scene=0#rd" target="_blank" rel="noopener">设计模式 | 原型模式及典型应用</a></p><p><img src="http://image.laijianfeng.org/20180913_001328.png" alt="关注_小旋锋_微信公众号"></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h3 id=&quot;前言&quot;&gt;&lt;a href=&quot;#前言&quot; class=&quot;headerlink&quot; title=&quot;前言&quot;&gt;&lt;/a&gt;前言&lt;/h3&gt;&lt;p&gt;本文的主要内容：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;介绍外观模式&lt;/li&gt;
&lt;li&gt;示例&lt;ul&gt;
&lt;li&gt;自己泡茶&lt;/li&gt;
&lt;li&gt;到茶馆喝茶&lt;/
      
    
    </summary>
    
      <category term="后端" scheme="http://laijianfeng.org/categories/%E5%90%8E%E7%AB%AF/"/>
    
    
      <category term="设计模式" scheme="http://laijianfeng.org/tags/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/"/>
    
  </entry>
  
  <entry>
    <title>设计模式 | 原型模式及典型应用</title>
    <link href="http://laijianfeng.org/2018/09/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F-%E5%8E%9F%E5%9E%8B%E6%A8%A1%E5%BC%8F%E5%8F%8A%E5%85%B8%E5%9E%8B%E5%BA%94%E7%94%A8/"/>
    <id>http://laijianfeng.org/2018/09/设计模式-原型模式及典型应用/</id>
    <published>2018-09-14T16:08:13.000Z</published>
    <updated>2018-09-14T16:09:23.726Z</updated>
    
    <content type="html"><![CDATA[<h3 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h3><p>本文的主要内容如下：</p><ul><li>介绍原型模式</li><li>示例<ul><li>Java语言的clone</li><li>浅克隆与深克隆</li><li>实现深克隆</li></ul></li><li>原型模式的典型应用</li></ul><h3 id="原型模式"><a href="#原型模式" class="headerlink" title="原型模式"></a>原型模式</h3><p><strong>原型模式(Prototype Pattern)</strong>：使用原型实例指定创建对象的种类，并且通过拷贝这些原型创建新的对象。原型模式是一种对象创建型模式。</p><p>原型模式的工作原理很简单：将一个原型对象传给那个要发动创建的对象，这个要发动创建的对象通过请求原型对象拷贝自己来实现创建过程。</p><p>原型模式是一种“另类”的创建型模式，创建克隆对象的工厂就是原型类自身，工厂方法由克隆方法来实现。</p><p>需要注意的是通过克隆方法所创建的对象是全新的对象，它们在内存中拥有新的地址，通常对克隆所产生的对象进行修改对原型对象不会造成任何影响，每一个克隆对象都是相互独立的。通过不同的方式修改可以得到一系列相似但不完全相同的对象。</p><h4 id="角色"><a href="#角色" class="headerlink" title="角色"></a>角色</h4><ul><li><strong>Prototype（抽象原型类）</strong>：它是声明克隆方法的接口，是所有具体原型类的公共父类，可以是抽象类也可以是接口，甚至还可以是具体实现类。</li><li><strong>ConcretePrototype（具体原型类）</strong>：它实现在抽象原型类中声明的克隆方法，在克隆方法中返回自己的一个克隆对象。</li><li><strong>Client（客户类）</strong>：让一个原型对象克隆自身从而创建一个新的对象，在客户类中只需要直接实例化或通过工厂方法等方式创建一个原型对象，再通过调用该对象的克隆方法即可得到多个相同的对象。由于客户类针对抽象原型类Prototype编程，因此用户可以根据需要选择具体原型类，系统具有较好的可扩展性，增加或更换具体原型类都很方便。</li></ul><p>原型模式的<strong>核心在于如何实现克隆方法</strong>。</p><h3 id="示例"><a href="#示例" class="headerlink" title="示例"></a>示例</h3><h4 id="Java语言提供的clone-方法"><a href="#Java语言提供的clone-方法" class="headerlink" title="Java语言提供的clone()方法"></a>Java语言提供的clone()方法</h4><p>学过Java语言的人都知道，所有的Java类都继承自 <code>java.lang.Object</code>。事实上，<code>Object</code> 类提供一个 <code>clone()</code> 方法，可以将一个Java对象复制一份。因此在Java中可以直接使用 <code>Object</code> 提供的 <code>clone()</code> 方法来实现对象的克隆，Java语言中的原型模式实现很简单。</p><p>需要注意的是能够实现克隆的Java类必须实现一个 <code>标识接口 Cloneable</code>，表示这个Java类支持被复制。如果一个类没有实现这个接口但是调用了clone()方法，Java编译器将抛出一个 <code>CloneNotSupportedException</code> 异常。</p><pre><code>public class Mail implements Cloneable{    private String name;    private String emailAddress;    private String content;    public Mail(){        System.out.println(&quot;Mail Class Constructor&quot;);    }    // ...省略 getter、setter    @Override    protected Object clone() throws CloneNotSupportedException {        System.out.println(&quot;clone mail object&quot;);        return super.clone();    }}</code></pre><p>在客户端创建原型对象和克隆对象也很简单，如下代码所示：</p><pre><code>public class Test {    public static void main(String[] args) throws CloneNotSupportedException {        Mail mail = new Mail();        mail.setContent(&quot;初始化模板&quot;);        System.out.println(&quot;初始化mail:&quot;+mail);        for(int i = 0;i &lt; 3;i++){            System.out.println();            Mail mailTemp = (Mail) mail.clone();            mailTemp.setName(&quot;姓名&quot;+i);            mailTemp.setEmailAddress(&quot;姓名&quot;+i+&quot;@test.com&quot;);            mailTemp.setContent(&quot;恭喜您，此次抽奖活动中奖了&quot;);            MailUtil.sendMail(mailTemp);            System.out.println(&quot;克隆的mailTemp:&quot;+mailTemp);        }        MailUtil.saveOriginMailRecord(mail);    }}</code></pre><p>其中的 <code>MailUtil</code> 工具类为</p><pre><code>public class MailUtil {    public static void sendMail(Mail mail) {        String outputContent = &quot;向{0}同学,邮件地址:{1},邮件内容:{2}发送邮件成功&quot;;        System.out.println(MessageFormat.format(outputContent, mail.getName(), mail.getEmailAddress(), mail.getContent()));    }    public static void saveOriginMailRecord(Mail mail) {        System.out.println(&quot;存储originMail记录,originMail:&quot; + mail.getContent());    }}</code></pre><p>输出如下：</p><pre><code>Mail Class Constructor初始化mail:Mail{name=&#39;null&#39;, emailAddress=&#39;null&#39;, content=&#39;初始化模板&#39;}com.designpattern.prototype.Mail@12edcd21clone mail object向姓名0同学,邮件地址:姓名0@test.com,邮件内容:恭喜您，此次抽奖活动中奖了发送邮件成功克隆的mailTemp:Mail{name=&#39;姓名0&#39;, emailAddress=&#39;姓名0@test.com&#39;, content=&#39;恭喜您，此次抽奖活动中奖了&#39;}com.designpattern.prototype.Mail@34c45dcaclone mail object向姓名1同学,邮件地址:姓名1@test.com,邮件内容:恭喜您，此次抽奖活动中奖了发送邮件成功克隆的mailTemp:Mail{name=&#39;姓名1&#39;, emailAddress=&#39;姓名1@test.com&#39;, content=&#39;恭喜您，此次抽奖活动中奖了&#39;}com.designpattern.prototype.Mail@52cc8049clone mail object向姓名2同学,邮件地址:姓名2@test.com,邮件内容:恭喜您，此次抽奖活动中奖了发送邮件成功克隆的mailTemp:Mail{name=&#39;姓名2&#39;, emailAddress=&#39;姓名2@test.com&#39;, content=&#39;恭喜您，此次抽奖活动中奖了&#39;}com.designpattern.prototype.Mail@5b6f7412存储originMail记录,originMail:初始化模板</code></pre><p>从输出结果中我们可以观察到：</p><ul><li>for循环中的 mailTemp 从 mail 对象中克隆得到，它们的内存地址均不同，说明不是同一个对象，克隆成功，克隆仅仅通过调用 <code>super.clone()</code> 即可。</li><li>最后调用的 <code>MailUtil.saveOriginMailRecord(mail);</code> 中的 <code>mail</code> 对象的内容仍为 for 循环之前设置的内容，并没有因为克隆而改变。</li><li>克隆的时候调用了 <code>clone</code> 方法，并没有调用 <code>Mail</code> 类的构造器，只在最前面 <code>new</code> 的时候才调用了一次</li></ul><p>关于输出的内存地址是怎么输出的，我们还需要看一下 <code>Object#toString</code> 方法</p><pre><code>public class Object {    public String toString() {        return getClass().getName() + &quot;@&quot; + Integer.toHexString(hashCode());    }    //...省略...}</code></pre><p>所以所谓的内存地址即为 <code>hashCode()</code> 的十六进制表示，这里简单的认为 内存地址相同则为同一个对象，不同则为不同对象</p><p>再来看一眼 <code>Object#clone</code> 方法</p><pre><code>protected native Object clone() throws CloneNotSupportedException;</code></pre><p>这是一个 <code>native</code> 关键字修饰的方法</p><p>一般而言，Java语言中的clone()方法满足：</p><ul><li>对任何对象x，都有 <code>x.clone() != x</code>，即克隆对象与原型对象不是同一个对象；</li><li>对任何对象x，都有 <code>x.clone().getClass() == x.getClass()</code>，即克隆对象与原型对象的类型一样；</li><li>如果对象x的 <code>equals()</code> 方法定义恰当，那么 <code>x.clone().equals(x)</code> 应该成立。</li></ul><p>为了获取对象的一份拷贝，我们可以直接利用Object类的clone()方法，具体步骤如下：</p><ol><li>在派生类中覆盖基类的 <code>clone()</code> 方法，并声明为public；</li><li>在派生类的 <code>clone()</code> 方法中，调用 <code>super.clone()</code>；</li><li>派生类需实现Cloneable接口。</li></ol><p>此时，Object类相当于<strong>抽象原型类</strong>，所有实现了Cloneable接口的类相当于<strong>具体原型类</strong>。</p><h4 id="浅克隆与深克隆"><a href="#浅克隆与深克隆" class="headerlink" title="浅克隆与深克隆"></a>浅克隆与深克隆</h4><p>看下面的示例</p><pre><code>public class Pig implements Cloneable{    private String name;    private Date birthday;    // ...getter, setter, construct    @Override    protected Object clone() throws CloneNotSupportedException {        Pig pig = (Pig)super.clone();        return pig;    }    @Override    public String toString() {        return &quot;Pig{&quot; +                &quot;name=&#39;&quot; + name + &#39;\&#39;&#39; +                &quot;, birthday=&quot; + birthday +                &#39;}&#39;+super.toString();    }}</code></pre><p>测试</p><pre><code>public class Test {    public static void main(String[] args) throws CloneNotSupportedException, NoSuchMethodException, InvocationTargetException, IllegalAccessException {        Date birthday = new Date(0L);        Pig pig1 = new Pig(&quot;佩奇&quot;,birthday);        Pig pig2 = (Pig) pig1.clone();        System.out.println(pig1);        System.out.println(pig2);        pig1.getBirthday().setTime(666666666666L);        System.out.println(pig1);        System.out.println(pig2);    }}</code></pre><p>输出如下</p><pre><code>Pig{name=&#39;佩奇&#39;, birthday=Thu Jan 01 08:00:00 CST 1970}com.designpattern.clone.Pig@27973e9bPig{name=&#39;佩奇&#39;, birthday=Thu Jan 01 08:00:00 CST 1970}com.designpattern.clone.Pig@312b1daePig{name=&#39;佩奇&#39;, birthday=Sat Feb 16 09:11:06 CST 1991}com.designpattern.clone.Pig@27973e9bPig{name=&#39;佩奇&#39;, birthday=Sat Feb 16 09:11:06 CST 1991}com.designpattern.clone.Pig@312b1dae</code></pre><p>我们照着上一小节说的实现 <code>Cloneable</code>，调用 <code>super.clone();</code> 进行克隆，中间我们对 <code>pig1</code> 对象设置了一个时间戳，从输出中我们可以发现什么问题呢？</p><p>我们可以发现：</p><ul><li><code>pig1</code> 与 <code>pig2</code> 的内存地址不同</li><li>对 <code>pig1</code> 设置了时间，同事 <code>pig2</code> 的时间也改变了</li></ul><p>我们通过 debug 来看一下</p><p><img src="http://image.laijianfeng.org/20180914_224723.png" alt="debug查看对象地址"></p><p>发现如下：</p><ul><li>pig1 与 pig2 地址不一样</li><li>pig1 的 birthday 与 pig2 的 birthday <strong>一样</strong></li></ul><p>这里引出浅拷贝与深拷贝。</p><p>在Java语言中，数据类型分为值类型（基本数据类型）和引用类型，<strong>值类型</strong>包括int、double、byte、boolean、char等简单数据类型，<strong>引用类型</strong>包括类、接口、数组等复杂类型。</p><p>浅克隆和深克隆的主要区别在于<strong>是否支持引用类型的成员变量的复制</strong>，下面将对两者进行详细介绍。</p><p><strong>浅克隆：</strong></p><ul><li><p>在浅克隆中，如果原型对象的成员变量是值类型，将复制一份给克隆对象；如果原型对象的成员变量是引用类型，则将引用对象的地址复制一份给克隆对象，也就是说原型对象和克隆对象的成员变量指向相同的内存地址。</p></li><li><p>简单来说，在浅克隆中，当对象被复制时<strong>只复制它本身和其中包含的值类型的成员变量</strong>，而<strong>引用类型的成员对象并没有复制</strong>。</p></li><li><p>在Java语言中，通过覆盖Object类的clone()方法可以实现浅克隆。</p></li></ul><p><strong>深克隆：</strong></p><ul><li><p>在深克隆中，<strong>无论原型对象的成员变量是值类型还是引用类型，都将复制一份给克隆对象</strong>，深克隆将原型对象的所有引用对象也复制一份给克隆对象。</p></li><li><p>简单来说，在深克隆中，除了对象本身被复制外，对象所包含的所有成员变量也将复制。</p></li><li><p>在Java语言中，如果需要实现深克隆，可以通过序列化(Serialization)等方式来实现。需要注意的是能够实现序列化的对象其类必须实现Serializable接口，否则无法实现序列化操作。</p></li></ul><h4 id="实现深克隆"><a href="#实现深克隆" class="headerlink" title="实现深克隆"></a>实现深克隆</h4><p>方式一，手动对引用对象进行克隆：</p><pre><code>    @Override    protected Object clone() throws CloneNotSupportedException {        Pig pig = (Pig)super.clone();        //深克隆        pig.birthday = (Date) pig.birthday.clone();        return pig;    }</code></pre><p>方式二，通过序列化的方式：</p><pre><code>public class Pig implements Serializable {    private String name;    private Date birthday;    // ...省略 getter, setter等    protected Object deepClone() throws CloneNotSupportedException, IOException, ClassNotFoundException {        //将对象写入流中        ByteArrayOutputStream bao = new ByteArrayOutputStream();        ObjectOutputStream oos = new ObjectOutputStream(bao);        oos.writeObject(this);        //将对象从流中取出        ByteArrayInputStream bis = new ByteArrayInputStream(bao.toByteArray());        ObjectInputStream ois = new ObjectInputStream(bis);        return (ois.readObject());    }}</code></pre><p><img src="http://image.laijianfeng.org/20180914_230920.png" alt="序列化方式的深克隆结果"></p><h3 id="破坏单例模式"><a href="#破坏单例模式" class="headerlink" title="破坏单例模式"></a>破坏单例模式</h3><p>饿汉式单例模式如下：</p><pre><code>public class HungrySingleton implements Serializable, Cloneable {    private final static HungrySingleton hungrySingleton;    static {        hungrySingleton = new HungrySingleton();    }    private HungrySingleton() {        if (hungrySingleton != null) {            throw new RuntimeException(&quot;单例构造器禁止反射调用&quot;);        }    }    public static HungrySingleton getInstance() {        return hungrySingleton;    }    private Object readResolve() {        return hungrySingleton;    }    @Override    protected Object clone() throws CloneNotSupportedException {        return super.clone();    }}</code></pre><p>使用反射获取对象，测试如下</p><pre><code>public class Test {    public static void main(String[] args) throws CloneNotSupportedException, NoSuchMethodException, InvocationTargetException, IllegalAccessException {        HungrySingleton hungrySingleton = HungrySingleton.getInstance();        Method method = hungrySingleton.getClass().getDeclaredMethod(&quot;clone&quot;);        method.setAccessible(true);        HungrySingleton cloneHungrySingleton = (HungrySingleton) method.invoke(hungrySingleton);        System.out.println(hungrySingleton);        System.out.println(cloneHungrySingleton);    }}</code></pre><p>输出</p><pre><code>com.designpattern.HungrySingleton@34c45dcacom.designpattern.HungrySingleton@52cc8049</code></pre><p>可以看到，通过原型模式，我们把单例模式给破坏了，现在有两个对象了</p><p>为了防止单例模式被破坏，我们可以：不实现 <code>Cloneable</code> 接口；或者把 <code>clone</code> 方法改为如下</p><pre><code>    @Override    protected Object clone() throws CloneNotSupportedException {        return getInstance();    }</code></pre><h3 id="原型模式的典型应用"><a href="#原型模式的典型应用" class="headerlink" title="原型模式的典型应用"></a>原型模式的典型应用</h3><ol><li><code>Object</code> 类中的 <code>clone</code> 接口</li><li><code>Cloneable</code> 接口的实现类，可以看到至少一千多个，找几个例子譬如：</li></ol><p><img src="http://image.laijianfeng.org/20180914_233315.png" alt="Cloneable接口的实现类"></p><p><code>ArrayList</code> 对 <code>clone</code> 的重写如下：</p><pre><code>public class ArrayList&lt;E&gt; extends AbstractList&lt;E&gt;        implements List&lt;E&gt;, RandomAccess, Cloneable, java.io.Serializable {    public Object clone() {        try {            ArrayList&lt;?&gt; v = (ArrayList&lt;?&gt;) super.clone();            v.elementData = Arrays.copyOf(elementData, size);            v.modCount = 0;            return v;        } catch (CloneNotSupportedException e) {            // this shouldn&#39;t happen, since we are Cloneable            throw new InternalError(e);        }    }    //...省略}</code></pre><p>调用 <code>super.clone();</code> 之后把 <code>elementData</code> 数据 copy 了一份</p><p>同理，我们看看 <code>HashMap</code> 对 <code>clone</code> 方法的重写：</p><pre><code>public class HashMap&lt;K,V&gt; extends AbstractMap&lt;K,V&gt; implements Map&lt;K,V&gt;, Cloneable, Serializable {    @Override    public Object clone() {        HashMap&lt;K,V&gt; result;        try {            result = (HashMap&lt;K,V&gt;)super.clone();        } catch (CloneNotSupportedException e) {            // this shouldn&#39;t happen, since we are Cloneable            throw new InternalError(e);        }        result.reinitialize();        result.putMapEntries(this, false);        return result;    }    // ...省略...}</code></pre><p>mybatis 中的 <code>org.apache.ibatis.cache.CacheKey</code> 对 <code>clone</code> 方法的重写：</p><pre><code>public class CacheKey implements Cloneable, Serializable {    private List&lt;Object&gt; updateList;    public CacheKey clone() throws CloneNotSupportedException {        CacheKey clonedCacheKey = (CacheKey)super.clone();        clonedCacheKey.updateList = new ArrayList(this.updateList);        return clonedCacheKey;    }    // ... 省略...}</code></pre><p>这里又要注意，<code>updateList</code> 是 <code>List&lt;Object&gt;</code> 类型，所以可能是值类型的List，也可能是引用类型的List，克隆的结果需要注意是否为深克隆或者浅克隆</p><p><strong>使用原始模式的时候一定要注意为深克隆还是浅克隆。</strong></p><h3 id="原型模式总结"><a href="#原型模式总结" class="headerlink" title="原型模式总结"></a>原型模式总结</h3><p>原型模式的<strong>主要优点</strong>如下：</p><ul><li>当创建新的对象实例较为复杂时，使用原型模式可以简化对象的创建过程，通过复制一个已有实例可以提高新实例的创建效率。</li><li>扩展性较好，由于在原型模式中提供了抽象原型类，在客户端可以针对抽象原型类进行编程，而将具体原型类写在配置文件中，增加或减少产品类对原有系统都没有任何影响。</li><li>原型模式提供了简化的创建结构，工厂方法模式常常需要有一个与产品类等级结构相同的工厂等级结构，而原型模式就不需要这样，原型模式中产品的复制是通过封装在原型类中的克隆方法实现的，无须专门的工厂类来创建产品。</li><li>可以使用深克隆的方式保存对象的状态，使用原型模式将对象复制一份并将其状态保存起来，以便在需要的时候使用（如恢复到某一历史状态），可辅助实现撤销操作。</li></ul><p>原型模式的<strong>主要缺点</strong>如下：</p><ul><li>需要为每一个类配备一个克隆方法，而且该克隆方法位于一个类的内部，当对已有的类进行改造时，需要修改源代码，违背了“开闭原则”。</li><li>在实现深克隆时需要编写较为复杂的代码，而且当对象之间存在多重的嵌套引用时，为了实现深克隆，每一层对象对应的类都必须支持深克隆，实现起来可能会比较麻烦。</li></ul><p><strong>适用场景：</strong></p><ul><li>创建新对象成本较大（如初始化需要占用较长的时间，占用太多的CPU资源或网络资源），新的对象可以通过原型模式对已有对象进行复制来获得，如果是相似对象，则可以对其成员变量稍作修改。</li><li>如果系统要保存对象的状态，而对象的状态变化很小，或者对象本身占用内存较少时，可以使用原型模式配合备忘录模式来实现。</li><li>需要避免使用分层次的工厂类来创建分层次的对象，并且类的实例对象只有一个或很少的几个组合状态，通过复制原型对象得到新实例可能比使用构造函数创建一个新实例更加方便。</li></ul><blockquote><p>参考：<br>刘伟：设计模式Java版<br>慕课网java设计模式精讲 Debug 方式+内存分析</p></blockquote><p><img src="http://image.laijianfeng.org/20180913_001328.png" alt="关注_小旋锋_微信公众号"></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h3 id=&quot;前言&quot;&gt;&lt;a href=&quot;#前言&quot; class=&quot;headerlink&quot; title=&quot;前言&quot;&gt;&lt;/a&gt;前言&lt;/h3&gt;&lt;p&gt;本文的主要内容如下：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;介绍原型模式&lt;/li&gt;
&lt;li&gt;示例&lt;ul&gt;
&lt;li&gt;Java语言的clone&lt;/li&gt;
&lt;
      
    
    </summary>
    
      <category term="后端" scheme="http://laijianfeng.org/categories/%E5%90%8E%E7%AB%AF/"/>
    
    
      <category term="设计模式" scheme="http://laijianfeng.org/tags/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/"/>
    
  </entry>
  
  <entry>
    <title>设计模式 | 建造者模式及典型应用</title>
    <link href="http://laijianfeng.org/2018/09/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F-%E5%BB%BA%E9%80%A0%E8%80%85%E6%A8%A1%E5%BC%8F%E5%8F%8A%E5%85%B8%E5%9E%8B%E5%BA%94%E7%94%A8/"/>
    <id>http://laijianfeng.org/2018/09/设计模式-建造者模式及典型应用/</id>
    <published>2018-09-11T16:39:42.000Z</published>
    <updated>2018-09-11T16:40:51.023Z</updated>
    
    <content type="html"><![CDATA[<h3 id="建造者模式"><a href="#建造者模式" class="headerlink" title="建造者模式"></a>建造者模式</h3><p>建造者模式(Builder Pattern)：将一个复杂对象的构建与它的表示分离，使得同样的构建过程可以创建不同的表示。建造者模式是一种对象创建型模式。</p><p>建造者模式一步一步创建一个复杂的对象，它允许用户只通过指定复杂对象的类型和内容就可以构建它们，用户不需要知道内部的具体构建细节。</p><h4 id="角色"><a href="#角色" class="headerlink" title="角色"></a>角色</h4><p><strong>Builder（抽象建造者）</strong>：它为创建一个产品Product对象的各个部件指定抽象接口，在该接口中一般声明两类方法，一类方法是buildPartX()，它们用于创建复杂对象的各个部件；另一类方法是getResult()，它们用于返回复杂对象。Builder既可以是抽象类，也可以是接口。</p><p><strong>ConcreteBuilder（具体建造者）</strong>：它实现了Builder接口，实现各个部件的具体构造和装配方法，定义并明确它所创建的复杂对象，也可以提供一个方法返回创建好的复杂产品对象。</p><p><strong>Product（产品角色）</strong>：它是被构建的复杂对象，包含多个组成部件，具体建造者创建该产品的内部表示并定义它的装配过程。</p><p><strong>Director（指挥者）</strong>：指挥者又称为导演类，它负责安排复杂对象的建造次序，指挥者与抽象建造者之间存在关联关系，可以在其construct()建造方法中调用建造者对象的部件构造与装配方法，完成复杂对象的建造。客户端一般只需要与指挥者进行交互，在客户端确定具体建造者的类型，并实例化具体建造者对象（也可以通过配置文件和反射机制），然后通过指挥者类的构造函数或者Setter方法将该对象传入指挥者类中。</p><p>在建造者模式的定义中提到了复杂对象，那么什么是复杂对象？简单来说，<strong>复杂对象</strong>是指那些包含多个成员属性的对象，这些成员属性也称为部件或零件，如汽车包括方向盘、发动机、轮胎等部件，电子邮件包括发件人、收件人、主题、内容、附件等部件</p><h3 id="示例"><a href="#示例" class="headerlink" title="示例"></a>示例</h3><p>产品角色 <code>Computer</code></p><pre><code>public class Computer {    private String brand;    private String cpu;    private String mainBoard;    private String hardDisk;    private String displayCard;    private String power;    private String memory;    // 省略 getter, setter, toString}</code></pre><p>抽象建造者 <code>builder</code></p><pre><code>public abstract class Builder {    protected Computer computer = new Computer();    public abstract void buildBrand();    public abstract void buildCPU();    public abstract void buildMainBoard();    public abstract void buildHardDisk();    public abstract void buildDisplayCard();    public abstract void buildPower();    public abstract void buildMemory();    public Computer createComputer() {        return computer;    }}</code></pre><p>具体建造者 <code>DellComputerBuilder</code>，<code>ASUSComputerBuilder</code>，分别建造戴尔电脑和华硕电脑</p><pre><code>public class DellComputerBuilder extends Builder {    @Override    public void buildBrand() {        computer.setBrand(&quot;戴尔电脑&quot;);    }    @Override    public void buildCPU() {        computer.setCpu(&quot;i5-8300H 四核&quot;);    }    @Override    public void buildMainBoard() {        computer.setMainBoard(&quot;戴尔主板&quot;);    }    @Override    public void buildHardDisk() {        computer.setHardDisk(&quot;1T + 128GB SSD&quot;);    }    @Override    public void buildDisplayCard() {        computer.setDisplayCard(&quot;GTX1060 独立6GB&quot;);    }    @Override    public void buildPower() {        computer.setPower(&quot;4芯 锂离子电池 180W AC适配器&quot;);    }    @Override    public void buildMemory() {        computer.setMemory(&quot;4G + 4G&quot;);    }}public class ASUSComputerBuilder extends Builder{    @Override    public void buildBrand() {        computer.setBrand(&quot;华硕电脑&quot;);    }    @Override    public void buildCPU() {        computer.setCpu(&quot;Intel 第8代 酷睿&quot;);    }    @Override    public void buildMainBoard() {        computer.setMainBoard(&quot;华硕主板&quot;);    }    @Override    public void buildHardDisk() {        computer.setHardDisk(&quot;256GB SSD&quot;);    }    @Override    public void buildDisplayCard() {        computer.setDisplayCard(&quot;MX150 独立2GB&quot;);    }    @Override    public void buildPower() {        computer.setPower(&quot;3芯 锂离子电池 65W AC适配器&quot;);    }    @Override    public void buildMemory() {        computer.setMemory(&quot;1 x SO-DIMM  8GB&quot;);    }}</code></pre><p>指挥者 <code>ComputerDirector</code>，指挥构建过程</p><pre><code>public class ComputerDirector {    public Computer construct(Builder builder) {        // 逐步构建复杂产品对象        Computer computer;        builder.buildBrand();        builder.buildCPU();        builder.buildDisplayCard();        builder.buildHardDisk();        builder.buildMainBoard();        builder.buildMemory();        builder.buildPower();        computer = builder.createComputer();        return computer;    }}</code></pre><p>客户端测试</p><pre><code>public class Test {    public static void main(String[] args) {        ComputerDirector director = new ComputerDirector();        Builder asusBuilder = new ASUSComputerBuilder();        Computer asusComputer = director.construct(asusBuilder);        System.out.println(asusComputer.toString());        Builder dellBuilder = new DellComputerBuilder();        Computer dellComputer = director.construct(dellBuilder);        System.out.println(dellComputer.toString());    }}</code></pre><p>输出</p><pre><code>Computer{brand=&#39;华硕电脑&#39;, cpu=&#39;Intel 第8代 酷睿&#39;, mainBoard=&#39;华硕主板&#39;, hardDisk=&#39;256GB SSD&#39;, displayCard=&#39;MX150 独立2GB&#39;, power=&#39;3芯 锂离子电池 65W AC适配器&#39;, memory=&#39;1 x SO-DIMM  8GB&#39;}Computer{brand=&#39;戴尔电脑&#39;, cpu=&#39;i5-8300H 四核&#39;, mainBoard=&#39;戴尔主板&#39;, hardDisk=&#39;1T + 128GB SSD&#39;, displayCard=&#39;GTX1060 独立6GB&#39;, power=&#39;4芯 锂离子电池 180W AC适配器&#39;, memory=&#39;4G + 4G&#39;}</code></pre><p>可以通过反射机制和配置文件配合，创建具体建造者对象</p><pre><code>public class Test {    public static void main(String[] args) throws ClassNotFoundException, IllegalAccessException, InstantiationException {        ComputerDirector director = new ComputerDirector();        // 从数据库或者配置文件中读取具体建造者类名        Class c = Class.forName(&quot;com.designpattern.ASUSComputerBuilder&quot;);        Builder asusBuilder = (Builder) c.newInstance();        Computer asusComputer = director.construct(asusBuilder);        System.out.println(asusComputer.toString());    }}</code></pre><p><img src="http://image.laijianfeng.org/20180911_164411.png" alt="image"></p><h3 id="建造者模式总结"><a href="#建造者模式总结" class="headerlink" title="建造者模式总结"></a>建造者模式总结</h3><p>建造者模式的<strong>主要优点</strong>如下：</p><ul><li>在建造者模式中，客户端不必知道产品内部组成的细节，将产品本身与产品的创建过程解耦，使得相同的创建过程可以创建不同的产品对象。</li><li>每一个具体建造者都相对独立，而与其他的具体建造者无关，因此可以很方便地替换具体建造者或增加新的具体建造者，用户使用不同的具体建造者即可得到不同的产品对象。由于指挥者类针对抽象建造者编程，增加新的具体建造者无须修改原有类库的代码，系统扩展方便，符合 “开闭原则”。</li><li>可以更加精细地控制产品的创建过程。将复杂产品的创建步骤分解在不同的方法中，使得创建过程更加清晰，也更方便使用程序来控制创建过程。</li></ul><p>建造者模式的<strong>主要缺点</strong>如下：</p><ul><li>建造者模式所创建的产品一般具有较多的共同点，其组成部分相似，如果产品之间的差异性很大，例如很多组成部分都不相同，不适合使用建造者模式，因此其使用范围受到一定的限制。</li><li>如果产品的内部变化复杂，可能会导致需要定义很多具体建造者类来实现这种变化，导致系统变得很庞大，增加系统的理解难度和运行成本。</li></ul><p><strong>适用场景</strong>：</p><ul><li>需要生成的产品对象有复杂的内部结构，这些产品对象通常包含多个成员属性。</li><li>需要生成的产品对象的属性相互依赖，需要指定其生成顺序。</li><li>对象的创建过程独立于创建该对象的类。在建造者模式中通过引入了指挥者类，将创建过程封装在指挥者类中，而不在建造者类和客户类中。</li><li>隔离复杂对象的创建和使用，并使得相同的创建过程可以创建不同的产品。</li></ul><h3 id="建造者模式的典型应用和源码分析"><a href="#建造者模式的典型应用和源码分析" class="headerlink" title="建造者模式的典型应用和源码分析"></a>建造者模式的典型应用和源码分析</h3><h4 id="java-lang-StringBuilder-中的建造者模式"><a href="#java-lang-StringBuilder-中的建造者模式" class="headerlink" title="java.lang.StringBuilder 中的建造者模式"></a>java.lang.StringBuilder 中的建造者模式</h4><p><code>StringBuilder</code> 的继承实现关系如下所示</p><p><img src="http://image.laijianfeng.org/20180911_172041.png" alt="StringBuilder的类图"></p><p><code>Appendable</code> 接口如下</p><pre><code>public interface Appendable {    Appendable append(CharSequence csq) throws IOException;    Appendable append(CharSequence csq, int start, int end) throws IOException;    Appendable append(char c) throws IOException;}</code></pre><p><code>StringBuilder</code> 中的 <code>append</code> 方法使用了建造者模式，不过装配方法只有一个，并不算复杂，<code>append</code> 方法返回的是 <code>StringBuilder</code> 自身</p><pre><code>public final class StringBuilder extends AbstractStringBuilder implements java.io.Serializable, CharSequence {    @Override    public StringBuilder append(String str) {        super.append(str);        return this;    }    // ...省略...}</code></pre><p><code>StringBuilder</code> 的父类 <code>AbstractStringBuilder</code> 实现了 <code>Appendable</code> 接口</p><pre><code>abstract class AbstractStringBuilder implements Appendable, CharSequence {    char[] value;    int count;    public AbstractStringBuilder append(String str) {        if (str == null)            return appendNull();        int len = str.length();        ensureCapacityInternal(count + len);        str.getChars(0, len, value, count);        count += len;        return this;    }    private void ensureCapacityInternal(int minimumCapacity) {        // overflow-conscious code        if (minimumCapacity - value.length &gt; 0) {            value = Arrays.copyOf(value,                    newCapacity(minimumCapacity));        }    }    // ...省略...}</code></pre><p>我们可以看出，<code>Appendable</code> 为抽象建造者，定义了建造方法，<code>StringBuilder</code> 既充当指挥者角色，又充当产品角色，又充当具体建造者，建造方法的实现由 <code>AbstractStringBuilder</code> 完成，而 <code>StringBuilder</code> 继承了 <code>AbstractStringBuilder</code> </p><h4 id="java-lang-StringBuffer-中的建造者方法"><a href="#java-lang-StringBuffer-中的建造者方法" class="headerlink" title="java.lang.StringBuffer 中的建造者方法"></a>java.lang.StringBuffer 中的建造者方法</h4><p>StringBuffer 继承与实现关系如下</p><p><img src="http://image.laijianfeng.org/20180911_173716.png" alt="StringBuffer的类图"></p><p>这分明就与 <code>StringBuilder</code> 一样嘛！</p><p>那它们有什么不同呢？</p><pre><code>public final class StringBuffer extends AbstractStringBuilder implements java.io.Serializable, CharSequence {    @Override    public synchronized StringBuffer append(String str) {        toStringCache = null;        super.append(str);        return this;    }    //...省略...}</code></pre><p>看 <code>StringBuffer</code> 的源码如上，它们的区别就是： <code>StringBuffer</code> 中的 <code>append</code> 加了 <code>synchronized</code> 关键字，所以<code>StringBuffer</code> 是线程安全的，而 <code>StringBuilder</code> 是非线程安全的</p><p><code>StringBuffer</code> 中的建造者模式与 <code>StringBuilder</code> 是一致的</p><h4 id="Google-Guava-中的建造者模式"><a href="#Google-Guava-中的建造者模式" class="headerlink" title="Google Guava 中的建造者模式"></a>Google Guava 中的建造者模式</h4><p><code>ImmutableSet</code> 不可变Set的主要方法如下</p><p><img src="http://image.laijianfeng.org/20180911_234124.png" alt="ImmutableSet方法列表"></p><p><code>ImmutableSet</code> 类中 <code>of</code>, <code>copyOf</code> 等方法返回的是一个 <code>ImmutableSet</code> 对象，这里是一个建造者模式，所构建的复杂产品对象为 <code>ImmutableSet</code></p><p><code>ImmutableSet</code> 的内部类 <code>ImmutableSet.Builder</code> 如下所示</p><pre><code>public static class Builder&lt;E&gt; extends ArrayBasedBuilder&lt;E&gt; {    @CanIgnoreReturnValue    public ImmutableSet.Builder&lt;E&gt; add(E... elements) {        super.add(elements);        return this;    }    @CanIgnoreReturnValue    public ImmutableSet.Builder&lt;E&gt; addAll(Iterator&lt;? extends E&gt; elements) {        super.addAll(elements);        return this;    }    public ImmutableSet&lt;E&gt; build() {        ImmutableSet&lt;E&gt; result = ImmutableSet.construct(this.size, this.contents);        this.size = result.size();        return result;    }    //...省略...}</code></pre><p>其中的 <code>add</code>、<code>addAll</code>等方法返回的是 <code>ImmutableSet.Builder</code> 对象本身，而 <code>build</code> 则返回 <code>ImmutableSet</code> 对象，所以 <code>ImmutableSet.Builder</code> 是具体建造者，<code>add</code>、<code>addAll</code>等方法则相当于<code>buildPartX()</code>，是装配过程中的一部分，<code>build</code> 方法则是 <code>getResult()</code>，返回最终创建好的复杂产品对象</p><p>ImmutableSet 使用示例如下:</p><pre><code>public class Test2 {    public static void main(String[] args) {        Set&lt;String&gt; set = ImmutableSet.&lt;String&gt;builder().add(&quot;a&quot;).add(&quot;a&quot;).add(&quot;b&quot;).build();        System.out.println(set);        // [a, b]    }}</code></pre><p>再来看一个，一般创建一个 <code>guava缓存</code> 的写法如下所示</p><pre><code>final static Cache&lt;Integer, String&gt; cache = CacheBuilder.newBuilder()        //设置cache的初始大小为10，要合理设置该值          .initialCapacity(10)        //设置并发数为5，即同一时间最多只能有5个线程往cache执行写入操作          .concurrencyLevel(5)        //设置cache中的数据在写入之后的存活时间为10秒          .expireAfterWrite(10, TimeUnit.SECONDS)        //构建cache实例          .build();</code></pre><p>这里很明显，我们不用看源码就可以知道这里是一个典型的建造者模式，<code>CacheBuilder.newBuilder()</code> 创建了一个具体建造者，<code>.initialCapacity(10)</code>、<code>.concurrencyLevel(5)</code>、<code>.expireAfterWrite(10, TimeUnit.SECONDS)</code> 则是构建过程，最终的 <code>.build()</code> 返回创建完成的复杂产品对象</p><p>看看源码是不是符合我们的猜测</p><pre><code>public final class CacheBuilder&lt;K, V&gt; {    // 创建一个具体建造者    public static CacheBuilder&lt;Object, Object&gt; newBuilder() {        return new CacheBuilder();    }    // 建造过程之一    public CacheBuilder&lt;K, V&gt; initialCapacity(int initialCapacity) {        Preconditions.checkState(this.initialCapacity == -1, &quot;initial capacity was already set to %s&quot;, this.initialCapacity);        Preconditions.checkArgument(initialCapacity &gt;= 0);        this.initialCapacity = initialCapacity;        return this;    }    // 建造过程之一    public CacheBuilder&lt;K, V&gt; concurrencyLevel(int concurrencyLevel) {        Preconditions.checkState(this.concurrencyLevel == -1, &quot;concurrency level was already set to %s&quot;, this.concurrencyLevel);        Preconditions.checkArgument(concurrencyLevel &gt; 0);        this.concurrencyLevel = concurrencyLevel;        return this;    }    // 建造过程之一    public CacheBuilder&lt;K, V&gt; expireAfterWrite(long duration, TimeUnit unit) {        Preconditions.checkState(this.expireAfterWriteNanos == -1L, &quot;expireAfterWrite was already set to %s ns&quot;, this.expireAfterWriteNanos);        Preconditions.checkArgument(duration &gt;= 0L, &quot;duration cannot be negative: %s %s&quot;, duration, unit);        this.expireAfterWriteNanos = unit.toNanos(duration);        return this;    }    // 建造完成，返回创建完的复杂产品对象    public &lt;K1 extends K, V1 extends V&gt; Cache&lt;K1, V1&gt; build() {        this.checkWeightWithWeigher();        this.checkNonLoadingCache();        return new LocalManualCache(this);    }    // ...省略...}</code></pre><p>很明显符合我们的猜测，<code>initialCapacity()</code>、<code>concurrencyLevel()</code>、<code>expireAfterWrite()</code> 等方法对传进来的参数进行处理和设置，返回 <code>CacheBuilder</code> 对象本身，<code>build</code> 则把 <code>CacheBuilder</code> 对象 作为参数，new 了一个 <code>LocalManualCache</code> 对象返回</p><h4 id="mybatis-中的建造者模式"><a href="#mybatis-中的建造者模式" class="headerlink" title="mybatis 中的建造者模式"></a>mybatis 中的建造者模式</h4><p>我们来看 <code>org.apache.ibatis.session</code> 包下的 <code>SqlSessionFactoryBuilder</code> 类</p><p><img src="http://image.laijianfeng.org/20180912_002707.png" alt="SqlSessionFactoryBuilder的方法"></p><p>里边很多重载的 <code>build</code> 方法，返回值都是 <code>SqlSessionFactory</code>，除了最后两个所有的 <code>build</code> 最后都调用下面这个 <code>build</code> 方法</p><pre><code>    public SqlSessionFactory build(Reader reader, String environment, Properties properties) {        SqlSessionFactory var5;        try {            XMLConfigBuilder parser = new XMLConfigBuilder(reader, environment, properties);            var5 = this.build(parser.parse());        } catch (Exception var14) {            throw ExceptionFactory.wrapException(&quot;Error building SqlSession.&quot;, var14);        } finally {            ErrorContext.instance().reset();            try {                reader.close();            } catch (IOException var13) {                ;            }        }        return var5;    }</code></pre><p>其中最重要的是 <code>XMLConfigBuilder</code> 的 <code>parse</code> 方法，代码如下</p><pre><code>public class XMLConfigBuilder extends BaseBuilder {    public Configuration parse() {        if (this.parsed) {            throw new BuilderException(&quot;Each XMLConfigBuilder can only be used once.&quot;);        } else {            this.parsed = true;            this.parseConfiguration(this.parser.evalNode(&quot;/configuration&quot;));            return this.configuration;        }    }    private void parseConfiguration(XNode root) {        try {            Properties settings = this.settingsAsPropertiess(root.evalNode(&quot;settings&quot;));            this.propertiesElement(root.evalNode(&quot;properties&quot;));            this.loadCustomVfs(settings);            this.typeAliasesElement(root.evalNode(&quot;typeAliases&quot;));            this.pluginElement(root.evalNode(&quot;plugins&quot;));            this.objectFactoryElement(root.evalNode(&quot;objectFactory&quot;));            this.objectWrapperFactoryElement(root.evalNode(&quot;objectWrapperFactory&quot;));            this.reflectorFactoryElement(root.evalNode(&quot;reflectorFactory&quot;));            this.settingsElement(settings);            this.environmentsElement(root.evalNode(&quot;environments&quot;));            this.databaseIdProviderElement(root.evalNode(&quot;databaseIdProvider&quot;));            this.typeHandlerElement(root.evalNode(&quot;typeHandlers&quot;));            this.mapperElement(root.evalNode(&quot;mappers&quot;));        } catch (Exception var3) {            throw new BuilderException(&quot;Error parsing SQL Mapper Configuration. Cause: &quot; + var3, var3);        }    }    // ...省略...}</code></pre><p><code>parse</code> 方法最终要返回一个 <code>Configuration</code> 对象，构建 <code>Configuration</code> 对象的建造过程都在 <code>parseConfiguration</code> 方法中，这也就是 <code>Mybatis</code> 解析 <code>XML配置文件</code> 来构建 <code>Configuration</code> 对象的主要过程</p><p>所以 <code>XMLConfigBuilder</code> 是建造者 <code>SqlSessionFactoryBuilder</code> 中的建造者，复杂产品对象分别是 <code>SqlSessionFactory</code> 和 <code>Configuration</code></p><hr><p>打开微信扫一扫，关注【小旋锋】微信公众号，及时接收博文推送</p><p><img src="http://image.laijianfeng.org/%E5%B0%8F%E6%97%8B%E9%94%8B%E7%9A%84%E5%BE%AE%E4%BF%A1%E5%85%AC%E4%BC%97%E5%8F%B7_%E4%BA%8C%E7%BB%B4%E7%A0%81.jpg" alt="小旋锋的微信公众号"></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h3 id=&quot;建造者模式&quot;&gt;&lt;a href=&quot;#建造者模式&quot; class=&quot;headerlink&quot; title=&quot;建造者模式&quot;&gt;&lt;/a&gt;建造者模式&lt;/h3&gt;&lt;p&gt;建造者模式(Builder Pattern)：将一个复杂对象的构建与它的表示分离，使得同样的构建过程可以创建不同的表
      
    
    </summary>
    
      <category term="后端" scheme="http://laijianfeng.org/categories/%E5%90%8E%E7%AB%AF/"/>
    
    
      <category term="设计模式" scheme="http://laijianfeng.org/tags/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/"/>
    
  </entry>
  
  <entry>
    <title>设计模式 | 抽象工厂模式及典型应用</title>
    <link href="http://laijianfeng.org/2018/09/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F%E4%B9%8B%E6%8A%BD%E8%B1%A1%E5%B7%A5%E5%8E%82%E6%A8%A1%E5%BC%8F%E5%8F%8A%E5%85%B8%E5%9E%8B%E5%BA%94%E7%94%A8/"/>
    <id>http://laijianfeng.org/2018/09/设计模式之抽象工厂模式及典型应用/</id>
    <published>2018-09-10T15:51:05.000Z</published>
    <updated>2018-09-11T07:10:25.650Z</updated>
    
    <content type="html"><![CDATA[<h3 id="抽象工厂模式"><a href="#抽象工厂模式" class="headerlink" title="抽象工厂模式"></a>抽象工厂模式</h3><p>抽象工厂模式(Abstract Factory Pattern)：提供一个创建一系列相关或相互依赖对象的接口，而无须指定它们具体的类。抽象工厂模式又称为Kit模式，它是一种对象创建型模式。</p><p>在抽象工厂模式中，每一个具体工厂都提供了多个工厂方法用于产生多种不同类型的产品。</p><h4 id="角色"><a href="#角色" class="headerlink" title="角色"></a>角色</h4><p>在抽象工厂模式包含如下几个角色：</p><ul><li><strong>AbstractFactory（抽象工厂）</strong>：它声明了一组用于创建一族产品的方法，每一个方法对应一种产品。</li><li><strong>ConcreteFactory（具体工厂）</strong>：它实现了在抽象工厂中声明的创建产品的方法，生成一组具体产品，这些产品构成了一个产品族，每一个产品都位于某个产品等级结构中。</li><li><strong>AbstractProduct（抽象产品）</strong>：它为每种产品声明接口，在抽象产品中声明了产品所具有的业务方法</li><li><strong>ConcreteProduct（具体产品）</strong>：它定义具体工厂生产的具体产品对象，实现抽象产品接口中声明的业务方法。</li></ul><p>在抽象工厂中声明了多个工厂方法，用于创建不同类型的产品，抽象工厂可以是接口，也可以是抽象类或者具体类</p><p>具体工厂实现了抽象工厂，每一个具体的工厂方法可以返回一个特定的产品对象，而同一个具体工厂所创建的产品对象构成了一个产品族</p><h3 id="示例"><a href="#示例" class="headerlink" title="示例"></a>示例</h3><p>首先定义我们的抽象产品 <code>Article</code> 和 <code>Video</code>，他们是产品族的抽象类，有一个 <code>Article</code> 就有一个 <code>Video</code></p><pre><code>public abstract class Article {    public abstract void produce();}public abstract class Video {    public abstract void produce();}</code></pre><p>具体产品 <code>JavaArticle</code>、<code>PythonArticle</code>、<code>PythonVideo</code>、<code>JavaVideo</code></p><pre><code>public class JavaArticle extends Article {    @Override    public void produce() {        System.out.println(&quot;编写Java课程笔记记&quot;);    }}public class PythonArticle extends Article {    @Override    public void produce() {        System.out.println(&quot;编写Python课程笔记&quot;);    }}public class JavaVideo extends Video {    @Override    public void produce() {        System.out.println(&quot;录制Java课程视频&quot;);    }}public class PythonVideo extends Video {    @Override    public void produce() {        System.out.println(&quot;录制Python课程视频&quot;);    }}</code></pre><p>定义我们的抽象工厂 <code>CourseFactory</code>，与工厂方法模式不同，工厂方法模式中一个工厂只生产一个产品，而抽象工厂模式中一个工厂生产一族产品，有多个工厂方法</p><pre><code>public interface CourseFactory {    Video getVideo();    Article getArticle();}</code></pre><p>具体工厂 <code>JavaCourseFactory</code> 和 <code>PythonCourseFactory</code>，它们都继承抽象工厂接口 <code>CourseFactory</code></p><pre><code>public class JavaCourseFactory implements CourseFactory {    @Override    public Video getVideo() {        return new JavaVideo();    }    @Override    public Article getArticle() {        return new JavaArticle();    }}public class PythonCourseFactory implements CourseFactory {    @Override    public Video getVideo() {        return new PythonVideo();    }    @Override    public Article getArticle() {        return new PythonArticle();    }}</code></pre><p>客户端只需要指定具体工厂，就可以获取该工厂生产的一族产品</p><pre><code>public class Test {    public static void main(String[] args) {        CourseFactory courseFactory = new JavaCourseFactory();        Video video = courseFactory.getVideo();        Article article = courseFactory.getArticle();        video.produce();        article.produce();    }}</code></pre><p>输出</p><pre><code>录制Java课程视频编写Java课程笔记</code></pre><p>也可以利用反射机制和配置文件，当需要修改具体工厂的时候就不需要修改客户端代码，只改配置文件即可</p><pre><code>public class Test {    public static void main(String[] args) throws ClassNotFoundException, IllegalAccessException, InstantiationException {        // 从配置文件或数据库等外部渠道获取具体工厂类名        String factoryName = &quot;com.designpattern.JavaCourseFactory&quot;;        // 通过反射机制获取工厂类        Class c = Class.forName(factoryName);        CourseFactory courseFactory = (CourseFactory) c.newInstance();        Video video = courseFactory.getVideo();        Article article = courseFactory.getArticle();        video.produce();        article.produce();    }}</code></pre><p>最终的类图如下所示</p><p><img src="http://image.laijianfeng.org/20180910_231358.png" alt="示例.抽象工厂类图"></p><h3 id="抽象工厂模式总结"><a href="#抽象工厂模式总结" class="headerlink" title="抽象工厂模式总结"></a>抽象工厂模式总结</h3><p>抽象工厂模式的<strong>主要优点</strong>如下：</p><ul><li>抽象工厂模式隔离了具体类的生成，使得客户并不需要知道什么被创建。由于这种隔离，更换一个具体工厂就变得相对容易，所有的具体工厂都实现了抽象工厂中定义的那些公共接口，因此只需改变具体工厂的实例，就可以在某种程度上改变整个软件系统的行为。</li><li>当一个产品族中的多个对象被设计成一起工作时，它能够保证客户端始终只使用同一个产品族中的对象。</li><li>增加新的产品族很方便，无须修改已有系统，符合”开闭原则”。</li></ul><p>抽象工厂模式的<strong>主要缺点</strong>如下：</p><ul><li>增加新的产品等级结构麻烦，需要对原有系统进行较大的修改，甚至需要修改抽象层代码，这显然会带来较大的不便，违背了\”开闭原则”。</li></ul><p><strong>适用场景</strong>：</p><ul><li>一个系统不应当依赖于产品类实例如何被创建、组合和表达的细节，这对于所有类型的工厂模式都是很重要的，用户无须关心对象的创建过程，将对象的创建和使用解耦。</li><li>系统中有多于一个的产品族，而每次只使用其中某一产品族。可以通过配置文件等方式来使得用户可以动态改变产品族，也可以很方便地增加新的产品族。</li><li>属于同一个产品族的产品将在一起使用，这一约束必须在系统的设计中体现出来。同一个产品族中的产品可以是没有任何关系的对象，但是它们都具有一些共同的约束，如同一操作系统下的按钮和文本框，按钮与文本框之间没有直接关系，但它们都是属于某一操作系统的，此时具有一个共同的约束条件：操作系统的类型。</li><li>产品等级结构稳定，设计完成之后，不会向系统中增加新的产品等级结构或者删除已有的产品等级结构。</li></ul><h3 id="抽象工厂模式的典型应用及源码分析"><a href="#抽象工厂模式的典型应用及源码分析" class="headerlink" title="抽象工厂模式的典型应用及源码分析"></a>抽象工厂模式的典型应用及源码分析</h3><p>我们来看 <code>java.sql</code> 包下的 <code>Connection</code> 接口，该接口定义了与特定数据库的连接 <code>Connection</code>，执行 <code>SQL statements</code> 并返回 <code>results</code></p><pre><code>public interface Connection  extends Wrapper, AutoCloseable {    Statement createStatement() throws SQLException;    PreparedStatement prepareStatement(String sql) throws SQLException;    CallableStatement prepareCall(String sql) throws SQLException;    DatabaseMetaData getMetaData() throws SQLException;    Savepoint setSavepoint() throws SQLException;    Clob createClob() throws SQLException;    Blob createBlob() throws SQLException;    SQLXML createSQLXML() throws SQLException;    // ...省略...}</code></pre><p>其中 <code>Statement</code>、<code>PreparedStatement</code>、<code>CallableStatement</code>、<code>DatabaseMetaData</code>、<code>Savepoint</code>、<code>Clob</code>、<code>Blob</code>、<code>SQLXML</code> 等均为接口</p><p>我们来看 <code>Statement</code> 接口</p><pre><code>public interface Statement extends Wrapper, AutoCloseable {    ResultSet executeQuery(String sql) throws SQLException;    int executeUpdate(String sql) throws SQLException;    void close() throws SQLException;    int getMaxFieldSize() throws SQLException;    boolean execute(String sql) throws SQLException;    // ...省略...}</code></pre><p>其中的 <code>ResultSet</code> 又是一个接口</p><pre><code>public interface ResultSet extends Wrapper, AutoCloseable {    boolean next() throws SQLException;    void close() throws SQLException;    boolean wasNull() throws SQLException;    String getString(int columnIndex) throws SQLException;    //...省略...}</code></pre><p>我们可以看一下他们的实现类</p><p><img src="http://image.laijianfeng.org/20180910_234012.png" alt="Connection的实现类"></p><p><img src="http://image.laijianfeng.org/20180910_234051.png" alt="Statement的实现类"></p><p><img src="http://image.laijianfeng.org/20180910_234121.png" alt="ResultSet的实现类"></p><p>可以看出这里边的抽象工厂模式，<code>Connection</code> 为抽象工厂，工厂方法很多，其中一个抽象产品为 <code>Statement</code>，同时 <code>Statement</code> 也是一个抽象工厂，工厂方法也很多，其中一个抽象产品为 <code>ResultSet</code>，具体工厂和具体产品则为他们的实现类</p><blockquote><p>参考：<br>刘伟：设计模式Java版<br>慕课网java设计模式精讲 Debug 方式+内存分析</p></blockquote><hr><p>打开微信扫一扫，关注【小旋锋】微信公众号，及时接收博文推送</p><p><img src="http://image.laijianfeng.org/%E5%B0%8F%E6%97%8B%E9%94%8B%E7%9A%84%E5%BE%AE%E4%BF%A1%E5%85%AC%E4%BC%97%E5%8F%B7_%E4%BA%8C%E7%BB%B4%E7%A0%81.jpg" alt="小旋锋的微信公众号"></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h3 id=&quot;抽象工厂模式&quot;&gt;&lt;a href=&quot;#抽象工厂模式&quot; class=&quot;headerlink&quot; title=&quot;抽象工厂模式&quot;&gt;&lt;/a&gt;抽象工厂模式&lt;/h3&gt;&lt;p&gt;抽象工厂模式(Abstract Factory Pattern)：提供一个创建一系列相关或相互依赖对象的接口
      
    
    </summary>
    
      <category term="后端" scheme="http://laijianfeng.org/categories/%E5%90%8E%E7%AB%AF/"/>
    
    
      <category term="设计模式" scheme="http://laijianfeng.org/tags/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/"/>
    
  </entry>
  
  <entry>
    <title>设计模式 | 工厂方法模式及典型应用</title>
    <link href="http://laijianfeng.org/2018/09/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F%E4%B9%8B%E5%B7%A5%E5%8E%82%E6%96%B9%E6%B3%95%E6%A8%A1%E5%BC%8F%E5%8F%8A%E5%85%B8%E5%9E%8B%E5%BA%94%E7%94%A8/"/>
    <id>http://laijianfeng.org/2018/09/设计模式之工厂方法模式及典型应用/</id>
    <published>2018-09-09T09:20:14.000Z</published>
    <updated>2018-09-09T09:24:06.085Z</updated>
    
    <content type="html"><![CDATA[<h3 id="工厂方法模式"><a href="#工厂方法模式" class="headerlink" title="工厂方法模式"></a>工厂方法模式</h3><p>工厂方法模式(Factory Method Pattern)：定义一个用于创建对象的接口，让子类决定将哪一个类实例化。工厂方法模式让一个类的实例化延迟到其子类。</p><p>工厂方法模式又简称为工厂模式(Factory Pattern)，又可称作虚拟构造器模式(Virtual Constructor Pattern)或多态工厂模式(Polymorphic Factory Pattern)。</p><p>工厂方法模式是一种类创建型模式。</p><h4 id="角色"><a href="#角色" class="headerlink" title="角色"></a>角色</h4><p>在工厂方法模式结构图中包含如下几个角色：</p><p><strong>Product（抽象产品）</strong>：它是定义产品的接口，是工厂方法模式所创建对象的超类型，也就是产品对象的公共父类</p><p><strong>ConcreteProduct（具体产品）</strong>：它实现了抽象产品接口，某种类型的具体产品由专门的具体工厂创建，具体工厂和具体产品之间一一对应。</p><p><strong>Factory（抽象工厂）</strong>：在抽象工厂类中，声明了工厂方法(Factory Method)，用于返回一个产品。抽象工厂是工厂方法模式的核心，所有创建对象的工厂类都必须实现该接口。</p><p><strong>ConcreteFactory（具体工厂）</strong>：它是抽象工厂类的子类，实现了抽象工厂中定义的工厂方法，并可由客户端调用，返回一个具体产品类的实例。</p><p>与简单工厂模式相比，工厂方法模式最重要的区别是引入了抽象工厂角色，抽象工厂可以是接口，也可以是抽象类或者具体类</p><h4 id="示例"><a href="#示例" class="headerlink" title="示例"></a>示例</h4><p>抽象产品类 Video</p><pre><code>public abstract class Video {    public abstract void produce();}</code></pre><p>具体产品类 JavaVideo 和 PythonVideo，需要继承抽象产品类 Video</p><pre><code>public class JavaVideo extends Video {    @Override    public void produce() {        System.out.println(&quot;录制Java课程视频&quot;);    }}public class PythonVideo extends Video {    @Override    public void produce() {        System.out.println(&quot;录制Python课程视频&quot;);    }}</code></pre><p>抽象工厂类 VideoFactory</p><pre><code>public abstract class VideoFactory {    public abstract Video getVideo();}</code></pre><p>具体工厂类 JavaVideoFactory 和 PythonVideoFactory，需要继承抽象工厂类 VideoFactory</p><pre><code>public class JavaVideoFactory extends VideoFactory {    @Override    public Video getVideo() {        return new JavaVideo();    }}public class PythonVideoFactory extends VideoFactory {    @Override    public Video getVideo() {        return new PythonVideo();    }}</code></pre><p>客户端类，需要什么产品则通过该产品对应的工厂类来获取，不需要知道具体的创建过程</p><pre><code>public class Test {    public static void main(String[] args) {        VideoFactory pythonVideoFactory = new PythonVideoFactory();        VideoFactory javaVideoFactory = new JavaVideoFactory();        Video pythonVideo = pythonVideoFactory.getVideo();        pythonVideo.produce();        Video javaVideo = javaVideoFactory.getVideo();        javaVideo.produce();    }}</code></pre><p>输出</p><pre><code>录制Python课程视频录制Java课程视频</code></pre><p>当需要增加一个产品 FEVideo 时，只需要增加 FEVideo 具体产品类和 FEVideoFactory 具体工厂类即可，不需要修改原有的产品类和工厂类</p><pre><code>public class FEVideo extends Video{    @Override    public void produce() {        System.out.println(&quot;录制FE课程视频&quot;);    }}public class FEVideoFactory extends VideoFactory{    @Override    public Video getVideo() {        return new FEVideo();    }}</code></pre><p>修改客户端代码</p><pre><code>public class Test {    public static void main(String[] args) {        VideoFactory feVideoFactory = new FEVideoFactory();        Video feVideo = feVideoFactory.getVideo();        feVideo.produce();    }}</code></pre><p>还可以通过反射机制和配置文件配合，连客户端代码都不需要修改</p><pre><code>public class Test {    public static void main(String[] args) throws ClassNotFoundException, IllegalAccessException, InstantiationException {        // 从文件或数据库等外部渠道获取 工厂类名        String factoryName = &quot;com.designpattern.factorymethod.JavaVideoFactory&quot;;        // 通过反射机制获取工厂类        Class c = Class.forName(factoryName);        VideoFactory factory = (VideoFactory)c.newInstance();        // 生产产品        Video video = factory.getVideo();        video.produce();    }}</code></pre><p>最终的类图如下所示</p><p><img src="http://image.laijianfeng.org/20180908_223324.png" alt="示例.工厂方法结构图"></p><h3 id="工厂方法模式总结"><a href="#工厂方法模式总结" class="headerlink" title="工厂方法模式总结"></a>工厂方法模式总结</h3><p>工厂方法模式是简单工厂模式的延伸，它继承了简单工厂模式的优点，同时还弥补了简单工厂模式的不足。工厂方法模式是使用频率最高的设计模式之一，是很多开源框架和API类库的核心模式。</p><h4 id="工厂方法模式的主要优点"><a href="#工厂方法模式的主要优点" class="headerlink" title="工厂方法模式的主要优点"></a>工厂方法模式的主要优点</h4><ul><li>在工厂方法模式中，工厂方法用来创建客户所需要的产品，同时还向客户隐藏了哪种具体产品类将被实例化这一细节，用户只需要关心所需产品对应的工厂，无须关心创建细节，甚至无须知道具体产品类的类名。</li><li>基于工厂角色和产品角色的多态性设计是工厂方法模式的关键。它能够让工厂可以自主确定创建何种产品对象，而如何创建这个对象的细节则完全封装在具体工厂内部。工厂方法模式之所以又被称为多态工厂模式，就正是因为所有的具体工厂类都具有同一抽象父类。</li><li>使用工厂方法模式的另一个优点是在系统中加入新产品时，无须修改抽象工厂和抽象产品提供的接口，无须修改客户端，也无须修改其他的具体工厂和具体产品，而只要添加一个具体工厂和具体产品就可以了，这样，系统的可扩展性也就变得非常好，完全符合”开闭原则”。</li></ul><h4 id="工厂方法模式的主要缺点"><a href="#工厂方法模式的主要缺点" class="headerlink" title="工厂方法模式的主要缺点"></a>工厂方法模式的主要缺点</h4><ul><li>在添加新产品时，需要编写新的具体产品类，而且还要提供与之对应的具体工厂类，系统中类的个数将成对增加，在一定程度上增加了系统的复杂度，有更多的类需要编译和运行，会给系统带来一些额外的开销。</li><li>由于考虑到系统的可扩展性，需要引入抽象层，在客户端代码中均使用抽象层进行定义，增加了系统的抽象性和理解难度，且在实现时可能需要用到DOM、反射等技术，增加了系统的实现难度。</li></ul><h4 id="适用场景"><a href="#适用场景" class="headerlink" title="适用场景"></a>适用场景</h4><ul><li>客户端不知道它所需要的对象的类。在工厂方法模式中，客户端不需要知道具体产品类的类名，只需要知道所对应的工厂即可，具体的产品对象由具体工厂类创建，可将具体工厂类的类名存储在配置文件或数据库中。</li><li>抽象工厂类通过其子类来指定创建哪个对象。在工厂方法模式中，对于抽象工厂类只需要提供一个创建产品的接口，而由其子类来确定具体要创建的对象，利用面向对象的多态性和里氏代换原则，在程序运行时，子类对象将覆盖父类对象，从而使得系统更容易扩展。</li></ul><h3 id="工厂方法模式的典型应用及源码分析"><a href="#工厂方法模式的典型应用及源码分析" class="headerlink" title="工厂方法模式的典型应用及源码分析"></a>工厂方法模式的典型应用及源码分析</h3><h4 id="Java集合接口-Collection-中的工厂方法模式"><a href="#Java集合接口-Collection-中的工厂方法模式" class="headerlink" title="Java集合接口 Collection 中的工厂方法模式"></a>Java集合接口 Collection 中的工厂方法模式</h4><p>Collection 中的 iterator 方法如下：</p><pre><code>public interface Collection&lt;E&gt; extends Iterable&lt;E&gt; {    Iterator&lt;E&gt; iterator();    // ...省略}</code></pre><blockquote><p>关于 iterator 方法的介绍：<br>Java的迭代器只在Collection中有，而Map没有迭代器，它有不同的迭代方法；<br> <strong>迭代器的终极目标</strong>：就是用统一的方法来迭代不同类型的集合！可能由于不同集合的内部数据结构不尽相同，如果要自己纯手工迭代的话相互之间会有很大的差别，而迭代器的作用就是统一的方法对不同的集合进行迭代，而在迭代器底层隐藏不同集合之间的差异，从而为迭代提供最大的方便<br><strong>使用用迭代器迭代的步骤</strong>： i. 第一步肯定是先获取集合的迭代器：调用集合的iterator方法就能获得，Iterator<e> Collection.iterator(); ii. 使用迭代器的hasNext、next往下迭代<br><strong>Iterator的常用方法</strong>：boolean hasNext()：是否还有下一个元素； Object next()：取出下一个元素并返回； void remove(); ：从容器中删除当前元素，直接会改变容器中的数据</e></p></blockquote><p>查看该接口的实现类，可以看到是非常的多</p><p><img src="http://image.laijianfeng.org/20180908_230822.png" alt="Collection接口的实现类(部分)"></p><p>我们仅看其中一个实现类 <code>java.util.ArrayList</code>，看其对 <code>iterator</code> 方法的实现</p><pre><code>public Iterator&lt;E&gt; iterator() {    return new Itr();}/** * An optimized version of AbstractList.Itr */private class Itr implements Iterator&lt;E&gt; {    int cursor;       // index of next element to return    int lastRet = -1; // index of last element returned; -1 if no such    int expectedModCount = modCount;    Itr() {}    public boolean hasNext() {        return cursor != size;    }    @SuppressWarnings(&quot;unchecked&quot;)    public E next() {        // ...省略...    }    public void remove() {        // ...省略...    }    @Override    @SuppressWarnings(&quot;unchecked&quot;)    public void forEachRemaining(Consumer&lt;? super E&gt; consumer) {        // ...省略...    }    final void checkForComodification() {        // ...省略...    }}</code></pre><p><code>Itr</code> 类实现了 <code>iterator</code> 接口，<code>iterator</code> 接口正是 <code>Collection</code> 接口中 <code>iterator</code> 方法的返回类型，其代码如下：</p><pre><code>public interface Iterator&lt;E&gt; {    boolean hasNext();    E next();    default void remove() {        throw new UnsupportedOperationException(&quot;remove&quot;);    }    default void forEachRemaining(Consumer&lt;? super E&gt; action) {        Objects.requireNonNull(action);        while (hasNext())            action.accept(next());    }}</code></pre><p><strong>由此可见</strong>，<code>Collection</code> 接口扮演了抽象工厂角色，工厂方法为 <code>iterator()</code>，<code>Collection</code> 的实现类譬如 <code>ArrayList</code> 扮演了具体工厂角色，而抽象产品为 <code>Iterator</code> 接口，具体产品为 <code>Itr</code> 类</p><h4 id="java-net-网络包中的工厂方法模式"><a href="#java-net-网络包中的工厂方法模式" class="headerlink" title="java.net 网络包中的工厂方法模式"></a>java.net 网络包中的工厂方法模式</h4><p>URLStreamHandlerFactory 接口为 URL 流协议处理程序定义一个工厂。URL 类使用它可为特定的协议创建 URLStreamHandler</p><pre><code>public interface URLStreamHandlerFactory {    /**     * Creates a new {@code URLStreamHandler} instance with the specified protocol.     *     * @param   protocol   the protocol (&quot;{@code ftp}&quot;, &quot;{@code http}&quot;, &quot;{@code nntp}&quot;, etc.).     * @return  a {@code URLStreamHandler} for the specific protocol.     * @see     java.net.URLStreamHandler     */    URLStreamHandler createURLStreamHandler(String protocol);}</code></pre><p>该接口的实现类为 <code>sun.misc.Launcher</code> 中的内部类 <code>Factory</code></p><pre><code>private static class Factory implements URLStreamHandlerFactory {    private static String PREFIX = &quot;sun.net.www.protocol&quot;;    private Factory() {    }    public URLStreamHandler createURLStreamHandler(String var1) {        String var2 = PREFIX + &quot;.&quot; + var1 + &quot;.Handler&quot;;        try {            Class var3 = Class.forName(var2);            return (URLStreamHandler)var3.newInstance();        } catch (ReflectiveOperationException var4) {            throw new InternalError(&quot;could not load &quot; + var1 + &quot;system protocol handler&quot;, var4);        }    }}</code></pre><p>可以看到 <code>createURLStreamHandler</code> 方法的实现为：传入参数，拼接前缀和后缀，之后通过反射机制获取创建一个 <code>URLStreamHandler</code> 对象</p><p><code>URLStreamHandler</code> 是一个抽象类，其中的方法如下图，只有 <code>openConnection</code> 为抽象方法，其他方法均有具体实现</p><p><img src="http://image.laijianfeng.org/20180908_235350.png" alt="URLStreamHandler抽象类中的方法"></p><blockquote><p>关于URLStreamHandler:<br>抽象类URLStreamHandler是所有流协议处理程序的通用超类。 流协议处理程序知道如何为特定协议类型建立连接，例如http或https</p></blockquote><p>其子类有如下(19个)：</p><p><img src="http://image.laijianfeng.org/20180908_234100.png" alt="URLStreamHandler的子类"></p><p>查看其中一个子类譬如 <code>sun.net.www.protocol.http.Handler</code></p><pre><code>public class Handler extends URLStreamHandler {    protected String proxy;    protected int proxyPort;    protected int getDefaultPort() {        return 80;    }    public Handler() {        this.proxy = null;        this.proxyPort = -1;    }    public Handler(String var1, int var2) {        this.proxy = var1;        this.proxyPort = var2;    }    protected URLConnection openConnection(URL var1) throws IOException {        return this.openConnection(var1, (Proxy)null);    }    protected URLConnection openConnection(URL var1, Proxy var2) throws IOException {        return new HttpURLConnection(var1, var2, this);    }}</code></pre><p>该类实现的 <code>openConnection</code> 方法的返回值类型为 <code>URLConnection</code>，最终返回了一个 <code>HttpURLConnection</code> 对象</p><p>我们又继续看 <code>java.net.URLConnection</code>，这也是一个抽象类</p><p><img src="http://image.laijianfeng.org/20180909_001513.png" alt="image"></p><blockquote><p><strong>URLConnection介绍</strong>：   </p><ul><li>URLConnection是一个功能强大的抽象类，它表示指向URL指定资源的活动连接。<br>与URL类相比，它与服务器的交互提供了更多的控制机制。尤其服务器是HTTP服务器，可以使用URLConnection对HTTP首部的访问，可以配置发送给服务器的请求参数。当然也可以通过它读取服务器的数据以及向服务器写入数据.   </li><li>URLConnection是Java的协议处理器机制的一部分。协议处理器机制是将处理协议的细节与特定数据类型分开。如果要实现一个特定的协议，则实现URLConnection的子类即可。程序运行时可以将该子类作为一个具体的协议处理器来使用。   </li><li><strong>使用URLConnection类的步骤</strong>：1.  构造一个URL对象；2. 调用该URL的openConnection()获取一个URLConnection；3. 配置这个URLConnection；4. 读取首部字段；5. 获得输入流并读取数据；6. 获得输出流并写入数据；7. 关闭连接</li></ul></blockquote><p>其子类有23个</p><p><img src="http://image.laijianfeng.org/20180909_001308.png" alt="image"></p><p>我们可以画出他们的关系图如下所示</p><p><img src="http://image.laijianfeng.org/20180909_164345.png" alt="URLConnection关系图"></p><p><strong>由此可知</strong>：抽象工厂角色为 <code>URLStreamHandlerFactory</code>，工厂方法为 <code>createURLStreamHandler</code>，抽象产品角色为 <code>URLStreamHandler</code>，具体产品角色为 <code>URLStreamHandler</code> 的子类譬如 <code>sun.net.www.protocol.http.Handler</code>、<code>sun.net.www.protocol.ftp.Handler</code> 等</p><p><strong>同时</strong>，<code>URLStreamHandler</code> 也扮演了抽象工厂角色，工厂方法为 <code>openConnection</code>，<code>URLStreamHandler</code> 的子类譬如 <code>sun.net.www.protocol.http.Handler</code> 也扮演了具体工厂角色，抽象产品为 <code>URLConnection</code>，具体产品角色为  <code>URLConnection</code> 的子类如 <code>sun.net.www.protocol.http.HttpURLConnection</code> 等</p><h4 id="Logback-中的工厂方法模式"><a href="#Logback-中的工厂方法模式" class="headerlink" title="Logback 中的工厂方法模式"></a>Logback 中的工厂方法模式</h4><p>在上一篇文章《<a href="https://mp.weixin.qq.com/s?__biz=MzI1NDU0MTE1NA==&amp;mid=2247483700&amp;idx=1&amp;sn=dd4d23f9400c8be248f5d125465ba941&amp;chksm=e9c2ed39deb5642fb809eca1351f00995f06c9a4875f09986cc5005059eff74d6c20fc1118a3&amp;scene=0#rd" target="_blank" rel="noopener">设计模式 | 简单工厂模式及典型应用</a>》 介绍的 Logback 里有简单工厂模式，其实也有工厂方法模式，画图如下</p><p><img src="http://image.laijianfeng.org/20180909_170301.png" alt="iLoggerFactory类关系"></p><p><strong>可以看出</strong>，抽象工厂角色为 <code>ILoggerFactory</code> 接口，工厂方法为 <code>getLogger</code>，具体工厂角色为 <code>LoggerContext</code>、<code>NOPLoggerFactory</code>、<code>SubstituteLoggerFactory</code> 等，抽象产品角色为 <code>Logger</code>，具体产品角色为 <code>Logger</code> 的实现类如下</p><p><img src="http://image.laijianfeng.org/20180909_171112.png" alt="Logger 的实现类"></p><p>而简单工厂模式应用在 <code>LoggerContext</code> 的  <code>getLogger</code> 方法中，根据参数返回相应的 <code>Logger</code> 对象</p><blockquote><p>参考：<br>刘伟：设计模式Java版<br>慕课网java设计模式精讲 Debug 方式+内存分析</p></blockquote><hr><p>打开微信扫一扫，关注【小旋锋】微信公众号，及时接收博文推送</p><p><img src="http://image.laijianfeng.org/%E5%B0%8F%E6%97%8B%E9%94%8B%E7%9A%84%E5%BE%AE%E4%BF%A1%E5%85%AC%E4%BC%97%E5%8F%B7_%E4%BA%8C%E7%BB%B4%E7%A0%81.jpg" alt="小旋锋的微信公众号"></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h3 id=&quot;工厂方法模式&quot;&gt;&lt;a href=&quot;#工厂方法模式&quot; class=&quot;headerlink&quot; title=&quot;工厂方法模式&quot;&gt;&lt;/a&gt;工厂方法模式&lt;/h3&gt;&lt;p&gt;工厂方法模式(Factory Method Pattern)：定义一个用于创建对象的接口，让子类决定将哪一个
      
    
    </summary>
    
      <category term="后端" scheme="http://laijianfeng.org/categories/%E5%90%8E%E7%AB%AF/"/>
    
    
      <category term="设计模式" scheme="http://laijianfeng.org/tags/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/"/>
    
  </entry>
  
  <entry>
    <title>设计模式 | 简单工厂模式及典型应用</title>
    <link href="http://laijianfeng.org/2018/09/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F-%E7%AE%80%E5%8D%95%E5%B7%A5%E5%8E%82%E6%A8%A1%E5%BC%8F%E5%8F%8A%E5%85%B8%E5%9E%8B%E5%BA%94%E7%94%A8/"/>
    <id>http://laijianfeng.org/2018/09/设计模式-简单工厂模式及典型应用/</id>
    <published>2018-09-07T15:13:45.000Z</published>
    <updated>2018-09-07T15:14:50.320Z</updated>
    
    <content type="html"><![CDATA[<h3 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h3><p>设计模式(Design Pattern)是一套被反复使用、多数人知晓的、经过分类编目的、代码设计经验的总结，使用设计模式是为了可重用代码、让代码更容易被他人<br>理解并且保证代码可靠性。</p><p>本文主要介绍简单工厂模式及典型应用，内容如下：</p><ul><li>简单工厂模式的介绍</li><li>简单工厂模式的典型应用及源码分析<ul><li>Calendar 类获取日历类对象</li><li>JDBC 获取数据库连接</li><li>LoggerFactory 获取 Logger 对象</li></ul></li></ul><h3 id="简单工厂模式"><a href="#简单工厂模式" class="headerlink" title="简单工厂模式"></a>简单工厂模式</h3><p>工厂模式是最常用的一类创建型设计模式，包括 抽象工厂模式，工厂方法模式和简单工厂模式 这三种，简单工厂模式是其中最简单的一种</p><p>简单工厂模式(Simple Factory Pattern)：定义一个工厂类，它可以<strong>根据参数的不同</strong>返回不同类的实例，被创建的实例通常都具有共同的父类。</p><p>因为在简单工厂模式中用于创建实例的方法是静态(static)方法，因此简单工厂模式又被称为静态工厂方法(Static Factory Method)模式，它属于类创建型模式，但不属于GOF23种设计模式</p><h4 id="角色"><a href="#角色" class="headerlink" title="角色"></a>角色</h4><p><strong>Factory（工厂角色）</strong>：工厂角色即工厂类，它是<strong>简单工厂模式的核心</strong>，负责实现创建所有产品实例的内部逻辑；工厂类可以被外界直接调用，创建所需的产品对象；在工厂类中提供了静态的工厂方法factoryMethod()，它的返回类型为抽象产品类型Product</p><p><strong>Product（抽象产品角色）</strong>：它是工厂类所创建的所有对象的父类，封装了各种产品对象的公有方法，它的引入将提高系统的灵活性，使得在工厂类中只需定义一个通用的工厂方法，因为所有创建的具体产品对象都是其子类对象。</p><p><strong>ConcreteProduct（具体产品角色）</strong>：它是简单工厂模式的创建目标，所有被创建的对象都充当这个角色的某个具体类的实例。每一个具体产品角色都继承了抽象产品角色，需要实现在抽象产品中声明的抽象方法</p><p>在简单工厂模式中，客户端通过工厂类来创建一个产品类的实例，而无须直接使用new关键字来创建对象，它是工厂模式家族中最简单的一员</p><h4 id="示例"><a href="#示例" class="headerlink" title="示例"></a>示例</h4><p>抽象产品类 Video，定义了抽象方法 produce()</p><pre><code>public abstract class Video {    public abstract void produce();}</code></pre><p>具体产品类 JavaVideo 和 PythonVideo，都继承了抽象产品类 Video</p><pre><code>public class JavaVideo extends Video {    @Override    public void produce() {        System.out.println(&quot;录制Java课程视频&quot;);    }}public class PythonVideo extends Video {    @Override    public void produce() {        System.out.println(&quot;录制Python课程视频&quot;);    }}</code></pre><p>工厂类实现的两种方法：使用<code>if-else</code>判断和使用反射来创建对象</p><pre><code>public class VideoFactory {    /**     * 使用if else 判断类型，type 为 Java 则返回 JavaVideo， type为Python则返回 PythonVideo     */    public Video getVideo(String type) {        if (&quot;java&quot;.equalsIgnoreCase(type)) {            return new JavaVideo();        } else if (&quot;python&quot;.equalsIgnoreCase(type)) {            return new PythonVideo();        }        return null;    }    /**     * 使用反射来创建对象     */    public Video getVideo(Class c) {        Video video = null;        try {            video = (Video) Class.forName(c.getName()).newInstance();        } catch (InstantiationException e) {            e.printStackTrace();        } catch (IllegalAccessException e) {            e.printStackTrace();        } catch (ClassNotFoundException e) {            e.printStackTrace();        }        return video;    }}</code></pre><p>使用一个客户端来调用工厂类</p><pre><code>public class Test {    public static void main(String[] args) {        VideoFactory videoFactory = new VideoFactory();        Video video1 = videoFactory.getVideo(&quot;python&quot;);        if (video1 == null) {            return;        }        video1.produce();        Video video2 = videoFactory.getVideo(JavaVideo.class);        if (video2 == null) {            return;        }        video2.produce();    }}</code></pre><p>输出</p><pre><code>录制Python课程视频录制Java课程视频</code></pre><p><img src="http://image.laijianfeng.org/20180907_211234.png" alt="示例.简单工厂模式类图"></p><p>Test 类通过传递参数给 <code>VideoFactory.getVideo()</code> 来获取对象，创建对象的逻辑交给了工厂类 <code>VideoFactory</code> 来完成</p><h4 id="简单工厂模式总结"><a href="#简单工厂模式总结" class="headerlink" title="简单工厂模式总结"></a>简单工厂模式总结</h4><p>简单工厂模式的<strong>主要优点</strong>如下：</p><ul><li>工厂类包含必要的判断逻辑，可以决定在什么时候创建哪一个产品类的实例，客户端可以免除直接创建产品对象的职责，而仅仅“消费”产品，简单工厂模式实现了对象创建和使用的分离。</li><li>客户端无须知道所创建的具体产品类的类名，只需要知道具体产品类所对应的参数即可，对于一些复杂的类名，通过简单工厂模式可以在一定程度减少使用者的记忆量。</li><li>通过引入配置文件，可以在不修改任何客户端代码的情况下更换和增加新的具体产品类，在一定程度上提高了系统的灵活性。</li></ul><p>简单工厂模式的<strong>主要缺点</strong>如下：</p><ul><li>由于工厂类集中了所有产品的创建逻辑，职责过重，一旦不能正常工作，整个系统都要受到影响。</li><li>使用简单工厂模式势必会增加系统中类的个数（引入了新的工厂类），增加了系统的复杂度和理解难度。</li><li>系统扩展困难，一旦添加新产品就不得不修改工厂逻辑，在产品类型较多时，有可能造成工厂逻辑过于复杂，不利于系统的扩展和维护，且违背开闭原则。</li><li>简单工厂模式由于使用了静态工厂方法，造成工厂角色无法形成基于继承的等级结构。</li></ul><p><strong>适用场景</strong>：</p><ul><li>工厂类负责创建的对象比较少，由于创建的对象较少，不会造成工厂方法中的业务逻辑太过复杂。</li><li>客户端只知道传入工厂类的参数，对于如何创建对象并不关心。</li></ul><h3 id="简单工厂模式的典型应用及源码分析"><a href="#简单工厂模式的典型应用及源码分析" class="headerlink" title="简单工厂模式的典型应用及源码分析"></a>简单工厂模式的典型应用及源码分析</h3><h4 id="Calendar-类获取日历类对象"><a href="#Calendar-类获取日历类对象" class="headerlink" title="Calendar 类获取日历类对象"></a>Calendar 类获取日历类对象</h4><p><code>Calendar</code> 抽象类，该类的子类有 <code>BuddhistCalendar</code>、<code>JapaneseImperialCalendar</code>、<code>GregorianCalendar</code>、<code>RollingCalendar</code>等</p><p><code>getInstance</code>方法，根据参数获取一个<code>Calendar</code>子类对象，该方法实际将参数传给 <code>createCalendar</code> 方法，<code>createCalendar</code> 在根据参数通过 <code>provider</code> 或 <code>switch</code> 或者 <code>if-else</code> 创建相应的子类对象</p><p>以下为 Java8 中的 <code>Calendar</code> 类代码，Java7 中的实现为 <code>if-else</code> 方式</p><pre><code>public static Calendar getInstance(TimeZone zone, Locale aLocale) {    return createCalendar(zone, aLocale);}private static Calendar createCalendar(TimeZone zone, Locale aLocale) {    CalendarProvider provider = LocaleProviderAdapter.getAdapter(CalendarProvider.class, aLocale).getCalendarProvider();    if (provider != null) {        try {            return provider.getInstance(zone, aLocale);        } catch (IllegalArgumentException iae) {        }    }    Calendar cal = null;    if (aLocale.hasExtensions()) {        String caltype = aLocale.getUnicodeLocaleType(&quot;ca&quot;);        if (caltype != null) {            switch (caltype) {                case &quot;buddhist&quot;:                    cal = new BuddhistCalendar(zone, aLocale); break;                case &quot;japanese&quot;:                    cal = new JapaneseImperialCalendar(zone, aLocale); break;                case &quot;gregory&quot;:                    cal = new GregorianCalendar(zone, aLocale); break;            }        }    }    if (cal == null) {        if (aLocale.getLanguage() == &quot;th&quot; &amp;&amp; aLocale.getCountry() == &quot;TH&quot;) {            cal = new BuddhistCalendar(zone, aLocale);        } else if (aLocale.getVariant() == &quot;JP&quot; &amp;&amp; aLocale.getLanguage() == &quot;ja&quot; &amp;&amp; aLocale.getCountry() == &quot;JP&quot;) {            cal = new JapaneseImperialCalendar(zone, aLocale);        } else {            cal = new GregorianCalendar(zone, aLocale);        }    }    return cal;}</code></pre><p><img src="http://image.laijianfeng.org/20180907_213426.png" alt="Calendar的继承关系"></p><p>可以看到<code>抽象产品角色</code>和<code>工厂角色</code>都由  <code>Calendar</code> 担任，<code>具体产品角色</code>由 <code>Calendar</code> 的子类担任</p><h4 id="JDBC-获取数据库连接"><a href="#JDBC-获取数据库连接" class="headerlink" title="JDBC 获取数据库连接"></a>JDBC 获取数据库连接</h4><p>一般JDBC获取MySQL连接的写法如下：</p><pre><code>//加载MySql驱动Class.forName(&quot;com.mysql.jdbc.Driver&quot;);DriverManager.getConnection(&quot;jdbc:mysql://127.0.0.1:3306/test&quot;, &quot;root&quot;, &quot;123456&quot;);</code></pre><p>首先通过反射加载驱动类 <code>com.mysql.jdbc.Driver</code> 类，然后再通过 <code>DriverManager</code> 获取连接</p><p>看看 <code>com.mysql.jdbc.Driver</code> 的代码，该类主要的内容是静态代码块，其会随着类的加载一块执行</p><pre><code>public class Driver extends NonRegisteringDriver implements java.sql.Driver {    public Driver() throws SQLException {    }    static {        try {            DriverManager.registerDriver(new Driver());        } catch (SQLException var1) {            throw new RuntimeException(&quot;Can&#39;t register driver!&quot;);        }    }}</code></pre><p>静态代码块：new 一个 <code>Driver</code> 类并注册到 <code>DriverManager</code> 驱动管理类中</p><pre><code>public static synchronized void registerDriver(java.sql.Driver driver, DriverAction da) throws SQLException {    /* Register the driver if it has not already been added to our list */    if(driver != null) {        registeredDrivers.addIfAbsent(new DriverInfo(driver, da));    } else {        throw new NullPointerException();    }    println(&quot;registerDriver: &quot; + driver);}</code></pre><p>其中的 <code>registeredDrivers</code> 是一个 <code>CopyOnWriteArrayList</code> 对象</p><pre><code>private final static CopyOnWriteArrayList&lt;DriverInfo&gt; registeredDrivers = new CopyOnWriteArrayList&lt;&gt;();</code></pre><blockquote><p>CopyOnWriteArrayList是Java并发包中提供的一个并发容器，它是个线程安全且读操作无锁的ArrayList，写操作则通过创建底层数组的新副本来实现，是一种读写分离的并发策略，我们也可以称这种容器为”写时复制器”，Java并发包中类似的容器还有CopyOnWriteSet<br>一篇CopyOnWriteArrayList的文章：<a href="https://www.cnblogs.com/chengxiao/p/6881974.html" target="_blank" rel="noopener">https://www.cnblogs.com/chengxiao/p/6881974.html</a></p></blockquote><p>再通过 <code>DriverManager.getConnection</code> 获取连接对象的主要代码如下：通过for循环从已注册的驱动中(registeredDrivers)获取驱动，尝试连接，成功则返回连接</p><pre><code>private static Connection getConnection(String url, java.util.Properties info, Class&lt;?&gt; caller) throws SQLException {    // ...省略...    println(&quot;DriverManager.getConnection(\&quot;&quot; + url + &quot;\&quot;)&quot;);    for(DriverInfo aDriver : registeredDrivers) {        // If the caller does not have permission to load the driver then skip it.        if(isDriverAllowed(aDriver.driver, callerCL)) {            try {                println(&quot;    trying &quot; + aDriver.driver.getClass().getName());                Connection con = aDriver.driver.connect(url, info);                if (con != null) {                    // Success!                    println(&quot;getConnection returning &quot; + aDriver.driver.getClass().getName());                    return (con);                }            } catch (SQLException ex) {                if (reason == null) {                    reason = ex;                }            }        } else {            println(&quot;    skipping: &quot; + aDriver.getClass().getName());        }    }    // ...省略...}</code></pre><p><img src="http://image.laijianfeng.org/20180907_225826.png" alt="Connection 接口及子类实现关系"></p><p>工厂角色为 <code>DriverManager</code> 类，抽象产品角色为 <code>Connection</code>，具体产品角色则很多</p><h4 id="Logback-中的-LoggerFactory-获取-Logger-对象"><a href="#Logback-中的-LoggerFactory-获取-Logger-对象" class="headerlink" title="Logback 中的 LoggerFactory 获取 Logger 对象"></a>Logback 中的 LoggerFactory 获取 Logger 对象</h4><p>查看 <code>LoggerFactory</code> 类的 <code>getLogger</code> 方法，可看到调用了 <code>iLoggerFactory.getLogger()</code>，其中 <code>iLoggerFactory</code> 是一个接口</p><pre><code>public static Logger getLogger(String name) {    ILoggerFactory iLoggerFactory = getILoggerFactory();    return iLoggerFactory.getLogger(name);}public static Logger getLogger(Class clazz) {    return getLogger(clazz.getName());}</code></pre><p><code>iLoggerFactory</code> 接口只有一个 <code>getLogger</code> 方法</p><pre><code>public interface ILoggerFactory {    Logger getLogger(String var1);}</code></pre><p>查看其子类依赖关系</p><p><img src="http://image.laijianfeng.org/20180907_223038.png" alt="iLoggerFactory接口子类的依赖关系"></p><p>再看一个子类 <code>LoggerContext</code> 对 ILoggerFactory 的实现</p><p><img src="http://image.laijianfeng.org/20180907_222610.png" alt="image"></p><p>可看到这是通过 <code>if-else</code> 方式的简单工厂模式</p><p><img src="http://image.laijianfeng.org/20180907_230131.png" alt="Logger 接口及子类实现关系"></p><p>工厂角色为 <code>iLoggerFactory</code> 接口的子类如 <code>LoggerContext</code>，抽象产品角色为 <code>Logger</code>，具体产品角色为 <code>Logger</code> 的子类，主要是 <code>NOPLogger</code> 和 <code>Logger</code> 类</p><h3 id="小结"><a href="#小结" class="headerlink" title="小结"></a>小结</h3><p>下一篇介绍工厂方法及典型应用</p><blockquote><p>参考：<br>刘伟：设计模式Java版<br>慕课网java设计模式精讲 Debug 方式+内存分析</p></blockquote><hr><p>打开微信扫一扫，关注【小旋锋】微信公众号，及时接收博文推送</p><p><img src="http://image.laijianfeng.org/%E5%B0%8F%E6%97%8B%E9%94%8B%E7%9A%84%E5%BE%AE%E4%BF%A1%E5%85%AC%E4%BC%97%E5%8F%B7_%E4%BA%8C%E7%BB%B4%E7%A0%81.jpg" alt="小旋锋的微信公众号"></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h3 id=&quot;前言&quot;&gt;&lt;a href=&quot;#前言&quot; class=&quot;headerlink&quot; title=&quot;前言&quot;&gt;&lt;/a&gt;前言&lt;/h3&gt;&lt;p&gt;设计模式(Design Pattern)是一套被反复使用、多数人知晓的、经过分类编目的、代码设计经验的总结，使用设计模式是为了可重用代码、让
      
    
    </summary>
    
      <category term="后端" scheme="http://laijianfeng.org/categories/%E5%90%8E%E7%AB%AF/"/>
    
    
      <category term="设计模式" scheme="http://laijianfeng.org/tags/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/"/>
    
  </entry>
  
  <entry>
    <title>Elasticsearch 6.3.2 启动过程</title>
    <link href="http://laijianfeng.org/2018/09/Elasticsearch-6-3-2-%E5%90%AF%E5%8A%A8%E8%BF%87%E7%A8%8B/"/>
    <id>http://laijianfeng.org/2018/09/Elasticsearch-6-3-2-启动过程/</id>
    <published>2018-09-01T12:25:45.000Z</published>
    <updated>2018-09-01T12:29:11.559Z</updated>
    
    <content type="html"><![CDATA[<h3 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h3><p>本文探究Elasticsearch 6.3.2的启动流程</p><h4 id="环境准备"><a href="#环境准备" class="headerlink" title="环境准备"></a>环境准备</h4><p>使用工具：IDEA，XMind</p><p>关于ES调试环境的搭建，可以参考前面的文章 《<a href="https://mp.weixin.qq.com/s?__biz=MzI1NDU0MTE1NA==&amp;mid=2247483676&amp;idx=1&amp;sn=1d88a883ce21d7dcacd073a8fa85dbfc&amp;chksm=e9c2ed11deb56407879ba0b22a4ef96916f8a9e7931e1efb99df57991966a3dc475eb3e23101&amp;mpshare=1&amp;scene=1&amp;srcid=0901DM6ZqcQqSqyujfIApsDj#rd" target="_blank" rel="noopener">教你编译调试Elasticsearch 6.3.2源码</a>》</p><p>然后通过设置断点，从 <code>org.elasticsearch.bootstrap.ElasticSearch</code> 的入口函数开始，一步一步调试</p><p><img src="http://image.laijianfeng.org/20180901_131938.png" alt="IDEA 2018.2 调试按钮"></p><p>上图为使用 IDEA 2018.2 进行调试的一个截图，左上角84行出红点为一个断点，1、2、3编号的3个按钮是较为常用的按钮，作用如下：</p><ul><li>按钮1：step over，执行到下一行，遇到方法<strong>不进入</strong>方法内部</li><li>按钮2：step into，执行到下一句代码，遇到方法则<strong>进入</strong>方法内部</li><li>按钮3：Run to cursor，执行到下一个断点处，后面没有断点则执行到结束</li></ul><h4 id="通过XMind记录ES启动流程的整个过程"><a href="#通过XMind记录ES启动流程的整个过程" class="headerlink" title="通过XMind记录ES启动流程的整个过程"></a>通过XMind记录ES启动流程的整个过程</h4><p><img src="http://image.laijianfeng.org/ES_startup_process.jpg" alt="ES 6.3.2 启动流程"></p><p>根据上图，作者大概地把ES启动流程分为四个阶段：</p><ul><li>Elasticsearch 解析 Command，加载配置</li><li>Bootstrap 初始化，资源检查</li><li>Node 创建节点</li><li>Bootstrap 启动节点和保活线程</li></ul><h3 id="Elasticsearch-解析-Command，加载配置"><a href="#Elasticsearch-解析-Command，加载配置" class="headerlink" title="Elasticsearch 解析 Command，加载配置"></a>Elasticsearch 解析 Command，加载配置</h3><p>首先可以看一下入口方法 <code>Elasticsearch.main</code>：</p><pre><code>    public static void main(final String[] args) throws Exception {        System.setSecurityManager(new SecurityManager() {            @Override            public void checkPermission(Permission perm) {                // grant all permissions so that we can later set the security manager to the one that we want            }        });        LogConfigurator.registerErrorListener();        final Elasticsearch elasticsearch = new Elasticsearch();        int status = main(args, elasticsearch, Terminal.DEFAULT);        if (status != ExitCodes.OK) {            exit(status);        }    }</code></pre><p>1.1, 创建 SecurityManager 安全管理器</p><blockquote><p>关于 SecurityManager:<br>安全管理器在Java语言中的作用就是<strong>检查操作是否有权限执行</strong>，通过则顺序进行，否则抛出一个异常<br>网上一篇文章：<a href="https://blog.csdn.net/wwwdc1012/article/details/82287474" target="_blank" rel="noopener">Java安全——安全管理器、访问控制器和类装载器</a></p></blockquote><p>1.2, LogConfigurator.registerErrorListener() 注册侦听器</p><p>1.3, 创建Elasticsearch对象</p><p>Elasticsearch 入口类的继承关系如下：</p><p><img src="http://image.laijianfeng.org/20180901_143515.png" alt="Elasticsearch 入口类的继承关系"></p><p>可以看到Elasticsearch继承了EnvironmentAwareCommand，Command，这几个类的功能简要介绍如下：</p><ul><li>Elasticsearch: This class starts elasticsearch.</li><li>EnvironmentAwareCommand: A cli command which requires an <code>org.elasticsearch.env.Environment</code> to use current paths and settings</li><li>Command: An action to execute within a cli.</li></ul><p>可以看出Elasticsearch的一个重要作用是解析命令参数</p><p>执行带 <code>-h</code> 参数的Elasticsearch启动命令</p><p><img src="http://image.laijianfeng.org/20180901_144410.png" alt="带参数的Elasticsearch启动命令"></p><p>可以发现这几个参数与 Cammand 类 和 Elasticsearch 的几个私有变量是对应的</p><p>Elasticsearch的构造函数如下：</p><pre><code>Elasticsearch() {    super(&quot;starts elasticsearch&quot;, () -&gt; {}); // we configure logging later so we override the base class from configuring logging    versionOption = parser.acceptsAll(Arrays.asList(&quot;V&quot;, &quot;version&quot;), &quot;Prints elasticsearch version information and exits&quot;);    daemonizeOption = parser.acceptsAll(Arrays.asList(&quot;d&quot;, &quot;daemonize&quot;), &quot;Starts Elasticsearch in the background&quot;)        .availableUnless(versionOption);    pidfileOption = parser.acceptsAll(Arrays.asList(&quot;p&quot;, &quot;pidfile&quot;), &quot;Creates a pid file in the specified path on start&quot;)        .availableUnless(versionOption).withRequiredArg().withValuesConvertedBy(new PathConverter());    quietOption = parser.acceptsAll(Arrays.asList(&quot;q&quot;, &quot;quiet&quot;), &quot;Turns off standard output/error streams logging in console&quot;)        .availableUnless(versionOption).availableUnless(daemonizeOption);}</code></pre><p>1.4, 接着进入 <code>Command.main</code> 方法</p><p>该方法给当前Runtime类添加一个hook线程，该线程作用是：当Runtime异常关闭时打印异常信息</p><p>1.5, <code>Command.mainWithoutErrorHandling</code> 方法，根据命令行参数，打印或者设置参数，然后执行命令，有异常则抛出所有异常</p><p>1.6, <code>EnvironmentAwareCommand.execute</code>，确保 <code>es.path.data</code>, <code>es.path.home</code>, <code>es.path.logs</code> 等参数已设置，否则从 <code>System.properties</code> 中读取</p><pre><code>putSystemPropertyIfSettingIsMissing(settings, &quot;path.data&quot;, &quot;es.path.data&quot;);putSystemPropertyIfSettingIsMissing(settings, &quot;path.home&quot;, &quot;es.path.home&quot;);putSystemPropertyIfSettingIsMissing(settings, &quot;path.logs&quot;, &quot;es.path.logs&quot;);execute(terminal, options, createEnv(terminal, settings));</code></pre><p>1.7, <code>EnvironmentAwareCommand.createEnv</code>，读取config下的配置文件<code>elasticsearch.yml</code>内容，收集plugins，bin，lib，modules等目录下的文件信息</p><p>createEnv最后返回一个 Environment 对象，执行结果如下</p><p><img src="http://image.laijianfeng.org/20180901_160825.png" alt="EnvironmentAwareCommand.createEnv"></p><p>1.8, <code>Elasticsearch.execute</code> ，读取daemonize， pidFile，quiet 的值，并 确保配置的临时目录(temp)是有效目录</p><p>进入Bootstrap初始化阶段</p><pre><code>Bootstrap.init(!daemonize, pidFile, quiet, initialEnv);</code></pre><h3 id="Bootstrap初始化阶段"><a href="#Bootstrap初始化阶段" class="headerlink" title="Bootstrap初始化阶段"></a>Bootstrap初始化阶段</h3><h4 id="Bootstrap-init"><a href="#Bootstrap-init" class="headerlink" title="Bootstrap.init"></a>Bootstrap.init</h4><p>2.1, 进入 <code>Bootstrap.init</code>, This method is invoked by <code>Elasticsearch#main(String[])</code> to startup elasticsearch.</p><p><code>INSTANCE = new Bootstrap();</code>, 创建一个Bootstrap对象作为类对象，该类构造函数会创建一个用户线程，添加到Runtime Hook中，进行 countDown 操作</p><pre><code> private final CountDownLatch keepAliveLatch = new CountDownLatch(1); /** creates a new instance */    Bootstrap() {        keepAliveThread = new Thread(new Runnable() {            @Override            public void run() {                try {                    keepAliveLatch.await();                } catch (InterruptedException e) {                }            }        }, &quot;elasticsearch[keepAlive/&quot; + Version.CURRENT + &quot;]&quot;);        keepAliveThread.setDaemon(false);        // keep this thread alive (non daemon thread) until we shutdown        Runtime.getRuntime().addShutdownHook(new Thread() {            @Override            public void run() {                keepAliveLatch.countDown();            }        });    }</code></pre><blockquote><p>CountDownLatch是一个同步工具类，它允许一个或多个线程一直等待，直到其他线程执行完后再执行。例如，应用程序的主线程希望在负责启动框架服务的线程已经启动所有框架服务之后执行。<br>CountDownLatch是通过一个计数器来实现的，计数器的初始化值为线程的数量。每当一个线程完成了自己的任务后，计数器的值就相应得减1。当计数器到达0时，表示所有的线程都已完成任务，然后在闭锁上等待的线程就可以恢复执行任务。<br>更多介绍请看文章：<a href="https://blog.csdn.net/wwwdc1012/article/details/82288473" target="_blank" rel="noopener">并发工具类 CountDownLatch</a></p></blockquote><p>2.2, 加载 keystore 安全配置，keystore文件不存在则创建，保存；存在则解密，更新keystore</p><p>2.3, 根据已有的配置信息，创建一个Environment对象</p><p>2.4, LogConfigurator log4j日志配置</p><p>2.5, 检查pid文件是否存在，不存在则创建</p><blockquote><p>关于 pid 文件：<br>(1) <strong>pid文件的内容</strong>：pid文件为文本文件，内容只有一行，记录了该进程的ID，用cat命令可以看到。<br>(2) <strong>pid文件的作用</strong>：防止进程启动多个副本。只有获得pid文件(固定路径固定文件名)写入权限(F_WRLCK)的进程才能正常启动并把自身的PID写入该文件中，其它同一个程序的多余进程则自动退出。</p></blockquote><p>2.6, 检查Lucene版本与实际的Lucene Jar文件的版本是否一致，不一致则抛异常</p><p>2.7, 设置未捕获异常的处理 Thread.setDefaultUncaughtExceptionHandler</p><p>在Thread ApI中提供了UncaughtExceptionHandle，它能检测出某个由于未捕获的异常而终结的情况</p><blockquote><p>朱小厮 <a href="https://blog.csdn.net/u013256816/article/details/50417822" target="_blank" rel="noopener">JAVA多线程之UncaughtExceptionHandler——处理非正常的线程中止</a></p></blockquote><h4 id="INSTANCE-setup-true-environment"><a href="#INSTANCE-setup-true-environment" class="headerlink" title="INSTANCE.setup(true, environment);"></a>INSTANCE.setup(true, environment);</h4><p>3.1，<code>spawner.spawnNativeControllers(environment);</code></p><p>遍历每个模块，生成本机控制类（native Controller）：读取modules文件夹下所有的文件夹中的模块信息，保存为一个 PluginInfo  对象，为合适的模块生成控制类，通过 <code>Files.isRegularFile(spawnPath)</code> 来判断</p><p>尝试为给定模块生成控制器(native Controller)守护程序。    生成的进程将通过其stdin，stdout和stderr流保持与此JVM的连接，但对此包之外的代码不能使用对这些流的引用。</p><p>3.2， <code>initializeNatives(Path tmpFile, boolean mlockAll, boolean systemCallFilter, boolean ctrlHandler)</code>初始化本地资源</p><p>检查用户是否为root用户，是则抛异常;<br>尝试启用 系统调用过滤器 system call filter;<br>如果设置了则进行 mlockall<br>Windows关闭事件监听器<br>init lucene random seed.   </p><p>这个过程中使用到了 Natives 类:<br>Natives类是一个包装类，用于检查调用本机方法所需的类是否在启动时可用。如果它们不可用，则此类将避免调用加载这些类的代码</p><p>3.3, 添加一个Hook： Runtime.getRuntime().addShutdownHook，当ES退出时用于关闭必要的IO流，日志器上下文和配置器等</p><p>3.4, 使用 JarHell 检查重复的 jar 文件</p><p>3.5, 初始化 SecurityManager</p><pre><code>// install SM after natives, shutdown hooks, etc.Security.configure(environment, BootstrapSettings.SECURITY_FILTER_BAD_DEFAULTS_SETTING.get(settings));</code></pre><h3 id="创建-node-节点"><a href="#创建-node-节点" class="headerlink" title="创建 node 节点"></a>创建 node 节点</h3><pre><code>node = new Node(environment) {    @Override    protected void validateNodeBeforeAcceptingRequests(        final BootstrapContext context,        final BoundTransportAddress boundTransportAddress, List&lt;BootstrapCheck&gt; checks) throws NodeValidationException {        BootstrapChecks.check(context, boundTransportAddress, checks);    }};</code></pre><p>4.1, 这里直接贴一下代码（前半部分）</p><pre><code>    protected Node(final Environment environment, Collection&lt;Class&lt;? extends Plugin&gt;&gt; classpathPlugins) {        final List&lt;Closeable&gt; resourcesToClose = new ArrayList&lt;&gt;(); // register everything we need to release in the case of an error        boolean success = false;        {            // use temp logger just to say we are starting. we can&#39;t use it later on because the node name might not be set            Logger logger = Loggers.getLogger(Node.class, NODE_NAME_SETTING.get(environment.settings()));            logger.info(&quot;initializing ...&quot;);        }        try {            originalSettings = environment.settings();            Settings tmpSettings = Settings.builder().put(environment.settings())                .put(Client.CLIENT_TYPE_SETTING_S.getKey(), CLIENT_TYPE).build();            // create the node environment as soon as possible, to recover the node id and enable logging            try {                nodeEnvironment = new NodeEnvironment(tmpSettings, environment);                resourcesToClose.add(nodeEnvironment);            } catch (IOException ex) {                throw new IllegalStateException(&quot;Failed to create node environment&quot;, ex);            }            final boolean hadPredefinedNodeName = NODE_NAME_SETTING.exists(tmpSettings);            final String nodeId = nodeEnvironment.nodeId();            tmpSettings = addNodeNameIfNeeded(tmpSettings, nodeId);            final Logger logger = Loggers.getLogger(Node.class, tmpSettings);            // this must be captured after the node name is possibly added to the settings            final String nodeName = NODE_NAME_SETTING.get(tmpSettings);            if (hadPredefinedNodeName == false) {                logger.info(&quot;node name derived from node ID [{}]; set [{}] to override&quot;, nodeId, NODE_NAME_SETTING.getKey());            } else {                logger.info(&quot;node name [{}], node ID [{}]&quot;, nodeName, nodeId);            }            final JvmInfo jvmInfo = JvmInfo.jvmInfo();            logger.info(                &quot;version[{}], pid[{}], build[{}/{}/{}/{}], OS[{}/{}/{}], JVM[{}/{}/{}/{}]&quot;,                Version.displayVersion(Version.CURRENT, Build.CURRENT.isSnapshot()),                jvmInfo.pid(),                Build.CURRENT.flavor().displayName(),                Build.CURRENT.type().displayName(),                Build.CURRENT.shortHash(),                Build.CURRENT.date(),                Constants.OS_NAME,                Constants.OS_VERSION,                Constants.OS_ARCH,                Constants.JVM_VENDOR,                Constants.JVM_NAME,                Constants.JAVA_VERSION,                Constants.JVM_VERSION);            logger.info(&quot;JVM arguments {}&quot;, Arrays.toString(jvmInfo.getInputArguments()));            warnIfPreRelease(Version.CURRENT, Build.CURRENT.isSnapshot(), logger);            if (logger.isDebugEnabled()) {                logger.debug(&quot;using config [{}], data [{}], logs [{}], plugins [{}]&quot;,                    environment.configFile(), Arrays.toString(environment.dataFiles()), environment.logsFile(), environment.pluginsFile());            }            this.pluginsService = new PluginsService(tmpSettings, environment.configFile(), environment.modulesFile(), environment.pluginsFile(), classpathPlugins);            this.settings = pluginsService.updatedSettings();            localNodeFactory = new LocalNodeFactory(settings, nodeEnvironment.nodeId());            // create the environment based on the finalized (processed) view of the settings            // this is just to makes sure that people get the same settings, no matter where they ask them from            this.environment = new Environment(this.settings, environment.configFile());            Environment.assertEquivalent(environment, this.environment);            final List&lt;ExecutorBuilder&lt;?&gt;&gt; executorBuilders = pluginsService.getExecutorBuilders(settings);            final ThreadPool threadPool = new ThreadPool(settings, executorBuilders.toArray(new ExecutorBuilder[0]));            resourcesToClose.add(() -&gt; ThreadPool.terminate(threadPool, 10, TimeUnit.SECONDS));            // adds the context to the DeprecationLogger so that it does not need to be injected everywhere            DeprecationLogger.setThreadContext(threadPool.getThreadContext());            resourcesToClose.add(() -&gt; DeprecationLogger.removeThreadContext(threadPool.getThreadContext()));            final List&lt;Setting&lt;?&gt;&gt; additionalSettings = new ArrayList&lt;&gt;(pluginsService.getPluginSettings());            final List&lt;String&gt; additionalSettingsFilter = new ArrayList&lt;&gt;(pluginsService.getPluginSettingsFilter());            for (final ExecutorBuilder&lt;?&gt; builder : threadPool.builders()) {                additionalSettings.addAll(builder.getRegisteredSettings());            }            client = new NodeClient(settings, threadPool);    ...</code></pre><p>这里进行的主要操作有:</p><ol><li>生命周期Lifecycle设置为 初始化状态 INITIALIZED</li><li>创建一个 NodeEnvironment 对象保存节点环境信息，如各种数据文件的路径</li><li>读取JVM信息</li><li>创建 PluginsService 对象，创建过程中会读取并加载所有的模块和插件</li><li>创建一个最终的 Environment 对象</li><li>创建线程池 ThreadPool 后面各类对象基本都是通过线程来提供服务，这个线程池可以管理各类线程</li><li>创建 节点客户端 NodeClient</li></ol><p><strong>这里重点介绍 PluginsService 和 ThreadPool 这两个类</strong></p><h4 id="PluginsService"><a href="#PluginsService" class="headerlink" title="PluginsService"></a>PluginsService</h4><p>在构造该类对象是传入的参数如下：</p><p><img src="http://image.laijianfeng.org/20180901_175542.png" alt="PluginsService 构造方法的参数"></p><p>在构造方法中加载所有的模块</p><pre><code>Set&lt;Bundle&gt; seenBundles = new LinkedHashSet&lt;&gt;();List&lt;PluginInfo&gt; modulesList = new ArrayList&lt;&gt;();Set&lt;Bundle&gt; modules = getModuleBundles(modulesDirectory); for (Bundle bundle : modules) {   modulesList.add(bundle.plugin);}seenBundles.addAll(modules);/** Get bundles for plugins installed in the given modules directory. */static Set&lt;Bundle&gt; getModuleBundles(Path modulesDirectory) throws IOException {    return findBundles(modulesDirectory, &quot;module&quot;).stream().flatMap(b -&gt; b.bundles().stream()).collect(Collectors.toSet());}</code></pre><p>其中的 Bundle是一个内部类（a “bundle” is a group of plugins in a single classloader）<br>而 PluginInfo 则是 An in-memory representation of the plugin descriptor. 存在内存中的用来描述一个 plugin 的类</p><p>插件加载的实际代码如下：</p><pre><code>    /**     * Reads the plugin descriptor file.     *     * @param path           the path to the root directory for the plugin     * @return the plugin info     * @throws IOException if an I/O exception occurred reading the plugin descriptor     */    public static PluginInfo readFromProperties(final Path path) throws IOException {        final Path descriptor = path.resolve(ES_PLUGIN_PROPERTIES);        final Map&lt;String, String&gt; propsMap;        {            final Properties props = new Properties();            try (InputStream stream = Files.newInputStream(descriptor)) {                props.load(stream);            }            propsMap = props.stringPropertyNames().stream().collect(Collectors.toMap(Function.identity(), props::getProperty));        }        final String name = propsMap.remove(&quot;name&quot;);        if (name == null || name.isEmpty()) {            throw new IllegalArgumentException(                    &quot;property [name] is missing in [&quot; + descriptor + &quot;]&quot;);        }        final String description = propsMap.remove(&quot;description&quot;);        if (description == null) {            throw new IllegalArgumentException(                    &quot;property [description] is missing for plugin [&quot; + name + &quot;]&quot;);        }        final String version = propsMap.remove(&quot;version&quot;);        if (version == null) {            throw new IllegalArgumentException(                    &quot;property [version] is missing for plugin [&quot; + name + &quot;]&quot;);        }        final String esVersionString = propsMap.remove(&quot;elasticsearch.version&quot;);        if (esVersionString == null) {            throw new IllegalArgumentException(                    &quot;property [elasticsearch.version] is missing for plugin [&quot; + name + &quot;]&quot;);        }        final Version esVersion = Version.fromString(esVersionString);        final String javaVersionString = propsMap.remove(&quot;java.version&quot;);        if (javaVersionString == null) {            throw new IllegalArgumentException(                    &quot;property [java.version] is missing for plugin [&quot; + name + &quot;]&quot;);        }        JarHell.checkVersionFormat(javaVersionString);        final String classname = propsMap.remove(&quot;classname&quot;);        if (classname == null) {            throw new IllegalArgumentException(                    &quot;property [classname] is missing for plugin [&quot; + name + &quot;]&quot;);        }        final String extendedString = propsMap.remove(&quot;extended.plugins&quot;);        final List&lt;String&gt; extendedPlugins;        if (extendedString == null) {            extendedPlugins = Collections.emptyList();        } else {            extendedPlugins = Arrays.asList(Strings.delimitedListToStringArray(extendedString, &quot;,&quot;));        }        final String hasNativeControllerValue = propsMap.remove(&quot;has.native.controller&quot;);        final boolean hasNativeController;        if (hasNativeControllerValue == null) {            hasNativeController = false;        } else {            switch (hasNativeControllerValue) {                case &quot;true&quot;:                    hasNativeController = true;                    break;                case &quot;false&quot;:                    hasNativeController = false;                    break;                default:                    final String message = String.format(                            Locale.ROOT,                            &quot;property [%s] must be [%s], [%s], or unspecified but was [%s]&quot;,                            &quot;has_native_controller&quot;,                            &quot;true&quot;,                            &quot;false&quot;,                            hasNativeControllerValue);                    throw new IllegalArgumentException(message);            }        }        if (esVersion.before(Version.V_6_3_0) &amp;&amp; esVersion.onOrAfter(Version.V_6_0_0_beta2)) {            propsMap.remove(&quot;requires.keystore&quot;);        }        if (propsMap.isEmpty() == false) {            throw new IllegalArgumentException(&quot;Unknown properties in plugin descriptor: &quot; + propsMap.keySet());        }        return new PluginInfo(name, description, version, esVersion, javaVersionString,                              classname, extendedPlugins, hasNativeController);    }</code></pre><p>其中的两个常量的值</p><pre><code>    public static final String ES_PLUGIN_PROPERTIES = &quot;plugin-descriptor.properties&quot;;    public static final String ES_PLUGIN_POLICY = &quot;plugin-security.policy&quot;;</code></pre><p>从以上代码可以看出<strong>模块的加载过程</strong>：</p><ol><li>读取模块的配置文件 <code>plugin-descriptor.properties</code>，解析出内容并存储到 Map 中</li><li>分别校验 <code>name</code>, <code>description</code>, <code>version</code>, <code>elasticsearch.version</code>, <code>java.version</code>, <code>classname</code>, <code>extended.plugins</code>, <code>has.native.controller</code>, <code>requires.keystore</code> 这些配置项，缺失或者不按要求则抛出异常</li><li>根据配置项构造一个 PluginInfo 对象返回</li></ol><p>举例：读取出的 aggs-matrix-stats 模块的配置项信息如下</p><p><img src="http://image.laijianfeng.org/20180901_181500.png" alt="读取插件配置文件并解析文件内容"></p><p>加载插件与加载模块调用的是相同的方法</p><h3 id="ThreadPool-线程池"><a href="#ThreadPool-线程池" class="headerlink" title="ThreadPool 线程池"></a>ThreadPool 线程池</h3><p>线程池的构造方法如下：</p><pre><code>    public ThreadPool(final Settings settings, final ExecutorBuilder&lt;?&gt;... customBuilders) {        super(settings);        assert Node.NODE_NAME_SETTING.exists(settings);        final Map&lt;String, ExecutorBuilder&gt; builders = new HashMap&lt;&gt;();        final int availableProcessors = EsExecutors.numberOfProcessors(settings);        final int halfProcMaxAt5 = halfNumberOfProcessorsMaxFive(availableProcessors);        final int halfProcMaxAt10 = halfNumberOfProcessorsMaxTen(availableProcessors);        final int genericThreadPoolMax = boundedBy(4 * availableProcessors, 128, 512);        builders.put(Names.GENERIC, new ScalingExecutorBuilder(Names.GENERIC, 4, genericThreadPoolMax, TimeValue.timeValueSeconds(30)));        builders.put(Names.INDEX, new FixedExecutorBuilder(settings, Names.INDEX, availableProcessors, 200, true));        builders.put(Names.WRITE, new FixedExecutorBuilder(settings, Names.WRITE, &quot;bulk&quot;, availableProcessors, 200));        builders.put(Names.GET, new FixedExecutorBuilder(settings, Names.GET, availableProcessors, 1000));        builders.put(Names.ANALYZE, new FixedExecutorBuilder(settings, Names.ANALYZE, 1, 16));        builders.put(Names.SEARCH, new AutoQueueAdjustingExecutorBuilder(settings,                        Names.SEARCH, searchThreadPoolSize(availableProcessors), 1000, 1000, 1000, 2000));        builders.put(Names.MANAGEMENT, new ScalingExecutorBuilder(Names.MANAGEMENT, 1, 5, TimeValue.timeValueMinutes(5)));        // no queue as this means clients will need to handle rejections on listener queue even if the operation succeeded        // the assumption here is that the listeners should be very lightweight on the listeners side        builders.put(Names.LISTENER, new FixedExecutorBuilder(settings, Names.LISTENER, halfProcMaxAt10, -1));        builders.put(Names.FLUSH, new ScalingExecutorBuilder(Names.FLUSH, 1, halfProcMaxAt5, TimeValue.timeValueMinutes(5)));        builders.put(Names.REFRESH, new ScalingExecutorBuilder(Names.REFRESH, 1, halfProcMaxAt10, TimeValue.timeValueMinutes(5)));        builders.put(Names.WARMER, new ScalingExecutorBuilder(Names.WARMER, 1, halfProcMaxAt5, TimeValue.timeValueMinutes(5)));        builders.put(Names.SNAPSHOT, new ScalingExecutorBuilder(Names.SNAPSHOT, 1, halfProcMaxAt5, TimeValue.timeValueMinutes(5)));        builders.put(Names.FETCH_SHARD_STARTED, new ScalingExecutorBuilder(Names.FETCH_SHARD_STARTED, 1, 2 * availableProcessors, TimeValue.timeValueMinutes(5)));        builders.put(Names.FORCE_MERGE, new FixedExecutorBuilder(settings, Names.FORCE_MERGE, 1, -1));        builders.put(Names.FETCH_SHARD_STORE, new ScalingExecutorBuilder(Names.FETCH_SHARD_STORE, 1, 2 * availableProcessors, TimeValue.timeValueMinutes(5)));        for (final ExecutorBuilder&lt;?&gt; builder : customBuilders) {            if (builders.containsKey(builder.name())) {                throw new IllegalArgumentException(&quot;builder with name [&quot; + builder.name() + &quot;] already exists&quot;);            }            builders.put(builder.name(), builder);        }        this.builders = Collections.unmodifiableMap(builders);        threadContext = new ThreadContext(settings);        final Map&lt;String, ExecutorHolder&gt; executors = new HashMap&lt;&gt;();        for (@SuppressWarnings(&quot;unchecked&quot;) final Map.Entry&lt;String, ExecutorBuilder&gt; entry : builders.entrySet()) {            final ExecutorBuilder.ExecutorSettings executorSettings = entry.getValue().getSettings(settings);            final ExecutorHolder executorHolder = entry.getValue().build(executorSettings, threadContext);            if (executors.containsKey(executorHolder.info.getName())) {                throw new IllegalStateException(&quot;duplicate executors with name [&quot; + executorHolder.info.getName() + &quot;] registered&quot;);            }            logger.debug(&quot;created thread pool: {}&quot;, entry.getValue().formatInfo(executorHolder.info));            executors.put(entry.getKey(), executorHolder);        }        executors.put(Names.SAME, new ExecutorHolder(DIRECT_EXECUTOR, new Info(Names.SAME, ThreadPoolType.DIRECT)));        this.executors = unmodifiableMap(executors);        this.scheduler = Scheduler.initScheduler(settings);        TimeValue estimatedTimeInterval = ESTIMATED_TIME_INTERVAL_SETTING.get(settings);        this.cachedTimeThread = new CachedTimeThread(EsExecutors.threadName(settings, &quot;[timer]&quot;), estimatedTimeInterval.millis());        this.cachedTimeThread.start();    }</code></pre><p>参考着文档来理解这里的代码：<a href="https://www.elastic.co/guide/en/elasticsearch/reference/current/modules-threadpool.html" target="_blank" rel="noopener">Elasticsearch Reference [6.4] » Modules » Thread Pool</a> 和 <a href="http://cwiki.apachecn.org/pages/viewpage.action?pageId=9405389" target="_blank" rel="noopener">apachecn 线程池</a></p><h4 id="线程池类型-ThreadPoolType"><a href="#线程池类型-ThreadPoolType" class="headerlink" title="线程池类型 ThreadPoolType"></a>线程池类型 ThreadPoolType</h4><p><strong>fixed</strong>（固定）：fixed线程池拥有固定数量的线程来处理请求，在没有空闲线程时请求将被挂在队列中。queue_size参数可以控制在没有空闲线程时，能排队挂起的请求数</p><p><strong>fixed_auto_queue_size</strong>：此类型为实验性的，将被更改或删除，不关注</p><p><strong>scaling</strong>（弹性）：scaling线程池拥有的线程数量是动态的，这个数字介于core和max参数的配置之间变化。keep_alive参数用来控制线程在线程池中空闲的最长时间</p><p><strong>direct</strong>：此类线程是一种不支持关闭的线程,就意味着一旦使用,则会一直存活下去.</p><h4 id="一些重要的线程池"><a href="#一些重要的线程池" class="headerlink" title="一些重要的线程池"></a>一些重要的线程池</h4><p><strong>generic</strong>：用于通用的请求（例如：后台节点发现），线程池类型为 scaling。</p><p><strong>index</strong>：用于index/delete请求，线程池类型为 fixed， 大小的为处理器数量，队列大小为200，最大线程数为 1 + 处理器数量。</p><p><strong>search</strong>：用于count/search/suggest请求。线程池类型为 fixed， 大小的为 int((处理器数量 3) / 2) +1，队列大小为1000。*</p><p><strong>get</strong>：用于get请求。线程池类型为 fixed，大小的为处理器数量，队列大小为1000。</p><p><strong>analyze</strong>：用于analyze请求。线程池类型为 fixed，大小的1，队列大小为16</p><p><strong>write</strong>：用于单个文档的 index/delete/update 请求以及 <strong>bulk 请求</strong>，线程池类型为 fixed，大小的为处理器数量，队列大小为200，最大线程数为 1 + 处理器数量。</p><p><strong>snapshot</strong>：用于snaphost/restore请求。线程池类型为 scaling，线程保持存活时间为5分钟，最大线程数为min(5, (处理器数量)/2)。</p><p><strong>warmer</strong>：用于segment warm-up请求。线程池类型为 scaling，线程保持存活时间为5分钟，最大线程数为min(5, (处理器数量)/2)。</p><p><strong>refresh</strong>：用于refresh请求。线程池类型为 scaling，线程空闲保持存活时间为5分钟，最大线程数为min(10, (处理器数量)/2)。</p><p><strong>listener</strong>：主要用于Java客户端线程监听器被设置为true时执行动作。线程池类型为 scaling，最大线程数为min(10, (处理器数量)/2)。</p><p>ThreadPool 类中除了以上线程队列，还可以看到有 CachedTimeThread（缓存系统时间）、ExecutorService（在当前线程上执行提交的任务）、ThreadContext（线程上下文）、ScheduledThreadPoolExecutor（Java任务调度）等</p><blockquote><p>参考文章：<a href="https://my.oschina.net/u/3145136/blog/848079" target="_blank" rel="noopener">Java并发编程14-ScheduledThreadPoolExecutor详解</a><br><a href="https://www.jianshu.com/p/4b8a257f1b90" target="_blank" rel="noopener">Java线程池原理分析ScheduledThreadPoolExecutor篇</a><br>关于 ScheduledThreadPoolExecutor 更多的细节应该看书或者官方文档</p></blockquote><h4 id="关于线程"><a href="#关于线程" class="headerlink" title="关于线程"></a>关于线程</h4><p>了解了线程池，继续深究ES线程是什么样子的</p><p>在 <code>ScalingExecutorBuilder.build</code> 中可以发现 <code>ExecutorService</code> 对象是由 <code>EsExecutors.newScaling</code> 创建的</p><pre><code>public static EsThreadPoolExecutor newScaling(String name, int min, int max, long keepAliveTime, TimeUnit unit, ThreadFactory threadFactory, ThreadContext contextHolder) {    ExecutorScalingQueue&lt;Runnable&gt; queue = new ExecutorScalingQueue&lt;&gt;();    EsThreadPoolExecutor executor = new EsThreadPoolExecutor(name, min, max, keepAliveTime, unit, queue, threadFactory, new ForceQueuePolicy(), contextHolder);    queue.executor = executor;    return executor;}</code></pre><p>再看看 <code>EsThreadPoolExecutor</code> 这个类的继承关系，其是扩展自Java的线程池 <code>ThreadPoolExecutor</code></p><p><img src="http://image.laijianfeng.org/20180901_192545.png" alt="EsThreadPoolExecutor的继承链"></p><pre><code>    EsThreadPoolExecutor(String name, int corePoolSize, int maximumPoolSize, long keepAliveTime, TimeUnit unit,            BlockingQueue&lt;Runnable&gt; workQueue, ThreadFactory threadFactory, XRejectedExecutionHandler handler,            ThreadContext contextHolder) {        super(corePoolSize, maximumPoolSize, keepAliveTime, unit, workQueue, threadFactory, handler);        this.name = name;        this.contextHolder = contextHolder;    }</code></pre><h3 id="回到-Node-节点的创建"><a href="#回到-Node-节点的创建" class="headerlink" title="回到 Node 节点的创建"></a>回到 Node 节点的创建</h3><p>4.2, 创建各种服务类对象 ResourceWatcherService、NetworkService、ClusterService、IngestService、ClusterInfoService、UsageService、MonitorService、CircuitBreakerService、MetaStateService、IndicesService、MetaDataIndexUpgradeService、TemplateUpgradeService、TransportService、ResponseCollectorService、SearchTransportService、NodeService、SearchService、PersistentTasksClusterService</p><p>这些服务类是的功能可以根据名称做一个大概的判断，具体还需要看文档和源码，限于篇幅，在此不做探究</p><p>4.3, ModulesBuilder类加入各种模块 ScriptModule、AnalysisModule、SettingsModule、pluginModule、ClusterModule、IndicesModule、SearchModule、GatewayModule、RepositoriesModule、ActionModule、NetworkModule、DiscoveryModule</p><p>4.4, guice 绑定依赖以及依赖注入</p><blockquote><p>关于 guice 可以参考之前的文章:<br><a href="https://mp.weixin.qq.com/s?__biz=MzI1NDU0MTE1NA==&amp;mid=2247483683&amp;idx=1&amp;sn=0d77085a0234b2c5b7c679e62200e6f5&amp;chksm=e9c2ed2edeb56438010b5f5d487bcb7f0529c85d50ac7c858e1a8e3a9279c15007341170c5ac&amp;mpshare=1&amp;scene=1&amp;srcid=0901SWQiIdjHZ3endUHZqjkP#rd" target="_blank" rel="noopener">Google Guice 快速入门</a><br><a href="https://mp.weixin.qq.com/s?__biz=MzI1NDU0MTE1NA==&amp;mid=2247483691&amp;idx=1&amp;sn=3c7175d318bce6728c2105d27ae6bafe&amp;chksm=e9c2ed26deb56430289edabd15cef1a0cf777c5dfe4f4ad5013655e9d3607958e0fe16ac5436&amp;mpshare=1&amp;scene=1&amp;srcid=0901u1aslOFhg6UmeBkLw8BY#rd" target="_blank" rel="noopener">Elasticsearch 中的 Guice</a></p></blockquote><p>elasticsearch里面的组件基本都进行进行了模块化管理，elasticsearch对guice进行了封装，通过ModulesBuilder类构建es的模块（一般包括的模块在 4.3 中列举了）</p><pre><code>// 依赖绑定modules.add(b -&gt; {        b.bind(Node.class).toInstance(this);        b.bind(NodeService.class).toInstance(nodeService);        b.bind(NamedXContentRegistry.class).toInstance(xContentRegistry);        b.bind(PluginsService.class).toInstance(pluginsService);        b.bind(Client.class).toInstance(client);        b.bind(NodeClient.class).toInstance(client);        b.bind(Environment.class).toInstance(this.environment);        b.bind(ThreadPool.class).toInstance(threadPool);        b.bind(NodeEnvironment.class).toInstance(nodeEnvironment);        b.bind(ResourceWatcherService.class).toInstance(resourceWatcherService);        b.bind(CircuitBreakerService.class).toInstance(circuitBreakerService);        b.bind(BigArrays.class).toInstance(bigArrays);        b.bind(ScriptService.class).toInstance(scriptModule.getScriptService());        b.bind(AnalysisRegistry.class).toInstance(analysisModule.getAnalysisRegistry());        b.bind(IngestService.class).toInstance(ingestService);        b.bind(UsageService.class).toInstance(usageService);        b.bind(NamedWriteableRegistry.class).toInstance(namedWriteableRegistry);        b.bind(MetaDataUpgrader.class).toInstance(metaDataUpgrader);        b.bind(MetaStateService.class).toInstance(metaStateService);        b.bind(IndicesService.class).toInstance(indicesService);        b.bind(SearchService.class).toInstance(searchService);        b.bind(SearchTransportService.class).toInstance(searchTransportService);        b.bind(SearchPhaseController.class).toInstance(new SearchPhaseController(settings,            searchService::createReduceContext));        b.bind(Transport.class).toInstance(transport);        b.bind(TransportService.class).toInstance(transportService);        b.bind(NetworkService.class).toInstance(networkService);        b.bind(UpdateHelper.class).toInstance(new UpdateHelper(settings, scriptModule.getScriptService()));        b.bind(MetaDataIndexUpgradeService.class).toInstance(metaDataIndexUpgradeService);        b.bind(ClusterInfoService.class).toInstance(clusterInfoService);        b.bind(GatewayMetaState.class).toInstance(gatewayMetaState);        b.bind(Discovery.class).toInstance(discoveryModule.getDiscovery());        {            RecoverySettings recoverySettings = new RecoverySettings(settings, settingsModule.getClusterSettings());            processRecoverySettings(settingsModule.getClusterSettings(), recoverySettings);            b.bind(PeerRecoverySourceService.class).toInstance(new PeerRecoverySourceService(settings, transportService,                    indicesService, recoverySettings));            b.bind(PeerRecoveryTargetService.class).toInstance(new PeerRecoveryTargetService(settings, threadPool,                    transportService, recoverySettings, clusterService));        }        httpBind.accept(b);        pluginComponents.stream().forEach(p -&gt; b.bind((Class) p.getClass()).toInstance(p));        b.bind(PersistentTasksService.class).toInstance(persistentTasksService);        b.bind(PersistentTasksClusterService.class).toInstance(persistentTasksClusterService);        b.bind(PersistentTasksExecutorRegistry.class).toInstance(registry);    });injector = modules.createInjector();</code></pre><h3 id="Bootstrap-启动"><a href="#Bootstrap-启动" class="headerlink" title="Bootstrap 启动"></a>Bootstrap 启动</h3><p>5.1， 通过 <code>injector</code> 获取各个类的对象，调用 <code>start()</code> 方法启动（实际进入各个类的中 <code>doStart</code> 方法）: LifecycleComponent、IndicesService、IndicesClusterStateService、SnapshotsService、SnapshotShardsService、RoutingService、SearchService、MonitorService、NodeConnectionsService、ResourceWatcherService、GatewayService、Discovery、TransportService</p><p>这里简要介绍一下各个服务类的职能：</p><p>IndicesService：索引管理<br>IndicesClusterStateService：跨集群同步<br>SnapshotsService：负责创建快照<br>SnapshotShardsService：此服务在数据和主节点上运行，并控制这些节点上当前快照的分片。 它负责启动和停止分片级别快照<br>RoutingService：侦听集群状态，当它收到ClusterChangedEvent（集群改变事件）将验证集群状态，路由表可能会更新<br>SearchService：搜索服务<br>MonitorService：监控<br>NodeConnectionsService：此组件负责在节点添加到群集状态后连接到节点，并在删除它们时断开连接。 此外，它会定期检查所有连接是否仍处于打开状态，并在需要时还原它们。 请注意，如果节点断开/不响应ping，则此组件不负责从群集中删除节点。 这是由NodesFaultDetection完成的。 主故障检测由链接MasterFaultDetection完成。<br>ResourceWatcherService：通用资源观察器服务<br>GatewayService：网关</p><p>如果该节点是主节点或数据节点，还需要进行相关的职能操作</p><p>5.2, 集群发现与监控等，启动 HttpServerTransport， 绑定服务端口</p><pre><code>validateNodeBeforeAcceptingRequests(new BootstrapContext(settings, onDiskMetadata), transportService.boundAddress(), pluginsService    .filterPlugins(Plugin    .class)    .stream()    .flatMap(p -&gt; p.getBootstrapChecks().stream()).collect(Collectors.toList()));clusterService.addStateApplier(transportService.getTaskManager());// start after transport service so the local disco is knowndiscovery.start(); // start before cluster service so that it can set initial state on ClusterApplierServiceclusterService.start();assert clusterService.localNode().equals(localNodeFactory.getNode())    : &quot;clusterService has a different local node than the factory provided&quot;;transportService.acceptIncomingRequests();discovery.startInitialJoin();// tribe nodes don&#39;t have a master so we shouldn&#39;t register an observer         sfinal TimeValue initialStateTimeout = DiscoverySettings.INITIAL_STATE_TIMEOUT_SETTING.get(settings);if (initialStateTimeout.millis() &gt; 0) {    final ThreadPool thread = injector.getInstance(ThreadPool.class);    ClusterState clusterState = clusterService.state();    ClusterStateObserver observer = new ClusterStateObserver(clusterState, clusterService, null, logger, thread.getThreadContext());    if (clusterState.nodes().getMasterNodeId() == null) {        logger.debug(&quot;waiting to join the cluster. timeout [{}]&quot;, initialStateTimeout);        final CountDownLatch latch = new CountDownLatch(1);        observer.waitForNextChange(new ClusterStateObserver.Listener() {            @Override            public void onNewClusterState(ClusterState state) { latch.countDown(); }            @Override            public void onClusterServiceClose() {                latch.countDown();            }            @Override            public void onTimeout(TimeValue timeout) {                logger.warn(&quot;timed out while waiting for initial discovery state - timeout: {}&quot;,                    initialStateTimeout);                latch.countDown();            }        }, state -&gt; state.nodes().getMasterNodeId() != null, initialStateTimeout);        try {            latch.await();        } catch (InterruptedException e) {            throw new ElasticsearchTimeoutException(&quot;Interrupted while waiting for initial discovery state&quot;);        }    }}if (NetworkModule.HTTP_ENABLED.get(settings)) {    injector.getInstance(HttpServerTransport.class).start();}if (WRITE_PORTS_FILE_SETTING.get(settings)) {    if (NetworkModule.HTTP_ENABLED.get(settings)) {        HttpServerTransport http = injector.getInstance(HttpServerTransport.class);        writePortsFile(&quot;http&quot;, http.boundAddress());    }    TransportService transport = injector.getInstance(TransportService.class);    writePortsFile(&quot;transport&quot;, transport.boundAddress());}</code></pre><p>5.3, 启动保活线程 keepAliveThread.start 进行心跳检测</p><h3 id="小结"><a href="#小结" class="headerlink" title="小结"></a>小结</h3><p>过程很漫长，后面很多类的功能未了解，之后补上</p><p>有理解错误的地方请大家多多指教</p><hr><p>打开微信扫一扫，关注【小旋锋】微信公众号，及时接收博文推送</p><p><img src="http://image.laijianfeng.org/%E5%B0%8F%E6%97%8B%E9%94%8B%E7%9A%84%E5%BE%AE%E4%BF%A1%E5%85%AC%E4%BC%97%E5%8F%B7_%E4%BA%8C%E7%BB%B4%E7%A0%81.jpg" alt="小旋锋的微信公众号"></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h3 id=&quot;前言&quot;&gt;&lt;a href=&quot;#前言&quot; class=&quot;headerlink&quot; title=&quot;前言&quot;&gt;&lt;/a&gt;前言&lt;/h3&gt;&lt;p&gt;本文探究Elasticsearch 6.3.2的启动流程&lt;/p&gt;
&lt;h4 id=&quot;环境准备&quot;&gt;&lt;a href=&quot;#环境准备&quot; class=&quot;
      
    
    </summary>
    
      <category term="大数据" scheme="http://laijianfeng.org/categories/%E5%A4%A7%E6%95%B0%E6%8D%AE/"/>
    
    
      <category term="elasticsearch" scheme="http://laijianfeng.org/tags/elasticsearch/"/>
    
  </entry>
  
  <entry>
    <title>Google guava工具类的介绍和使用</title>
    <link href="http://laijianfeng.org/2018/08/Google-guava%E5%B7%A5%E5%85%B7%E7%B1%BB%E7%9A%84%E4%BB%8B%E7%BB%8D%E5%92%8C%E4%BD%BF%E7%94%A8/"/>
    <id>http://laijianfeng.org/2018/08/Google-guava工具类的介绍和使用/</id>
    <published>2018-08-30T16:58:57.000Z</published>
    <updated>2018-08-30T16:59:59.729Z</updated>
    
    <content type="html"><![CDATA[<h3 id="概述"><a href="#概述" class="headerlink" title="概述"></a>概述</h3><p>工具类 就是封装平常用的方法，不需要你重复造轮子，节省开发人员时间，提高工作效率。谷歌作为大公司，当然会从日常的工作中提取中很多高效率的方法出来。所以就诞生了guava。</p><p>guava的优点：</p><ul><li>高效设计良好的API，被Google的开发者设计，实现和使用</li><li>遵循高效的java语法实践</li><li>使代码更刻度，简洁，简单</li><li>节约时间，资源，提高生产力</li></ul><p>Guava工程包含了若干被Google的 Java项目广泛依赖 的核心库，例如：</p><ul><li>集合 [collections]</li><li>缓存 [caching]</li><li>原生类型支持 [primitives support]</li><li>并发库 [concurrency libraries]</li><li>通用注解 [common annotations]</li><li>字符串处理 [string processing]</li><li>I/O 等等。</li></ul><p>这里借用龙果学院深入浅出Guava课程的一张图</p><p><img src="http://image.laijianfeng.org/20180830_234930.png" alt="龙果学院深入浅出Guava"></p><h3 id="使用"><a href="#使用" class="headerlink" title="使用"></a>使用</h3><p>引入gradle依赖（引入Jar包）</p><pre><code>compile &#39;com.google.guava:guava:26.0-jre&#39;</code></pre><h4 id="1-集合的创建"><a href="#1-集合的创建" class="headerlink" title="1.集合的创建"></a>1.集合的创建</h4><pre><code>// 普通Collection的创建List&lt;String&gt; list = Lists.newArrayList();Set&lt;String&gt; set = Sets.newHashSet();Map&lt;String, String&gt; map = Maps.newHashMap();// 不变Collection的创建ImmutableList&lt;String&gt; iList = ImmutableList.of(&quot;a&quot;, &quot;b&quot;, &quot;c&quot;);ImmutableSet&lt;String&gt; iSet = ImmutableSet.of(&quot;e1&quot;, &quot;e2&quot;);ImmutableMap&lt;String, String&gt; iMap = ImmutableMap.of(&quot;k1&quot;, &quot;v1&quot;, &quot;k2&quot;, &quot;v2&quot;);</code></pre><p>创建不可变集合 先理解什么是immutable(不可变)对象</p><ul><li>在多线程操作下，是线程安全的</li><li>所有不可变集合会比可变集合更有效的利用资源</li><li>中途不可改变</li></ul><pre><code>ImmutableList&lt;String&gt; immutableList = ImmutableList.of(&quot;1&quot;,&quot;2&quot;,&quot;3&quot;,&quot;4&quot;);</code></pre><p>这声明了一个<strong>不可变</strong>的List集合，List中有数据1，2，3，4。类中的 操作集合的方法（譬如add, set, sort, replace等）都被声明过期，并且抛出异常。 而没用guava之前是需要声明并且加各种包裹集合才能实现这个功能</p><pre><code>  // add 方法  @Deprecated @Override  public final void add(int index, E element) {    throw new UnsupportedOperationException();  }</code></pre><p><strong>当我们需要一个map中包含key为String类型，value为List类型的时候</strong>，以前我们是这样写的</p><pre><code>Map&lt;String,List&lt;Integer&gt;&gt; map = new HashMap&lt;String,List&lt;Integer&gt;&gt;();List&lt;Integer&gt; list = new ArrayList&lt;Integer&gt;();list.add(1);list.add(2);map.put(&quot;aa&quot;, list);System.out.println(map.get(&quot;aa&quot;));//[1, 2]</code></pre><p>而现在</p><pre><code>Multimap&lt;String,Integer&gt; map = ArrayListMultimap.create();        map.put(&quot;aa&quot;, 1);map.put(&quot;aa&quot;, 2);System.out.println(map.get(&quot;aa&quot;));  //[1, 2]</code></pre><p><strong>其他的黑科技集合</strong></p><pre><code>MultiSet: 无序+可重复   count()方法获取单词的次数  增强了可读性+操作简单创建方式:  Multiset&lt;String&gt; set = HashMultiset.create();Multimap: key-value  key可以重复  创建方式: Multimap&lt;String, String&gt; teachers = ArrayListMultimap.create();BiMap: 双向Map(Bidirectional Map) 键与值都不能重复创建方式:  BiMap&lt;String, String&gt; biMap = HashBiMap.create();Table: 双键的Map Map--&gt; Table--&gt;rowKey+columnKey+value  //和sql中的联合主键有点像创建方式: Table&lt;String, String, Integer&gt; tables = HashBasedTable.create();...等等(guava中还有很多java里面没有给出的集合类型)</code></pre><h4 id="2-将集合转换为特定规则的字符串"><a href="#2-将集合转换为特定规则的字符串" class="headerlink" title="2.将集合转换为特定规则的字符串"></a>2.将集合转换为特定规则的字符串</h4><p>以前我们将list转换为特定规则的字符串是这样写的:</p><pre><code>//use javaList&lt;String&gt; list = new ArrayList&lt;String&gt;();list.add(&quot;aa&quot;);list.add(&quot;bb&quot;);list.add(&quot;cc&quot;);String str = &quot;&quot;;for(int i=0; i&lt;list.size(); i++){    str = str + &quot;-&quot; +list.get(i);}//str 为-aa-bb-cc//use guavaList&lt;String&gt; list = new ArrayList&lt;String&gt;();list.add(&quot;aa&quot;);list.add(&quot;bb&quot;);list.add(&quot;cc&quot;);String result = Joiner.on(&quot;-&quot;).join(list);//result为  aa-bb-cc</code></pre><p>把map集合转换为特定规则的字符串</p><pre><code>Map&lt;String, Integer&gt; map = Maps.newHashMap();map.put(&quot;xiaoming&quot;, 12);map.put(&quot;xiaohong&quot;,13);String result = Joiner.on(&quot;,&quot;).withKeyValueSeparator(&quot;=&quot;).join(map);// result为 xiaoming=12,xiaohong=13</code></pre><h4 id="3-将String转换为特定的集合"><a href="#3-将String转换为特定的集合" class="headerlink" title="3.将String转换为特定的集合"></a>3.将String转换为特定的集合</h4><pre><code>//use javaList&lt;String&gt; list = new ArrayList&lt;String&gt;();String a = &quot;1-2-3-4-5-6&quot;;String[] strs = a.split(&quot;-&quot;);for(int i=0; i&lt;strs.length; i++){    list.add(strs[i]);}//use guavaString str = &quot;1-2-3-4-5-6&quot;;List&lt;String&gt; list = Splitter.on(&quot;-&quot;).splitToList(str);//list为  [1, 2, 3, 4, 5, 6]</code></pre><p>如果</p><pre><code>str=&quot;1-2-3-4- 5-  6  &quot;;</code></pre><p>guava还可以使用 <code>omitEmptyStrings().trimResults()</code> 去除空串与空格</p><pre><code>String str = &quot;1-2-3-4-  5-  6   &quot;;  List&lt;String&gt; list = Splitter.on(&quot;-&quot;).omitEmptyStrings().trimResults().splitToList(str);System.out.println(list);</code></pre><p><strong>将String转换为map</strong></p><pre><code>String str = &quot;xiaoming=11,xiaohong=23&quot;;Map&lt;String,String&gt; map = Splitter.on(&quot;,&quot;).withKeyValueSeparator(&quot;=&quot;).split(str);</code></pre><h4 id="4-guava还支持多个字符切割，或者特定的正则分隔"><a href="#4-guava还支持多个字符切割，或者特定的正则分隔" class="headerlink" title="4.guava还支持多个字符切割，或者特定的正则分隔"></a>4.guava还支持多个字符切割，或者特定的正则分隔</h4><pre><code>String input = &quot;aa.dd,,ff,,.&quot;;List&lt;String&gt; result = Splitter.onPattern(&quot;[.|,]&quot;).omitEmptyStrings().splitToList(input);</code></pre><p>关于字符串的操作 都是在Splitter这个类上进行的</p><pre><code>// 判断匹配结果boolean result = CharMatcher.inRange(&#39;a&#39;, &#39;z&#39;).or(CharMatcher.inRange(&#39;A&#39;, &#39;Z&#39;)).matches(&#39;K&#39;); //true// 保留数字文本  CharMatcher.digit() 已过时   retain 保留//String s1 = CharMatcher.digit().retainFrom(&quot;abc 123 efg&quot;); //123String s1 = CharMatcher.inRange(&#39;0&#39;, &#39;9&#39;).retainFrom(&quot;abc 123 efg&quot;); // 123// 删除数字文本  remove 删除// String s2 = CharMatcher.digit().removeFrom(&quot;abc 123 efg&quot;);    //abc  efgString s2 = CharMatcher.inRange(&#39;0&#39;, &#39;9&#39;).removeFrom(&quot;abc 123 efg&quot;); // abc  efg</code></pre><h4 id="5-集合的过滤"><a href="#5-集合的过滤" class="headerlink" title="5. 集合的过滤"></a>5. 集合的过滤</h4><p>我们对于集合的过滤，思路就是迭代，然后再具体对每一个数判断，这样的代码放在程序中，难免会显得很臃肿，虽然功能都有，但是很不好看。</p><p>guava写法</p><pre><code>//按照条件过滤ImmutableList&lt;String&gt; names = ImmutableList.of(&quot;begin&quot;, &quot;code&quot;, &quot;Guava&quot;, &quot;Java&quot;);Iterable&lt;String&gt; fitered = Iterables.filter(names, Predicates.or(Predicates.equalTo(&quot;Guava&quot;), Predicates.equalTo(&quot;Java&quot;)));System.out.println(fitered); // [Guava, Java]//自定义过滤条件   使用自定义回调方法对Map的每个Value进行操作ImmutableMap&lt;String, Integer&gt; m = ImmutableMap.of(&quot;begin&quot;, 12, &quot;code&quot;, 15);        // Function&lt;F, T&gt; F表示apply()方法input的类型，T表示apply()方法返回类型        Map&lt;String, Integer&gt; m2 = Maps.transformValues(m, new Function&lt;Integer, Integer&gt;() {            public Integer apply(Integer input) {                if(input&gt;12){                    return input;                }else{                    return input+1;                }            }        });System.out.println(m2);   //{begin=13, code=15}</code></pre><p>set的交集, 并集, 差集</p><pre><code>HashSet setA = newHashSet(1, 2, 3, 4, 5);  HashSet setB = newHashSet(4, 5, 6, 7, 8);  SetView union = Sets.union(setA, setB);    System.out.println(&quot;union:&quot;);  for (Integer integer : union)      System.out.println(integer);           //union 并集:12345867SetView difference = Sets.difference(setA, setB);  System.out.println(&quot;difference:&quot;);  for (Integer integer : difference)      System.out.println(integer);        //difference 差集:123SetView intersection = Sets.intersection(setA, setB);  System.out.println(&quot;intersection:&quot;);  for (Integer integer : intersection)      System.out.println(integer);  //intersection 交集:45</code></pre><p>map的交集，并集，差集</p><pre><code>HashMap&lt;String, Integer&gt; mapA = Maps.newHashMap();mapA.put(&quot;a&quot;, 1);mapA.put(&quot;b&quot;, 2);mapA.put(&quot;c&quot;, 3);HashMap&lt;String, Integer&gt; mapB = Maps.newHashMap();mapB.put(&quot;b&quot;, 20);mapB.put(&quot;c&quot;, 3);mapB.put(&quot;d&quot;, 4);MapDifference differenceMap = Maps.difference(mapA, mapB);differenceMap.areEqual();Map entriesDiffering = differenceMap.entriesDiffering();Map entriesOnlyLeft = differenceMap.entriesOnlyOnLeft();Map entriesOnlyRight = differenceMap.entriesOnlyOnRight();Map entriesInCommon = differenceMap.entriesInCommon();System.out.println(entriesDiffering);   // {b=(2, 20)}System.out.println(entriesOnlyLeft);    // {a=1}System.out.println(entriesOnlyRight);   // {d=4}System.out.println(entriesInCommon);    // {c=3}</code></pre><h4 id="6-检查参数"><a href="#6-检查参数" class="headerlink" title="6.检查参数"></a>6.检查参数</h4><pre><code>//use javaif(list!=null &amp;&amp; list.size()&gt;0)&#39;&#39;&#39;if(str!=null &amp;&amp; str.length()&gt;0)&#39;&#39;&#39;if(str !=null &amp;&amp; !str.isEmpty())//use guavaif(!Strings.isNullOrEmpty(str))//use javaif (count &lt;= 0) {    throw new IllegalArgumentException(&quot;must be positive: &quot; + count);         }    //use guavaPreconditions.checkArgument(count &gt; 0, &quot;must be positive: %s&quot;, count);  </code></pre><p>免去了很多麻烦！并且会使你的代码看上去更好看。而不是代码里面充斥着 <code>!=null</code>， <code>!=&quot;&quot;</code></p><p><strong>检查是否为空,不仅仅是字符串类型，其他类型的判断，全部都封装在 Preconditions类里，里面的方法全为静态</strong></p><p>其中的一个方法的源码</p><pre><code>@CanIgnoreReturnValuepublic static &lt;T&gt; T checkNotNull(T reference) {    if (reference == null) {      throw new NullPointerException();    }    return reference;}</code></pre><table><thead><tr><th>方法声明（不包括额外参数）</th><th>描述</th><th>检查失败时抛出的异常</th></tr></thead><tbody><tr><td>checkArgument(boolean)</td><td>检查boolean是否为true，用来检查传递给方法的参数。</td><td>IllegalArgumentException</td></tr><tr><td>checkNotNull(T)</td><td>检查value是否为null，该方法直接返回value，因此可以内嵌使用checkNotNull。</td><td>NullPointerException</td></tr><tr><td>checkState(boolean)</td><td>用来检查对象的某些状态。</td><td>IllegalStateException</td></tr><tr><td>checkElementIndex(int index, int size)</td><td>检查index作为索引值对某个列表、字符串或数组是否有效。   index &gt; 0 &amp;&amp; index &lt; size</td><td>IndexOutOfBoundsException</td></tr><tr><td>checkPositionIndexes(int start, int end, int size)</td><td>检查[start,end]表示的位置范围对某个列表、字符串或数组是否有效</td><td>IndexOutOfBoundsException</td></tr></tbody></table><h4 id="7-MoreObjects"><a href="#7-MoreObjects" class="headerlink" title="7. MoreObjects"></a>7. MoreObjects</h4><p>这个方法是在Objects过期后官方推荐使用的替代品，该类最大的好处就是不用大量的重写 <code>toString</code>，用一种很优雅的方式实现重写，或者在某个场景定制使用。</p><pre><code>Person person = new Person(&quot;aa&quot;,11);String str = MoreObjects.toStringHelper(&quot;Person&quot;).add(&quot;age&quot;, person.getAge()).toString();System.out.println(str);  //输出Person{age=11}</code></pre><h4 id="8-强大的Ordering排序器"><a href="#8-强大的Ordering排序器" class="headerlink" title="8.强大的Ordering排序器"></a>8.强大的Ordering排序器</h4><p>排序器[Ordering]是Guava流畅风格比较器[Comparator]的实现，它可以用来为构建复杂的比较器，以完成集合排序的功能。</p><pre><code>natural()    对可排序类型做自然排序，如数字按大小，日期按先后排序usingToString()    按对象的字符串形式做字典排序[lexicographical ordering]from(Comparator)    把给定的Comparator转化为排序器reverse()    获取语义相反的排序器nullsFirst()    使用当前排序器，但额外把null值排到最前面。nullsLast()    使用当前排序器，但额外把null值排到最后面。compound(Comparator)    合成另一个比较器，以处理当前排序器中的相等情况。lexicographical()    基于处理类型T的排序器，返回该类型的可迭代对象Iterable&lt;T&gt;的排序器。onResultOf(Function)    对集合中元素调用Function，再按返回值用当前排序器排序。</code></pre><p>示例</p><pre><code>Person person = new Person(&quot;aa&quot;,14);  //String name  ,Integer agePerson ps = new Person(&quot;bb&quot;,13);Ordering&lt;Person&gt; byOrdering = Ordering.natural().nullsFirst().onResultOf(new Function&lt;Person,String&gt;(){    public String apply(Person person){        return person.age.toString();    }});byOrdering.compare(person, ps);System.out.println(byOrdering.compare(person, ps)); //1      person的年龄比ps大 所以输出1</code></pre><h4 id="9-计算中间代码的运行时间"><a href="#9-计算中间代码的运行时间" class="headerlink" title="9.计算中间代码的运行时间"></a>9.计算中间代码的运行时间</h4><pre><code>Stopwatch stopwatch = Stopwatch.createStarted();for(int i=0; i&lt;100000; i++){    // do some thing}long nanos = stopwatch.elapsed(TimeUnit.MILLISECONDS);System.out.println(nanos);</code></pre><p>TimeUnit 可以指定时间输出精确到多少时间</p><h4 id="10-文件操作"><a href="#10-文件操作" class="headerlink" title="10.文件操作"></a>10.文件操作</h4><p>以前我们写文件读取的时候要定义缓冲区，各种条件判断，各种 <code>$%#$@#</code></p><p>而现在我们只需要使用好guava的api 就能使代码变得简洁，并且不用担心因为写错逻辑而背锅了</p><pre><code>File file = new File(&quot;test.txt&quot;);List&lt;String&gt; list = null;try {    list = Files.readLines(file, Charsets.UTF_8);} catch (Exception e) {}Files.copy(from,to);  //复制文件Files.deleteDirectoryContents(File directory); //删除文件夹下的内容(包括文件与子文件夹)  Files.deleteRecursively(File file); //删除文件或者文件夹  Files.move(File from, File to); //移动文件URL url = Resources.getResource(&quot;abc.xml&quot;); //获取classpath根下的abc.xml文件url</code></pre><p>Files类中还有许多方法可以用，可以多多翻阅</p><h4 id="11-guava缓存"><a href="#11-guava缓存" class="headerlink" title="11.guava缓存"></a>11.guava缓存</h4><p>guava的缓存设计的比较巧妙，可以很精巧的使用。guava缓存创建分为两种，一种是CacheLoader,另一种则是callback方式</p><p>CacheLoader:</p><pre><code>LoadingCache&lt;String,String&gt; cahceBuilder=CacheBuilder                .newBuilder()                .build(new CacheLoader&lt;String, String&gt;(){                    @Override                    public String load(String key) throws Exception {                                String strProValue=&quot;hello &quot;+key+&quot;!&quot;;                                        return strProValue;                    }                });        System.out.println(cahceBuilder.apply(&quot;begincode&quot;));  //hello begincode!System.out.println(cahceBuilder.get(&quot;begincode&quot;)); //hello begincode!System.out.println(cahceBuilder.get(&quot;wen&quot;)); //hello wen!System.out.println(cahceBuilder.apply(&quot;wen&quot;)); //hello wen!System.out.println(cahceBuilder.apply(&quot;da&quot;));//hello da!cahceBuilder.put(&quot;begin&quot;, &quot;code&quot;);System.out.println(cahceBuilder.get(&quot;begin&quot;)); //code</code></pre><p>api中已经把apply声明为过期，声明中推荐使用get方法获取值</p><p>callback方式:</p><pre><code> Cache&lt;String, String&gt; cache = CacheBuilder.newBuilder().maximumSize(1000).build();              String resultVal = cache.get(&quot;code&quot;, new Callable&lt;String&gt;() {                  public String call() {                      String strProValue=&quot;begin &quot;+&quot;code&quot;+&quot;!&quot;;                                    return strProValue;                }              });   System.out.println(&quot;value : &quot; + resultVal); //value : begin code!</code></pre><p>以上只是guava使用的一小部分，guava是个大的工具类，第一版guava是2010年发布的，每一版的更新和迭代都是一种创新。</p><p>jdk的升级很多都是借鉴guava里面的思想来进行的。</p><h3 id="小结"><a href="#小结" class="headerlink" title="小结"></a>小结</h3><p>代码可以在 <a href="https://github.com/whirlys/elastic-example/tree/master/guava" target="_blank" rel="noopener">https://github.com/whirlys/elastic-example/tree/master/guava</a> 下载</p><p>细节请翻看 guava 文档 <a href="https://github.com/google/guava/wiki" target="_blank" rel="noopener">https://github.com/google/guava/wiki</a></p><blockquote><p>参考：<br><a href="https://my.oschina.net/u/2551035/blog/802634" target="_blank" rel="noopener">Google guava工具类的介绍和使用</a><br><a href="https://blog.csdn.net/ac_dao_di/article/details/53750028" target="_blank" rel="noopener">Guava工具类学习</a></p></blockquote><hr><p>打开微信扫一扫，关注【小旋锋】微信公众号，及时接收博文推送</p><p><img src="http://image.laijianfeng.org/%E5%B0%8F%E6%97%8B%E9%94%8B%E7%9A%84%E5%BE%AE%E4%BF%A1%E5%85%AC%E4%BC%97%E5%8F%B7_%E4%BA%8C%E7%BB%B4%E7%A0%81.jpg" alt="小旋锋的微信公众号"></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h3 id=&quot;概述&quot;&gt;&lt;a href=&quot;#概述&quot; class=&quot;headerlink&quot; title=&quot;概述&quot;&gt;&lt;/a&gt;概述&lt;/h3&gt;&lt;p&gt;工具类 就是封装平常用的方法，不需要你重复造轮子，节省开发人员时间，提高工作效率。谷歌作为大公司，当然会从日常的工作中提取中很多高效率的方法
      
    
    </summary>
    
      <category term="后端" scheme="http://laijianfeng.org/categories/%E5%90%8E%E7%AB%AF/"/>
    
    
      <category term="java" scheme="http://laijianfeng.org/tags/java/"/>
    
  </entry>
  
  <entry>
    <title>Elasticsearch 中的 Guice</title>
    <link href="http://laijianfeng.org/2018/08/Elasticsearch-%E4%B8%AD%E7%9A%84-Guice/"/>
    <id>http://laijianfeng.org/2018/08/Elasticsearch-中的-Guice/</id>
    <published>2018-08-30T16:39:17.000Z</published>
    <updated>2018-08-30T16:40:14.535Z</updated>
    
    <content type="html"><![CDATA[<h3 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h3><p>Elasticsearch 源代码中使用了Guice框架进行依赖注入. 为了方便阅读源码, 此处我先通过模仿ES guice的使用方式简单写了一个基本Demo 方便理解, 之后再来理一下ES的Guice使用. 编写的测试类原理图如下:</p><p><img src="http://image.laijianfeng.org/2778947-7847f61cf5180bdc.webp" alt="ES Guice Demo"></p><p>总共有两个Module，一个是ToolModule，<strong>用于绑定</strong>IAnimal接口、ITool接口以及Map对象. 另一个是HumanModule 用于绑定Person对象。   </p><p>其中Person的构造函数通过 <code>@Inject</code> 注解注入其他实例</p><p>gradle 需要引入的 Jar 包</p><pre><code>compile group: &#39;com.google.inject.extensions&#39;, name: &#39;guice-multibindings&#39;, version: &#39;4.2.0&#39;compile group: &#39;com.google.inject&#39;, name: &#39;guice&#39;, version: &#39;4.2.0&#39;</code></pre><h3 id="1、Demo"><a href="#1、Demo" class="headerlink" title="1、Demo"></a>1、Demo</h3><h4 id="iTool接口与实现类"><a href="#iTool接口与实现类" class="headerlink" title="iTool接口与实现类"></a>iTool接口与实现类</h4><pre><code>public interface ITool {    public void doWork();}</code></pre><pre><code>import com.whirly.guice.example.ITool;public class IToolImpl implements ITool {    @Override    public void doWork() {        System.out.println(&quot;use tool to work&quot;);    }}</code></pre><h4 id="IAnimal-接口与实现类"><a href="#IAnimal-接口与实现类" class="headerlink" title="IAnimal 接口与实现类"></a>IAnimal 接口与实现类</h4><pre><code>public interface IAnimal {    void work();}</code></pre><pre><code>public class IAnimalImpl implements IAnimal {    @Override    public void work() {        System.out.println(&quot;animals can also do work&quot;);    }}</code></pre><h4 id="ToolModule的实现-它绑了三个实例"><a href="#ToolModule的实现-它绑了三个实例" class="headerlink" title="ToolModule的实现, 它绑了三个实例"></a>ToolModule的实现, 它绑了三个实例</h4><pre><code>public class ToolModule extends AbstractModule {    @Override    protected void configure() {        //此处注入的实例可以注入到其他类的构造函数中, 只要那个类使用@Inject进行注入即可        bind(IAnimal.class).to(IAnimalImpl.class);        bind(ITool.class).to(IToolImpl.class);        // 注入Map实例        MapBinder&lt;String, String&gt; mapBinder = MapBinder.newMapBinder(binder(), String.class, String.class);        mapBinder.addBinding(&quot;test1&quot;).toInstance(&quot;test1&quot;);        mapBinder.addBinding(&quot;test2&quot;).toInstance(&quot;test2&quot;);    }}</code></pre><p><code>bind(IAnimal.class).to(IAnimalImpl.class);bind(ITool.class).to(IToolImpl.class);</code>  是将接口与其具体实现绑定起来</p><p><code>MapBinder&lt;String,String&gt; mapBinder =MapBinder.newMapBinder(binder(), String.class, String.class);mapBinder.addBinding(&quot;test1&quot;).toInstance(&quot;test1&quot;);mapBinder.addBinding(&quot;test2&quot;).toInstance(&quot;test2&quot;);</code> 则是完成Map的绑定. </p><p>后面来看看Person类和HumanModule</p><h4 id="Person-类"><a href="#Person-类" class="headerlink" title="Person 类"></a>Person 类</h4><pre><code>public class Person {    private IAnimal iAnimal;    private ITool iTool;    private Map&lt;String, String&gt; map;    @Inject    public Person(IAnimal iAnimal, ITool iTool, Map&lt;String, String&gt; map) {        this.iAnimal = iAnimal;        this.iTool = iTool;        this.map = map;    }    public void startwork() {        iTool.doWork();        iAnimal.work();        for (Map.Entry entry : map.entrySet()) {            System.out.println(&quot;注入的map 是 &quot; + entry.getKey() + &quot; value &quot; + entry.getValue());        }    }}</code></pre><p>Person 类中由 <code>IAnimal</code>、<code>ITool</code> 和 <code>Map&lt;String, String&gt;</code> 这三个接口定义的变量，对象将通过 <code>@Inject</code> 从构造方法中注入进来</p><pre><code>public class HumanModule extends AbstractModule {    @Override    protected void configure() {        bind(Person.class).asEagerSingleton();    }}</code></pre><p>Person类的构造函数是通过注入的方式，注入对象实例的</p><p>最后 <code>CustomModuleBuilder</code> 进行<strong>统一管理所有的Module</strong>，实例化所有Module中的对象. 完成依赖注入。</p><p>这里的CustomModuleBuilder是修改自Elasticsearch中的ModulesBuilder，其原理是一样的。</p><p>就是一个迭代器，<strong>内部封装的是Module集合, 统一管理所有的Module</strong></p><h4 id="CustomModuleBuilder-统一管理-Module"><a href="#CustomModuleBuilder-统一管理-Module" class="headerlink" title="CustomModuleBuilder 统一管理 Module"></a>CustomModuleBuilder 统一管理 Module</h4><pre><code>public class CustomModuleBuilder implements Iterable&lt;Module&gt; {    private final List&lt;Module&gt; modules = new ArrayList&lt;&gt;();    public CustomModuleBuilder add(Module... newModules) {        for (Module module : newModules) {            modules.add(module);        }        return this;    }    @Override    public Iterator&lt;Module&gt; iterator() {        return modules.iterator();    }    public Injector createInjector() {        Injector injector = Guice.createInjector(modules);        return injector;    }}</code></pre><p>这样就可以从Main方法是如何进行使用的</p><h4 id="Main-方法"><a href="#Main-方法" class="headerlink" title="Main 方法"></a>Main 方法</h4><pre><code>public class Main {    public static void main(String[] args) {        CustomModuleBuilder moduleBuilder = new CustomModuleBuilder();        moduleBuilder.add(new ToolModule());        moduleBuilder.add(new HumanModule());        Injector injector = moduleBuilder.createInjector();        Person person = injector.getInstance(Person.class);        person.startwork();    }}</code></pre><p>运行结果</p><pre><code>use tool to workanimals can also do work注入的map 是 test1 value test1注入的map 是 test2 value test2</code></pre><p>通过CustomModuleBuilder 的createInjector获取Injector 对象, 根据Injector 对象取相应的具体实例对象.</p><h3 id="2、ES-中Guice的使用"><a href="#2、ES-中Guice的使用" class="headerlink" title="2、ES 中Guice的使用"></a>2、ES 中Guice的使用</h3><p>ES中TransportClient初始化时的Guice的使用是这样的, 如下图所示</p><p><img src="http://image.laijianfeng.org/2778947-ab2035e865492a2b.png" alt="ES中TransportClient初始化时的Guice的使用（ES版本不是6.3.2）"></p><h4 id="TransportClient的初始化代码"><a href="#TransportClient的初始化代码" class="headerlink" title="TransportClient的初始化代码"></a>TransportClient的初始化代码</h4><p>Elasticsearch 6.3.2 </p><pre><code>private static ClientTemplate buildTemplate(Settings providedSettings, Settings defaultSettings,                                            Collection&lt;Class&lt;? extends Plugin&gt;&gt; plugins, HostFailureListener failureListner) {    // 省略 ...    try {        // 省略 ...        // 创建一个迭代器, 然后将各个Module通过add方法加入进去        ModulesBuilder modules = new ModulesBuilder();        // plugin modules must be added here, before others or we can get crazy injection errors...        for (Module pluginModule : pluginsService.createGuiceModules()) {            modules.add(pluginModule);        }        modules.add(b -&gt; b.bind(ThreadPool.class).toInstance(threadPool));        ActionModule actionModule = new ActionModule(true, settings, null, settingsModule.getIndexScopedSettings(),                settingsModule.getClusterSettings(), settingsModule.getSettingsFilter(), threadPool,                pluginsService.filterPlugins(ActionPlugin.class), null, null, null);        modules.add(actionModule);        CircuitBreakerService circuitBreakerService = Node.createCircuitBreakerService(settingsModule.getSettings(),            settingsModule.getClusterSettings());        resourcesToClose.add(circuitBreakerService);        PageCacheRecycler pageCacheRecycler = new PageCacheRecycler(settings);        BigArrays bigArrays = new BigArrays(pageCacheRecycler, circuitBreakerService);        resourcesToClose.add(bigArrays);        modules.add(settingsModule);        NetworkModule networkModule = new NetworkModule(settings, true, pluginsService.filterPlugins(NetworkPlugin.class), threadPool,            bigArrays, pageCacheRecycler, circuitBreakerService, namedWriteableRegistry, xContentRegistry, networkService, null);        final Transport transport = networkModule.getTransportSupplier().get();        final TransportService transportService = new TransportService(settings, transport, threadPool,            networkModule.getTransportInterceptor(),            boundTransportAddress -&gt; DiscoveryNode.createLocal(settings, new TransportAddress(TransportAddress.META_ADDRESS, 0),                UUIDs.randomBase64UUID()), null, Collections.emptySet());        modules.add((b -&gt; {            b.bind(BigArrays.class).toInstance(bigArrays);            b.bind(PluginsService.class).toInstance(pluginsService);            b.bind(CircuitBreakerService.class).toInstance(circuitBreakerService);            b.bind(NamedWriteableRegistry.class).toInstance(namedWriteableRegistry);            b.bind(Transport.class).toInstance(transport);            b.bind(TransportService.class).toInstance(transportService);            b.bind(NetworkService.class).toInstance(networkService);        }));        // 注入所有module下的实例        Injector injector = modules.createInjector();        final TransportClientNodesService nodesService =            new TransportClientNodesService(settings, transportService, threadPool, failureListner == null                ? (t, e) -&gt; {} : failureListner);        // construct the list of client actions        final List&lt;ActionPlugin&gt; actionPlugins = pluginsService.filterPlugins(ActionPlugin.class);        final List&lt;GenericAction&gt; clientActions =                actionPlugins.stream().flatMap(p -&gt; p.getClientActions().stream()).collect(Collectors.toList());        // add all the base actions        final List&lt;? extends GenericAction&lt;?, ?&gt;&gt; baseActions =                actionModule.getActions().values().stream().map(ActionPlugin.ActionHandler::getAction).collect(Collectors.toList());        clientActions.addAll(baseActions);        final TransportProxyClient proxy = new TransportProxyClient(settings, transportService, nodesService, clientActions);        List&lt;LifecycleComponent&gt; pluginLifecycleComponents = new ArrayList&lt;&gt;(pluginsService.getGuiceServiceClasses().stream()            .map(injector::getInstance).collect(Collectors.toList()));        resourcesToClose.addAll(pluginLifecycleComponents);        // 启动服务        transportService.start();        transportService.acceptIncomingRequests();        ClientTemplate transportClient = new ClientTemplate(injector, pluginLifecycleComponents, nodesService, proxy, namedWriteableRegistry);        resourcesToClose.clear();        return transportClient;    } finally {        IOUtils.closeWhileHandlingException(resourcesToClose);    }}</code></pre><p>可以看到确实是先通 <code>过ModulesBuilder modules = new ModulesBuilder()</code> 创建一个迭代器, 然后将各个Module通过add方法加入进去, 最后通过 <code>Injector injector = modules.createInjector();</code> 创建Injector对象, <strong>之后便可根据Injector对象去获取实例了</strong>. </p><p>各个Module会绑定自己所需要的实例, 这里以 SettingsModule 举例:</p><pre><code>public class SettingsModule extends AbstractModule {    private final Settings settings;    private final Set&lt;String&gt; settingsFilterPattern = new HashSet&lt;&gt;();    private final Map&lt;String, Setting&lt;?&gt;&gt; nodeSettings = new HashMap&lt;&gt;();    private final Map&lt;String, Setting&lt;?&gt;&gt; indexSettings = new HashMap&lt;&gt;();    private final Logger logger;    private final IndexScopedSettings indexScopedSettings;    private final ClusterSettings clusterSettings;    private final SettingsFilter settingsFilter;    public SettingsModule(Settings settings, Setting&lt;?&gt;... additionalSettings) {        this(settings, Arrays.asList(additionalSettings), Collections.emptyList());    }    @Override    public void configure(Binder binder) {        binder.bind(Settings.class).toInstance(settings);        binder.bind(SettingsFilter.class).toInstance(settingsFilter);        binder.bind(ClusterSettings.class).toInstance(clusterSettings);        binder.bind(IndexScopedSettings.class).toInstance(indexScopedSettings);    }    //...}</code></pre><p>可以看到它绑定了四个,分别是 Settings.class，SettingsFilter.class，ClusterSettings.class，IndexScopedSettings.class</p><p>它们的实例对象都可以通过Injector来获取</p><h3 id="小结"><a href="#小结" class="headerlink" title="小结"></a>小结</h3><p>示例代码可在 <a href="https://github.com/whirlys/elastic-example/tree/master/guice" target="_blank" rel="noopener">https://github.com/whirlys/elastic-example/tree/master/guice</a> 处下载</p><blockquote><p>参考：<br>kason_zhang <a href="https://www.jianshu.com/p/0a1e6267b46f" target="_blank" rel="noopener">Elasticsearch Guice 的使用</a></p></blockquote><hr><p>打开微信扫一扫，关注【小旋锋】微信公众号，及时接收博文推送</p><p><img src="http://image.laijianfeng.org/%E5%B0%8F%E6%97%8B%E9%94%8B%E7%9A%84%E5%BE%AE%E4%BF%A1%E5%85%AC%E4%BC%97%E5%8F%B7_%E4%BA%8C%E7%BB%B4%E7%A0%81.jpg" alt="小旋锋的微信公众号"></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h3 id=&quot;前言&quot;&gt;&lt;a href=&quot;#前言&quot; class=&quot;headerlink&quot; title=&quot;前言&quot;&gt;&lt;/a&gt;前言&lt;/h3&gt;&lt;p&gt;Elasticsearch 源代码中使用了Guice框架进行依赖注入. 为了方便阅读源码, 此处我先通过模仿ES guice的使用方式简单写
      
    
    </summary>
    
      <category term="大数据" scheme="http://laijianfeng.org/categories/%E5%A4%A7%E6%95%B0%E6%8D%AE/"/>
    
    
      <category term="elasticsearch" scheme="http://laijianfeng.org/tags/elasticsearch/"/>
    
  </entry>
  
</feed>
